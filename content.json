{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"lronLin","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2018-05-26T03:20:51.000Z","updated":"2018-05-26T05:25:49.927Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spider","slug":"正则替换-配置国内源,bs获取属性, bs4语法学习-三国演义下载,智联招聘,xpath语法学习","date":"2018-08-10T07:23:11.000Z","updated":"2018-08-10T09:23:32.700Z","comments":true,"path":"2018/08/10/正则替换-配置国内源,bs获取属性, bs4语法学习-三国演义下载,智联招聘,xpath语法学习/","link":"","permalink":"http://yoursite.com/2018/08/10/正则替换-配置国内源,bs获取属性, bs4语法学习-三国演义下载,智联招聘,xpath语法学习/","excerpt":"","text":"1. 正则替换 :1234可替换为固定的字符串 : ret = pattern.sub(&apos;xxx&apos;, string)也可以传递一个函数, 将函数的返回值替换匹配的内容 ret = pattern.sub(fn, string) tihuan.py :1234567891011121314151617181920212223242526import restring = &apos;男生都喜欢20岁的女孩&apos;# ret = string.replace(&apos;18&apos;, &apos;30&apos;)# print(ret)# 里面的数字无论多少都改为30，正则替换# 将正则表达式匹配的内容替换为指定的内容pattern = re.compile(r&apos;\\d+&apos;)# 参数1：要替换的内容# 参数2：在哪个字符串中查找# ret = pattern.sub(&apos;30&apos;, string)# 将这回调函数传递进去，该函数的要求是有一个参数，有一个返回值# 参数就是正则匹配的对象，返回值的作用就是替换正则匹配的字符串def fn(obj): # print(obj) age = int(obj.group()) age += 1 return str(age)ret = pattern.sub(fn, string)print(ret) 2. bs4 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465bs4是什么 ? 是一个Python的第三方模块, 用来解析html数据, 其提供的api接口非常的人性化.安装 : pip install bs4 pip install lxml 这是一个解析器, 用来将文档生成对象有可能出现问题 : 将pip源 切换为国内源, 国内源 : 豆瓣源, 阿里源等如何切换国内源 : (1) 指令切换, -i 源地址 只针对于这一次的指令 (2) 永久切换, 在指定地方写一个配置文件即可 Windows : (1) 在文件资源管理器上面输入 %appdata% (2) 手动创建一个pip的文件夹 (3) 新建一个文件 pip.ini (4) 写入如下内容 : [global] timeout = 6000 index-url = http://pypi.douban.com/simple trusted-host = pypi.douban.com Linux : (1) cd ~ (2) mkdir ~/.pip (3) vi ~/.pip/pip.conf (4) 编辑内容和Windows的内容一模一样语法学习 : from bs4 import BeautifulSoup 步骤 : 通过BeautifulSoup这个类, 可以将你的html文档生成一个对象, 然后这个对象会有一些方法供你使用, 就可以得到你想要的节点内容, 或者节点属性 可以将本地文件或者网络文件生成对象, 先从本地开始学习 (1) 根据标签名进行查找 soup.a 只能得到第一个符合要求的标签 (2) 获取属性 soup.a.attrs 返回一个字典, 里面包含所有的属性和值 soup.a.attrs[&apos;href&apos;] soup.a[&apos;href&apos;] (3) 获取内容 obj.string obj.text obj.get_text() 如果标签里只有内容, 那么三那个获取的结果都一样 如果标签里面还有标签, 那么第一个获取的是None, 后两个获取的是纯文本内容 (4)find方法 soup.find(&apos;a&apos;, title=&apos;xxx&apos;) soup.find(&apos;a&apos;, id=&apos;xxx&apos;) soup.find(&apos;a&apos;, class_=&apos;xxx&apos;) 返回一个对象,只能找到第一个符合要求的节点 选看: soup.find(&apos;a&apos;, class_ = re.compile(r&apos;xxx&apos;)) 可以写正则表达式, 一般用的不多 (5) find_all方法 返回一个列表, 列表里面都是对象 用法和上面的find一样, 只不过这个是找到所有, find只是找到一个 soup.find_all(&apos;a&apos;, limit=2) 取出前两个 (6) select方法 根据选择器得到自己想要的节点 常用的选择器 : 标签选择器 a div 类选择器 .lala .dudu id选择器 #lala #dudu 后代选择器 div .lala a : 后面的是前面的子节点就行 div &gt; p &gt; a : 后面的必须是前面的直接子节点才行 群组选择器 div, #lala, .dudu 属性选择器 input[name=xxx] dic[class=xxx] 返回的是一个列表, 就算选择器精确到一个, 也是一个列表, 列表中只有一个对象 也可以通过子对象来查找内容, 得到当前子对象里面符合要求的标签内容 soup是整个文档对象 soup_test.py :123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试bs4&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; 阿珂 &lt;p&gt;李白&lt;/p&gt; 兰陵王 &lt;p&gt;韩信&lt;/p&gt; 孙悟空 &lt;/div&gt; &lt;div class=&quot;tang&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;www.libai.com&quot; class=&quot;bai lala&quot; title=&quot;李白&quot;&gt;李白乘舟将欲行,忽闻岸上踏歌声,桃花潭水深千尺,不及汪伦送我情&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;www.dufu.com&quot; class=&quot;du&quot; title=&quot;望岳&quot;&gt;会当凌绝顶,一览众山小&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;www.dumu.com&quot; class=&quot;du&quot; id=&quot;后庭花&quot;&gt;停车坐爱枫林晚,霜叶红于二月花,商女不知亡国恨,隔江犹唱后庭花&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;www.lishangyin.com&quot; class=&quot;shangyin&quot;&gt;君问归期未有期,巴山夜雨涨秋池,何当共剪西窗烛,却话巴山夜雨时&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;song&quot;&gt; &lt;li&gt;&lt;a href=&quot;www.qing.com&quot; class=&quot;suqing&quot;&gt;寻寻觅觅,冷冷清清,凄凄惨惨戚戚&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;www.luyou.com&quot; class=&quot;luyou&quot;&gt;王师北定中原日,家祭无忘告乃翁&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;www.su.com&quot; class=&quot;su&quot;&gt;但愿人长久千里共婵娟&lt;/a&gt;&lt;/li&gt; &lt;a href=&quot;www.xiang.com&quot; title=&quot;xiang&quot;&gt;人生自古谁无死,留取丹心照汗青&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; suop.py :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from bs4 import BeautifulSoup# 将文档生成对象# lxml是一个解析器，官方也自带了一个解析器 html.parser, 但是一般都使用lxml，效率更高soup = BeautifulSoup(open(&apos;soup_test.html&apos;, encoding=&apos;utf8&apos;), &apos;lxml&apos;)# 打印对象可以打印为字符串，重写一个方法叫做 __str__# print(type(soup))# 根据标签名进行查找# ret = soup.a# print(ret)# 获取属性# print(ret.attrs[&apos;href&apos;])# print(ret[&apos;href&apos;])# 获取内容# print(ret.string)# print(ret.text)# print(ret.get_text())# ret = soup.div# print(ret.string)# print(ret.text.replace(&apos;\\t&apos;, &apos;&apos;).replace(&apos;\\n&apos;, &apos;&apos;))# print(ret.get_text())# ret = soup.find(&apos;a&apos;, title=&apos;望岳&apos;)# ret = soup.find(&apos;a&apos;, class_=&apos;du&apos;)# ret = soup.find(&apos;a&apos;, id=&apos;后庭花&apos;)# print(ret.string)import re# ret = soup.find(&apos;a&apos;, class_=re.compile(r&apos;^su&apos;))# print(ret)# ret = soup.find_all(&apos;a&apos;)# print(ret[3].string)# ret = soup.find_all(&apos;a&apos;, class_=&apos;du&apos;)# print(ret)# ret = soup.find_all(&apos;a&apos;, class_=re.compile(r&apos;^su&apos;))# print(ret)# ret = soup.find_all(&apos;a&apos;, limit=2)# print(ret)# ret = soup.select(&apos;.song &gt; li &gt; a&apos;)# ret = soup.select(&apos;.song a&apos;)# ret = soup.select(&apos;a[title=xiang]&apos;)# print(ret)# ret = soup.select(&apos;a&apos;)# print(ret)odiv = soup.find(&apos;div&apos;, class_=&apos;song&apos;)# print(odiv)ret = odiv.select(&apos;a&apos;)print(ret) 3. bs4实例 :1234滚滚长江东逝水,浪花淘尽英雄,是非成败转头空,青山依旧在,几度夕阳红白发渔樵江渚上,惯看秋月春风,一壶浊酒喜相逢,古今多少事,都付笑谈中三国演义下载智联招聘 sanguo.py :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import urllib.requestimport timefrom bs4 import BeautifulSoupdef handle_request(url): headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;, &#125; request = urllib.request.Request(url=url, headers=headers) return requestdef parse_first(): url = &apos;http://www.shicimingju.com/book/sanguoyanyi.html&apos; request = handle_request(url) # 发送请求，得到响应 content = urllib.request.urlopen(request).read().decode(&apos;utf8&apos;) # 解析内容 soup = BeautifulSoup(content, &apos;lxml&apos;) # 得到所有的章节链接 oa_list = soup.select(&apos;.book-mulu &gt; ul &gt; li &gt; a&apos;) fp = open(&apos;三国演义.txt&apos;, &apos;w&apos;, encoding=&apos;utf8&apos;) # print(oa_list) # print(len(oa_list)) # 遍历列表，通过对象依次获取内容和链接 for oa in oa_list: # 得到链接 href = &apos;http://www.shicimingju.com&apos; + oa[&apos;href&apos;] # 得到章节标题 title = oa.text print(&apos;正在下载%s......&apos; % title) # 向href发送请求，通过bs得到该章节的内容 text = get_text(href) string = title + &apos;\\n&apos; + text + &apos;\\n&apos; fp.write(string) print(&apos;结束下载%s&apos; % title) time.sleep(2) fp.close()def get_text(href): request = handle_request(href) content = urllib.request.urlopen(request).read().decode(&apos;utf8&apos;) soup = BeautifulSoup(content, &apos;lxml&apos;) odiv = soup.find(&apos;div&apos;, class_=&apos;chapter_content&apos;) return odiv.textdef main(): parse_first()if __name__ == &apos;__main__&apos;: main() zhilian.py :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import urllib.requestimport urllib.parsefrom bs4 import BeautifulSoupimport timeclass ZhiLianSpider(object): def __init__(self, jl, kw, start_page, end_page): # 将这些都保存到成员属性中 self.jl = jl self.kw = kw self.start_page = start_page self.end_page = end_page self.url = &apos;https://sou.zhaopin.com/jobs/searchresult.ashx?&apos; self.headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;, &#125; def run(self): # 打开文件 self.fp = open(&apos;work.txt&apos;, &apos;w&apos;, encoding=&apos;utf8&apos;) # 要爬取多页，所以需要循环爬取 for page in range(self.start_page, self.end_page + 1): print(&apos;正在爬取第%s页......&apos; % page) request = self.handle_request(page) # 发送请求，获取响应 content = urllib.request.urlopen(request).read().decode(&apos;utf8&apos;) # 解析内容 self.parse_content(content) print(&apos;结束爬取第%s页&apos; % page) time.sleep(2) self.fp.close() def parse_content(self, content): # 生成soup对象 soup = BeautifulSoup(content, &apos;lxml&apos;) # 提取内容 # 首先提取所有的table otable_list = soup.find_all(&apos;table&apos;, class_=&apos;newlist&apos;) # print(len(otable_list)) # 过滤掉表头 otable_list = otable_list[1:] # 遍历这个列表，依次提取每一个工作的详细信息 for otable in otable_list: # 职位名称 zwmc = otable.select(&apos;.zwmc &gt; div &gt; a&apos;)[0].text.rstrip(&apos;\\xa0&apos;) # 公司名称 gsmc = otable.select(&apos;.gsmc &gt; a&apos;)[0].string # 职位月薪 zwyx = otable.select(&apos;.zwyx&apos;)[0].string # 工作地点 gzdd = otable.select(&apos;.gzdd&apos;)[0].string # print(zwmc) # exit() # 保存到字典中 item = &#123; &apos;职位名称&apos;: zwmc, &apos;公司名称&apos;: gsmc, &apos;职位月薪&apos;: zwyx, &apos;工作地点&apos;: gzdd, &#125; self.fp.write(str(item) + &apos;\\n&apos;) def handle_request(self, page): # 拼接url # 将get参数写成一个字典 data = &#123; &apos;jl&apos;: self.jl, &apos;kw&apos;: self.kw, &apos;p&apos;: page &#125; # 处理data data = urllib.parse.urlencode(data) url = self.url + data # print(url) request = urllib.request.Request(url=url, headers=self.headers) return requestdef main(): # 工作地点 jl = input(&apos;请输入工作地点:&apos;) # 工作关键字 kw = input(&apos;请输入工作关键字:&apos;) # 起始页码和结束页码 start_page = int(input(&apos;请输入起始页码:&apos;)) end_page = int(input(&apos;请输入结束页码:&apos;)) # 面向对象封装 zhilian = ZhiLianSpider(jl, kw, start_page, end_page) zhilian.run()if __name__ == &apos;__main__&apos;: main() 4. xpath简介 :1234567891011121314151617181920212223242526272829303132333435363738394041xml是什么? 被设计用来传输和存储数据, 和json同处一个位置, 但是目前以json居多 xml和html的不同点 : (1) xml用来传输数据, html用来显示数据 (2) xml的标签没有被定义, html的标签是预定义好的 (3) xml具有自我描述性常用的路径表达式 : / : 从根节点开始查找 // : 从任意位置开始查找 . : 从当前节点开始查找 .. : 从父节点开始查找 @ : 选取属性路径表达式举例 : bookstore/book : 从bookstore下面找book节点, book必须是bookstore的直接子节点 bookstore//book : 从bookstore下面找book节点, book可以是直接子节点也可以是孙子节点 //book : 从文档中任意位置找book节点 //@lang : 查找所有拥有lang属性节点 bookstore/book[1] : 直接子节点第一个book, 下标从1开始 bookstore/book[last()] : 直接字节点最后一个book bookstore//book[last()] : 所有book里面的最后一个 bookstore/book[last() - 1] : 倒数第二个book bookstore/book[position() &lt; 3] : 取出前两个 //title[@lang] : 所有拥有lang属性的title节点 //title[@lang=eng] : 所有的lang属性值为eng的title节点 bookstore/* : bookstore下面所有的直接子节点 bookstore//* : bookstore下面所有的子节点 //title[@*] : 有属性的title节点 //book/title | //book/price : 找到所有book节点下面的直接子节点titlexpath函数 : contains : 包含 starts-with : 以某某开头 ends-with : 以某某结尾(貌似不能用)我们学的xpath是用在了html中, 由于html和xml很像, 所以有一个第三方库就封装了使用xpath来解析html数据的接口, pip install lxml使用的时候, 首先需要使用插件进行测试xpath, 然后再来到代码中进行编写xpath插件使用: (1) 属性筛选 //input[@id=&quot;kw&quot;] 找到属性id值为kw的input节点 (2) 层级筛选 通过属性和层级筛选 //div[@id=&quot;head&quot;]/div/div[@id=&quot;u1&quot;]/a[2]","categories":[],"tags":[{"name":"正则替换-配置国内源,bs获取属性, bs4语法学习-三国演义下载,智联招聘,xpath语法学习","slug":"正则替换-配置国内源-bs获取属性-bs4语法学习-三国演义下载-智联招聘-xpath语法学习","permalink":"http://yoursite.com/tags/正则替换-配置国内源-bs获取属性-bs4语法学习-三国演义下载-智联招聘-xpath语法学习/"}]},{"title":"Spider","slug":"代理池ip,阿布云代理使用,cookie使用,正则简单回顾,正则子模式,糗图正则匹配,正则抓取励志","date":"2018-08-09T11:23:11.000Z","updated":"2018-08-09T11:23:19.656Z","comments":true,"path":"2018/08/09/代理池ip,阿布云代理使用,cookie使用,正则简单回顾,正则子模式,糗图正则匹配,正则抓取励志/","link":"","permalink":"http://yoursite.com/2018/08/09/代理池ip,阿布云代理使用,cookie使用,正则简单回顾,正则子模式,糗图正则匹配,正则抓取励志/","excerpt":"","text":"1. 代理ip池, 阿布云使用 :12见代码 https://www.abuyun.com/http-proxy/dyn-manual.html pool.txt :123456789218.60.8.98:3129122.72.18.34:80124.235.208.252:443182.88.178.229:8123121.43.170.207:31281.71.188.37:3128124.235.208.252:443113.200.56.13:8010114.215.95.188:3128 pool.py :123456789101112131415161718192021222324252627282930313233343536373839404142import urllib.requestimport randomimport timeurl = &apos;http://www.baidu.com/#ie=UTF-8&amp;wd=ip&apos;headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;&#125;request = urllib.request.Request(url=url, headers=headers)# 读取文件fp = open(&apos;pool.txt&apos;, &apos;r&apos;)string = fp.read()fp.close()# print(string)# 将字符串按照换行符切割，得到一个列表，列表里面就是一个一个的代理服务器lt = string.splitlines()# print(lt)while 1: # 从列表中随机抽取一个代理 daili = random.choice(lt) # 发送请求 proxy = &#123;&apos;http&apos;: daili&#125; # 创建handler handler = urllib.request.ProxyHandler(proxies=proxy) # 创建opener opener = urllib.request.build_opener(handler) try: response = opener.open(request) print(&apos;使用代理%s成功&apos; % daili) with open(&apos;ip.html&apos;, &apos;wb&apos;) as fp: fp.write(response.read()) break except Exception as e: # 将这个代理从你的列表移除 lt.remove(daili) print(&apos;使用代理%s失败&apos; % daili) time.sleep(2) abuyun.py :123456789101112131415161718192021222324252627import urllib.requestimport base64user = &apos;HCQ4X00T441PYI5D&apos;pwd = &apos;E8C159C7668242ED&apos;# 将用户名和密码拼接后再转化string = user + &apos;:&apos; + pwd# 进行base64编码ret = &apos;Basic &apos; + base64.b64encode(string.encode(&apos;utf8&apos;)).decode(&apos;utf8&apos;)# print(ret)url = &apos;http://www.baidu.com/s?ie=UTF-8&amp;wd=ip&apos;headers = &#123; &apos;Proxy-Authorization&apos;: ret&#125;# 构建请求对象request = urllib.request.Request(url=url, headers=headers)# handler = urllib.request.ProxyHandler(proxies=&#123;&apos;http&apos;: &apos;http-dyn.abuyun.com:9020&apos;&#125;)opener = urllib.request.build_opener(handler)r = opener.open(request)with open(&apos;ip.html&apos;, &apos;wb&apos;) as fp: fp.write(r.read()) 2. cookie使用 :1234567891011121314151617cookie是什么?http的特点 : 无状态 客户端 服务器 每一次请求都是单独的请求, 请求之间没有任何关系登录时候是一个请求访问登录后的页面又是一个请求, 这两个请求必须有关系,所以引入了cookie登录的时候, 服务端给你响应, 在响应里面就有cookie, 浏览器就会将cookie保存起来, 下次再请求的时候, 就会带着cookie来访问需求 : 通过代码访问登录后的页面 --- 人人网 http://www.renren.com/960481378/profile(1) 通过抓包 首先让浏览器登录成功, 然后让浏览器再访问登录后页面的时候, 你来抓包, 抓取到请求头里面的cookie信息, 然后写到代码中即可 (2) 模拟登录 思路 :首先抓包抓取post请求, 通过代码模拟发送post请求, 然后创建ck对象, 用来保存和携带cookie即可 cookie.py :12345678910111213import urllib.requesturl = &apos;http://www.renren.com/960481378/profile&apos;headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;, &apos;Cookie&apos;: &apos;anonymid=jkl96t9i-7jfkjc; depovince=SC; _r01_=1; _de=F872F5698F7602B30ADE65415FC01940; ln_uact=17701256561; ln_hurl=http://head.xiaonei.com/photos/0/0/men_main.gif; jebe_key=89a1a125-709a-4912-aa70-cbaf2eddd932%7C86ba94a3b75a9848502e25ac92562959%7C1533740001336%7C1%7C1533740008302; jebecookies=f91c2331-f0e2-4c9a-a936-3299112bbed6|||||; JSESSIONID=abcEmpXxJ_WYs8adJICuw; ick_login=a3456fda-f4c3-4dde-98b7-7994763bb807; p=e456fef62e5fb2a7971b6bb34af6b17d8; first_login_flag=1; t=01e2ec7768631eae78816a83379f3f508; societyguester=01e2ec7768631eae78816a83379f3f508; id=960481378; xnsid=e374bf01; ver=7.0; loginfrom=null; wp_fold=0&apos;,&#125;request = urllib.request.Request(url=url, headers=headers)r = urllib.request.urlopen(request)with open(&apos;renren.html&apos;, &apos;wb&apos;) as fp: fp.write(r.read()) moni.py :1234567891011121314151617181920212223242526272829303132333435363738394041424344import urllib.requestimport urllib.parseimport http.cookiejar# 在代码中有没有一个东西和浏览器是一样的，能够保存cookie呢？下次发送的时候自动携带cookie# 首先创建一个cookiejar对象，用来保存cookieck = http.cookiejar.CookieJar()# 根据ck创建一个handlerhandler = urllib.request.HTTPCookieProcessor(ck)opener = urllib.request.build_opener(handler)# 往下所有的请求，都是opener.open()方法发送，那么就会自动保存cookie和携带cookiepost_url = &apos;http://www.renren.com/ajaxLogin/login?1=1&amp;uniqueTimestamp=2018741029602&apos;headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;,&#125;request = urllib.request.Request(url=post_url, headers=headers)formdata = &#123; &apos;email&apos;: &apos;17701256561&apos;, &apos;password&apos;: &apos;lizhibin666&apos;, &apos;icode&apos;: &apos;&apos;, &apos;origURL&apos;: &apos;http://www.renren.com/home&apos;, &apos;domain&apos;: &apos;renren.com&apos;, &apos;key_id&apos;: &apos;1&apos;, &apos;captcha_type&apos;: &apos;web_login&apos;, &apos;f&apos;: &apos;https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3DVwDXbx3oN5RBHzVxzj2jwbsO3z8VmHcZ1HZQTdC3enq%26wd%3D%26eqid%3D834642bf0000b410000000055b6bac87&apos;,&#125;formdata = urllib.parse.urlencode(formdata).encode(&apos;utf8&apos;)r = opener.open(request, data=formdata)# print(r.read().decode(&apos;utf8&apos;))# 假如登录成功get_url = &apos;http://www.renren.com/960481378/profile&apos;request = urllib.request.Request(url=get_url, headers=headers)r = opener.open(request)with open(&apos;renren.html&apos;, &apos;wb&apos;) as fp: fp.write(r.read()) 3. 正则表达式 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354abc123@qq.comtext@163.com为什么引入正则表达式? 字符串的函数string.find(&apos;abc123@qq.com&apos;), 可以查找所有的邮箱, 可以验证邮箱格式是否正确, 可以匹配一类东西, 因为有规则, 学习正则就是学习规则女人的心, 医生的处方, 道士的符, 程序媛的正则1234567\\d&#123;5,7&#125;单字符规则 : \\d : 所有的数字字符 \\D : 非\\d \\w : 数字, 字母, 下划线, 中文 \\W : 非\\w \\s : 匹配所有的空白字符 \\n \\t 空格 \\S : 非\\s [] : [aeiou] 只能匹配其中任意一个字母 . : 除了\\n以外任意字符 [^aeiou] : 除了里面写的都能匹配数量修饰 : &#123;m&#125; : 修饰前面的字符出现m次 &#123;m,&#125; : 修饰前面的字符最少m次 贪婪地 能多匹配就多匹配 &#123;m,n&#125; : 最少m次, 最多n次 &#123;0, &#125; : 任意多次 * &#123;1, &#125; : 最少1次 + &#123;0, 1&#125; : 可有可无 ?在Python里面如何使用? 模块 : import re pattern = re.compile(r&apos;xxx&apos;) 函数 : pattern.match() 从字符串开头查找, 找到一个结束 pattern.search() 从字符串任意位置开始查找, 找到一个立马结束 ret.group() 得到匹配内容 ret.span() 得到匹配位置 pattern.findall() 返回列表, 得到所有匹配的内容边界修饰 : ^ : 以某某开头 $ : 以某某结尾分组 : (正则的高级功能) () 1. 视为一个整体 (a\\d)&#123;5&#125; 2. 子模式, 分组sublime中Ctrl+H --&gt; 正则匹配 (?P&lt;goudan&gt;) (?P=goudan) \\1 \\2 第一, 二个小括号配的内容 $1 $2 第一, 二个小括号匹配的内容 如果有子模式 ret.group(1)就是第一个子模式匹配的内容贪婪 : .* .+ .*? 取消贪婪模式修正 : re.I : 忽略大小写 re.M : 视为多行模式 re.S : 视为单行模式(忽略换行符) re.py :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import re# string = &apos;i love you very love much&apos;# pattern = re.compile(r&apos;love&apos;)# 匹配失败返回None# ret = pattern.match(string)# ret = pattern.search(string)# ret = pattern.findall(string)# print(ret)# 得到匹配的内容, 只匹配一个，成功立马结束# print(ret.group())# print(ret.span())&apos;&apos;&apos;# 子模式string = &apos;哈哈&lt;div&gt;&lt;span&gt;天青色等烟雨,而我在等你&lt;/span&gt;&lt;/div&gt;嘻嘻&apos;pattern = re.compile(r&apos;&lt;(\\w+)&gt;&lt;(\\w+)&gt;.*&lt;/\\2&gt;&lt;/\\1&gt;&apos;)# pattern = re.compile(r&apos;&lt;(?P&lt;goudan&gt;\\w+)&gt;&lt;(?P&lt;maodan&gt;\\w+)&gt;.*&lt;/(?P=maodan)&gt;&lt;/(?P=goudan)&gt;&apos;)ret = pattern.search(string)print(ret.group())print(ret.group(1))print(ret.group(2))&apos;&apos;&apos;&apos;&apos;&apos;# 贪婪模式string = &apos;&lt;div&gt;啦啦啦啦啦啦，我是卖报的小行家&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&apos;pattern = re.compile(r&apos;&lt;div&gt;(.*?)&lt;/div&gt;&apos;)ret = pattern.search(string)print(ret.group(1))&apos;&apos;&apos;&apos;&apos;&apos;# 忽略大小写string = &apos;love is a forever topic&apos;pattern = re.compile(r&apos;LOVE&apos;, re.I)ret = pattern.search(string)print(ret.group())&apos;&apos;&apos;&quot;&quot;&quot;# 多行模式string = &apos;&apos;&apos;细思极恐你的对手在看书你的敌人在磨刀你的闺蜜在减肥隔壁老王在炼腰&apos;&apos;&apos;pattern = re.compile(r&apos;^你的&apos;, re.M)ret = pattern.search(string)print(ret.group())&quot;&quot;&quot;# 单行模式string = &apos;&apos;&apos;&lt;div&gt;沁园春-雪北国风光，千里冰封，万里雪飘望长城内外，惟余莽莽大河上下，顿失滔滔&lt;/div&gt;&apos;&apos;&apos;pattern = re.compile(r&apos;&lt;div&gt;(.*?)&lt;/div&gt;&apos;, re.S)ret = pattern.search(string)print(ret.group(1)) 4. 正则案例 :123456糗事百科糗图 图片下载 : 防盗链, 直接通过urllib.request.urlretrieve()下载不了 在请求头部有一个referer, 判断头部是不是从这个网站过来的, 如果是, 可以看图片, 如果不是, 图片不让看 通过程序看这个图片的时候, 需要手动定制Referer: ,定制为网站的首页即可, 需要通过构建请求对象, 发送请求, qiutu.py :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import urllib.requestimport urllib.parseimport reimport timeimport osdef main(): start_page = int(input(&apos;请输入起始页码:&apos;)) end_page = int(input(&apos;请输入结束页码:&apos;)) url = &apos;https://www.qiushibaike.com/pic/page/&#123;&#125;/&apos; for page in range(start_page, end_page + 1): print(&apos;正在下载第%s页......&apos; % page) # 拼接url，构建请求对象 request = handle_request(url, page) # 发送请求，获取响应 content = urllib.request.urlopen(request).read().decode(&apos;utf8&apos;) # 正则解析内容 parse_content(content) print(&apos;结束下载第%s页&apos; % page) time.sleep(2)def parse_content(content): pattern = re.compile(r&apos;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; /&gt;.*?&lt;/div&gt;&apos;, re.S) ret = pattern.findall(content) # print(ret) # print(len(ret)) # 遍历这个列表，依次下载每一个图片 for tp in ret: # 取出图片的链接 image_src = &apos;https:&apos; + tp[0] # 取出图片的名字 name = tp[1] # 保存图片 dirname = &apos;qiutu&apos; filename = name + &apos;.&apos; + image_src.split(&apos;.&apos;)[-1] filepath = os.path.join(dirname, filename) print(&apos;正在下载%s..&apos; % filename) urllib.request.urlretrieve(image_src, filepath) print(&apos;结束下载%s&apos; % filename) time.sleep(2)def handle_request(url, page): # 拼接url url = url.format(page) # print(url) headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;, &#125; request = urllib.request.Request(url=url, headers=headers) return requestif __name__ == &apos;__main__&apos;: main() lizhi.py :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import urllib.requestimport urllib.parseimport timeimport redef main(): start_page = int(input(&apos;请输入起始页码:&apos;)) end_page = int(input(&apos;请输入结束页码:&apos;)) url = &apos;http://www.yikexun.cn/lizhi/qianming/list_50_&#123;&#125;.html&apos; # 打开文件 fp = open(&apos;lizhi.html&apos;, &apos;w&apos;, encoding=&apos;utf8&apos;) for page in range(start_page, end_page + 1): # 构建请求对象 request = handle_request(url, page) # 发送请求，得到响应 content = urllib.request.urlopen(request).read().decode(&apos;utf8&apos;) # 解析内容 parse_content(content, fp) time.sleep(2) fp.close()def parse_content(content, fp): pattern = re.compile(r&apos;&lt;div class=&quot;art-t&quot;&gt;.*?&lt;a href=&quot;(.*?)&quot;&gt;(&lt;b&gt;)?(.*?)(&lt;/b&gt;)?&lt;/a&gt;.*?&lt;/div&gt;&apos;, re.S) ret = pattern.findall(content) # 遍历列表，取出标题和链接 for tp in ret: href = &apos;http://www.yikexun.cn&apos; + tp[0] title = tp[2] # 取出b标签 # title = title.strip(&apos;&lt;/b&gt;&apos;) text = get_text(href) # 打开文件，写入文件中 string = &apos;&lt;h1&gt;%s&lt;/h1&gt;%s&apos; % (title, text) fp.write(string) time.sleep(2)def get_text(href): # 构建请求对象 request = handle_request(href) content = urllib.request.urlopen(request).read().decode(&apos;utf8&apos;) pattern = re.compile(r&apos;&lt;div class=&quot;neirong&quot;&gt;(.*?)&lt;/div&gt;&apos;, re.S) ret = pattern.search(content) # print(ret.group(1)) # exit() return ret.group(1)def handle_request(url, page=None): if page: url = url.format(page) headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos; &#125; request = urllib.request.Request(url=url, headers=headers) return requestif __name__ == &apos;__main__&apos;: main() test.py :123456789101112131415161718# &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;,# &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;,# &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;,# &apos;Cache-Control&apos;: &apos;max-age=0&apos;,# &apos;Connection&apos;: &apos;keep-alive&apos;,# &apos;Cookie&apos;: &apos;BIDUPSID=6F6C332F8A0E3C9949BD5D9F884F1FFB; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BAIDUID=EFDAC6F7D747687E9C719E50A41D707F:FG=1; PSTM=1533783169; BD_UPN=12314353; delPer=0; BD_HOME=0; BD_CK_SAM=1; PSINO=3; H_PS_PSSID=1435_21117_20927; H_PS_645EC=3a04mDqnf2AOXeU2n6NNCFlEHTqg2o6UIX4PAa801GwAZ5PgQkN95DF2qY8; BDSVRTM=0&apos;,# &apos;Host&apos;: &apos;www.baidu.com&apos;,# &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,# &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&apos;,# string = &apos;我叫&#123;&#125;, 我喜欢&#123;&#125;, 我最&#123;&#125;&apos;# string = &apos;我叫&#123;2&#125;, 我喜欢&#123;1&#125;, 我最&#123;0&#125;&apos;# string = &apos;我叫&#123;name&#125;, 我喜欢&#123;like&#125;, 我最&#123;lala&#125;&apos;# print(string.format(like=&apos;周星驰&apos;, lala=&apos;朱茵&apos;, name=&apos;疯狂&apos;))# string = &apos;&lt;b&gt;b有b没有那么一首b歌，可以让我跟着和&lt;/b&gt;&apos;# string = string.strip(&apos;&lt;/b&gt;&apos;)# print(string)","categories":[],"tags":[{"name":"代理池ip,阿布云代理使用,cookie使用,正则简单回顾,正则子模式,糗图正则匹配,正则抓取励志","slug":"代理池ip-阿布云代理使用-cookie使用-正则简单回顾-正则子模式-糗图正则匹配-正则抓取励志","permalink":"http://yoursite.com/tags/代理池ip-阿布云代理使用-cookie使用-正则简单回顾-正则子模式-糗图正则匹配-正则抓取励志/"}]},{"title":"Spider","slug":"parse,构建请求,模拟请求Handler","date":"2018-08-09T10:58:11.000Z","updated":"2018-08-09T10:58:20.243Z","comments":true,"path":"2018/08/09/parse,构建请求,模拟请求Handler/","link":"","permalink":"http://yoursite.com/2018/08/09/parse,构建请求,模拟请求Handler/","excerpt":"","text":"1. urllib.parse :1234567891011处理参数或者url的urllib.parse.quote() url编码 https://www.baidu.com/s?ie=UTF-8&amp;wd=%E5%91%A8%E6%9D%B0%E4%BC%A6 字母, 数字, 下划线, 冒号 // ? =等 如果有其他字符, 需要进行编码urllib.parse.unquote() url解码 [注] 编码的时候只需要编码参数即可urllib.parse.urlencode(data) data是一个字典，直接将字典的建和值转化为query_string格式，并且实现url编码 2. 构建请求对象 :1request = urllib.request.Request(url=url, headers=headers) 3. 模拟各种请求方式 :123456789101112131415161718get 百度搜素post 百度翻译 urlopen(url, data=None) 如果有data，代表是post请求，如果没有data，代表是get请求，get的参数需要拼接到url的后面 表单数据的处理 formdata = urllib.parse.urlencode(formdata).encode(&apos;utf8&apos;)ajax-get 豆瓣电影排行榜 https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;start=40&amp;limit=20 每页显示10条数据 第一页：start=0 limit=10 第二页：start=10 limit=10 第三页：start=20 limit=10 第n页： start=(n-1)*10 limit=10ajax-post 肯德基店铺位置 4. URLError / HTTPError :1234567是异常处理类, 属于urllib.error这个模块URLError : 断网或者主机不存在的时候会触发 mi.com jd.comException : 官方的异常基类, 所有的异常类都直接或者间接的继承它HTTPError : 是URLError的子类, 如果多个except同时捕获，注意将子类写到上面，将父类写到下面 5. 复杂的get :123456百度贴吧第一页：https://tieba.baidu.com/f?kw=%E6%9D%8E%E6%AF%85&amp;ie=utf-8&amp;pn=0第二页：https://tieba.baidu.com/f?kw=%E6%9D%8E%E6%AF%85&amp;ie=utf-8&amp;pn=50第三页：https://tieba.baidu.com/f?kw=%E6%9D%8E%E6%AF%85&amp;ie=utf-8&amp;pn=100第n页：pn = (n-1) * 50需求：输入贴吧名字，输入要爬取的起始页码，结束页码，以贴吧的名字创建一个文件夹，将每一页的内容全部拿下来保存到第n页.html文件中 6. Handler处理器, 自定义Opener :12345678910111213141516171819urlopen()请求对象为了解决代理和cookie这些更加高级的功能而引入的实现最简单的功能, 高级功能的步骤和这个步骤一模一样import urllib.requesturl = &apos;http://www.baidu.com/&apos;# 创建handlerhandler = urllib.request.HTTPHandler()# 根据handler创建openeropener = urllib.request.build_opener(handler)# 发送请求的时候, 不要使用urlopen发送, 使用opener.open()response = opener.open(url)print(response.read().decode(&apos;utf8&apos;)) 7. 代理 :12345生活中代理 : 代练, 代驾, 代孕, 代购程序中 : 见代理小弟图代理服务器: 快代理, 西刺代理, 芝麻代理, 阿布云代理 (1) 浏览器如何设置代理 (2) 代码中如何设置代理 parse.py :123456789101112131415161718192021222324252627282930313233343536import urllib.parse# url = &apos;https://www.baidu.com/s?ie=UTF-8&amp;wd=周杰伦&apos;# string = urllib.parse.quote(url)# string1 = urllib.parse.unquote(string)# print(string)# print(string1)# urlencodeurl = &apos;https://www.baidu.com/s?&apos;# 将get参数写到这里data = &#123; &apos;ie&apos;: &apos;utf8&apos;, &apos;wd&apos;: &apos;周杰伦&apos;&#125;query_string = urllib.parse.urlencode(data)url += query_stringprint(url)&apos;&apos;&apos;# 将data拼接到url的后面，组成完整的url# 遍历这个字典，拼接为指定格式lt = []for k, v in data.items(): value = k + &apos;=&apos; + v lt.append(value)# 将lt用&amp;符号拼接起来即可query_string = &apos;&amp;&apos;.join(lt)url += query_stringprint(url)&apos;&apos;&apos; request_obj.py :123456789101112131415161718import urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contexturl = &apos;http://www.baidu.com/&apos;# 如何定制UA# 在这个头部不仅可以定制ua，还可以定制其他的请求头部，一般只需要定制uaheaders = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;&#125;# 构建请求对象request = urllib.request.Request(url=url, headers=headers)# 发送请求，直接打开这个请求对象即可response = urllib.request.urlopen(request) get_params.py :1234567891011121314151617181920212223242526272829import urllib.requestimport urllib.parse# 让用户输入搜索关键字keyword = input(&apos;请输入要搜索的关键字:&apos;)url = &apos;https://www.baidu.com/s?&apos;# get参数data = &#123; &apos;ie&apos;: &apos;utf8&apos;, &apos;wd&apos;: keyword,&#125;query_string = urllib.parse.urlencode(data)url += query_string# 向url发送请求，得到响应headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.3&apos;,&#125;request = urllib.request.Request(url=url, headers=headers)response = urllib.request.urlopen(request)# 拼接文件名字filename = keyword + &apos;.html&apos;# 写入到文件中with open(filename, &apos;wb&apos;) as fp: fp.write(response.read()) 1- post.py :123456789101112131415161718import urllib.requestimport urllib.parseurl = &apos;http://fanyi.baidu.com/sug&apos;# 将表单数据写成一个字典formdata = &#123; &apos;kw&apos;: &apos;baby&apos;&#125;# 将formdata单独处理一下formdata = urllib.parse.urlencode(formdata).encode(&apos;utf8&apos;)headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.3&apos;,&#125;# 构建请求对象request = urllib.request.Request(url=url, headers=headers)response = urllib.request.urlopen(request, data=formdata)print(response.read().decode(&apos;utf8&apos;)) 2 - post.py : 123456789101112131415161718192021222324252627282930313233343536373839import urllib.requestimport urllib.parse# 加密的接口，如果想要得到，需要破解url = &apos;http://fanyi.baidu.com/v2transapi&apos;word = &apos;wolf&apos;# 表单数据formdata = &#123; &apos;from&apos;: &apos;en&apos;, &apos;to&apos;: &apos;zh&apos;, &apos;query&apos;: word, &apos;transtype&apos;: &apos;realtime&apos;, &apos;simple_means_flag&apos;: &apos;3&apos;, &apos;sign&apos;: &apos;275695.55262&apos;, &apos;token&apos;: &apos;268ca3a468d99f5aac3a179efad0ab28&apos;,&#125;# 处理表单数据formdata = urllib.parse.urlencode(formdata).encode(&apos;utf8&apos;)headers = &#123; # &apos;Accept&apos;: &apos;*/*&apos;, # 将其注释掉，索要完整的格式 # &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, # &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;, # &apos;Connection&apos;: &apos;keep-alive&apos;, # 将其注释掉，让其自动计算即可 # &apos;Content-Length&apos;: &apos;120&apos;, # &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;, &apos;Cookie&apos;: &apos;BAIDUID=55279ECD6DDA84C66A41BA7CC1E6840E:FG=1; PSTM=1533627007; BIDUPSID=6F6C332F8A0E3C9949BD5D9F884F1FFB; PSINO=3; BDRCVFR[Y1-7gJ950Fn]=jCHWiyEa0lYpAN8n1msQhPEUf; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; H_PS_PSSID=1465_26963_26432_21099_26350_26925_22157; locale=zh; to_lang_often=%5B%7B%22value%22%3A%22en%22%2C%22text%22%3A%22%u82F1%u8BED%22%7D%2C%7B%22value%22%3A%22zh%22%2C%22text%22%3A%22%u4E2D%u6587%22%7D%5D; REALTIME_TRANS_SWITCH=1; FANYI_WORD_SWITCH=1; HISTORY_SWITCH=1; SOUND_SPD_SWITCH=1; SOUND_PREFER_SWITCH=1; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1533694190; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1533694190; from_lang_often=%5B%7B%22value%22%3A%22zh%22%2C%22text%22%3A%22%u4E2D%u6587%22%7D%2C%7B%22value%22%3A%22en%22%2C%22text%22%3A%22%u82F1%u8BED%22%7D%5D&apos;, &apos;Host&apos;: &apos;fanyi.baidu.com&apos;, &apos;Origin&apos;: &apos;http://fanyi.baidu.com&apos;, &apos;Referer&apos;: &apos;http://fanyi.baidu.com/?aldtype=16047&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;, &apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,&#125;request = urllib.request.Request(url=url, headers=headers)response = urllib.request.urlopen(request, data=formdata)print(response.read().decode(&apos;utf-8&apos;)) ajax_get.py :123456789101112131415161718192021222324import urllib.requestimport urllib.parseurl = &apos;https://movie.douban.com/j/chart/top_list?type=5&amp;interval_id=100%3A90&amp;action=&amp;&apos;print(&apos;每页显示10条数据&apos;)page = int(input(&apos;请输入页码:&apos;))# 根据page计算出来start和limitstart = (page-1) * 10limit = 10data = &#123; &apos;start&apos;: start, &apos;limit&apos;: limit,&#125;url += urllib.parse.urlencode(data)headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;,&#125;request = urllib.request.Request(url=url, headers=headers)response = urllib.request.urlopen(request)print(response.read().decode(&apos;utf8&apos;)) ajax_post.py :1234567891011121314151617181920import urllib.requestimport urllib.parseurl = &apos;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname&apos;city = input(&apos;请输入要搜索的城市:&apos;)data = &#123; &apos;cname&apos;: city, &apos;pid&apos;: &apos;&apos;, &apos;pageIndex&apos;: &apos;1&apos;, &apos;pageSize&apos;: &apos;10&apos;&#125;data = urllib.parse.urlencode(data).encode(&apos;utf8&apos;)headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;,&#125;request = urllib.request.Request(url=url, headers=headers)response = urllib.request.urlopen(request, data=data)print(response.read().decode(&apos;utf8&apos;)) error.py :12345678910111213141516171819202122232425262728293031import urllib.requestimport urllib.error# 动物 人类 男人累、女人泪 红旭&apos;&apos;&apos;url = &apos;http://www.maodan.com/&apos;# response = urllib.request.urlopen(url)try: response = urllib.request.urlopen(url)# except Exception as e:except urllib.error.URLError as e:# except NameError as e: 这个不能捕获 print(e)print(&apos;不影响这一句代码的运行&apos;)&apos;&apos;&apos;url = &apos;https://www.cnblogs.com/fh-fendou/p/7479811.html&apos;try: response = urllib.request.urlopen(url)# except urllib.error.HTTPError as e:except (urllib.error.URLError, urllib.error.HTTPError) as e: print(e) print(&apos;httperror&apos;)# except urllib.error.URLError as e:# print(e)# print(&apos;urlerror&apos;)print(&apos;正常运行&apos;) tieba.py :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import urllib.requestimport urllib.parseimport osimport timedef main(): baming = input(&apos;请输入要爬取的贴吧的名字:&apos;) start_page = int(input(&apos;请输入要爬取的起始页码:&apos;)) end_page = int(input(&apos;请输入要爬取的结束页码:&apos;)) url = &apos;https://tieba.baidu.com/f?&apos; for page in range(start_page, end_page + 1): print(&apos;正在爬取第%s页......&apos; % page) # 根据url和page拼接指定页码的url request = handle_request(page, baming, url) # 根据请求对象发送请求得到响应写入到指定的文件中 down_load(request, baming, page) print(&apos;结束爬取第%s页&apos; % page) time.sleep(3)def down_load(request, baming, page): response = urllib.request.urlopen(request) # 通过代码创建指定的文件夹 dirname = baming # 判断不存在的时候创建 if not os.path.exists(dirname): os.mkdir(dirname) # 文件的名字 filename = &apos;第%s页.html&apos; % page # 得到文件的路径 filepath = os.path.join(dirname, filename) # 将内容直接写入到filepath中 with open(filepath, &apos;wb&apos;) as fp: fp.write(response.read())def handle_request(page, baming, url): pn = (page-1) * 50 # 拼接url data = &#123; &apos;kw&apos;: baming, &apos;ie&apos;: &apos;utf8&apos;, &apos;pn&apos;: pn &#125; url += urllib.parse.urlencode(data) # print(url) headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;, &#125; # 构建请求对象 request = urllib.request.Request(url, headers=headers) return requestif __name__ == &apos;__main__&apos;: main() handler.py :123456789101112import urllib.requesturl = &apos;http://www.baidu.com/&apos;# 创建handlerhandler = urllib.request.HTTPHandler()# 根据handler创建openeropener = urllib.request.build_opener(handler)# 发送请求的时候，不要使用urlopen发送，使用opener.open()response = opener.open(url)print(response.read().decode(&apos;utf8&apos;)) daili.py :12345678910import urllib.requesturl = &apos;http://www.baidu.com/s?ie=UTF-8&amp;wd=ip&apos;handler = urllib.request.ProxyHandler(proxies=&#123;&apos;http&apos;: &apos;218.60.8.98:3129&apos;&#125;)opener = urllib.request.build_opener(handler)r = opener.open(url)with open(&apos;代理.html&apos;, &apos;wb&apos;) as fp: fp.write(r.read())","categories":[],"tags":[{"name":"urllib.parse,构建请求,模拟请求,Handler,代理","slug":"urllib-parse-构建请求-模拟请求-Handler-代理","permalink":"http://yoursite.com/tags/urllib-parse-构建请求-模拟请求-Handler-代理/"}]},{"title":"Spider","slug":"认识爬虫","date":"2018-08-09T09:43:11.000Z","updated":"2018-08-09T09:44:23.554Z","comments":true,"path":"2018/08/09/认识爬虫/","link":"","permalink":"http://yoursite.com/2018/08/09/认识爬虫/","excerpt":"","text":"1.爬虫概念 ：123456爬虫是什么?生活角度理解, 蜘蛛(spider)互联网: 节点就是a链接(url)统一资源定位符 - 通过a链接一步一步跳转 - 就可以访问所有资源互联网爬虫 : 写一个程序, 根据url去抓取指定的内容 都有哪些语言可以实现爬虫 :1234(1) php : 号称世界上最好的语言, (后端语言 : php, java, python), 可以实现爬虫, 缺点 : 天生对多进程和多线程支持的不好(2) java : 可以实现爬虫功能, 而且做的非常好, 是Python爬虫最主要的竞争对手 , 缺点 : 语言不简洁, 代码臃肿, 重构成本高(3) C, C++ : 也可以实现爬虫, 非常强大, 编程语言排行榜, 如果实现爬虫功能, 只能说你牛, 但不是一个好的选择(4) Python : 可以实现, 号称世界上最优雅的语言, 代码简洁, 学习成本低, 执行效率也好, 而且还有一个非常强大的爬虫框架 (scrapy) 通用爬虫 :12345例子 : 百度, 谷歌, 360, 搜狗, 必应等等, 搜索引擎就是一种爬虫 搜索引擎做的工作 : (1) 爬取互联网所有的数据 (2) 对数据存储并且处理 (3) 给用户提供检索服务 如何让百度抓取你的网站?123(1) 静静地等待, 百度会和DSN服务商合作(2) 主动提交自己的url(3) 在其他网站设置友情链接 - bootstrap的图标使用 我的网站不想让百度抓取?12(1) 与百度商量好的, 君子协议, 口头协议, robots协议(爬虫协议, 机器协议)(2) 存放到网站的根目录下, 限制搜索引擎可以爬取哪些, 不可以爬取哪些, 所以自己写得程序就不遵从了robots协议 网站排名 (SEO): 通过SEO优化网站12(1) pagerank值排名, 根据点击量, 浏览量等, 相当靠谱 - 口碑(2) 竞价排名, 魏泽西事件 通用爬虫缺点 :12(1) 抓取很多数据都是无效的(2) 不能根据自己的需求抓取数据 聚焦爬虫 :123456根据自己特定的需求, 来抓取指定的数据 如何实现聚焦爬虫 ? 网页的特点 : (1) 网页都有自己唯一的url (2) 网页都是由html组成 (3) 网页传输都是使用http, https组成 思路 :123(1) 提供一个url(2) 模拟浏览器发送http请求(3) 从http结构中提取指定的数据, 从字符串中根据规则提取指定数据 开发环境 :1(1) Windows系统 , Python 3.x(64位) , sublime编辑器, pycharm编辑器, vscode 整体内容 :1234567891011121314(1) 涉及到的Python的库 : urllib , requests, selenium, jsonxpath, lxml等一些库 (2) 解析内容 正则表达式解析, bs4解析, xpath解析, jsonpath解析 (3) 采集动态html DOM操作, 动态的添加或者删除节点, selenium+phantomjs (4) scrapy框架 异步高性能网络爬虫框架的学习 (5) scrapy-redis分布式部署 在scrapy的基础上, 多了一套分布式部署的组件 (6) 涉及到的爬虫-反爬虫-反反爬虫之间的斗争 反爬会伤害真实的用户, 一般情况下, 反爬也就这么两点 : 第一个UA, 第二个封IP, 第三个验证码, 光学识别(软件), 打码平台 换思路解决问题 : 其他网站, 手机端等 2.http协议 :书 : &lt;&lt;图解http协议&gt;&gt; 12345678910协议是什么? : 协议就是规定好的传输方式上网原理 : 看图行 锚点 : 跳转可以实现本页面的跳转http与https的区别 : http://www.cnblogs.com/wqhwe/p/5407468.html http://www.cnblog.com/10158wsj/p/6762848.html HTTPS和HTTP的区别主要如下 :1234567891011121. https协议需要到ca申请证书, 一般免费证书较少, 因而需要一定费用2. http是超文本传输协议, 信息是明文传输, https则是具有安全性的ssl加密传输协议3.http和https使用的是完全不同的连接方式, 用的端口也不一样, 前者是80, 后者是4434.http的连接很简单, 是无状态的, HTTPS协议是由SLS+HTTP协议构建的可进行加密传输, 身份认证的网络协议, 比http协议安全 加密 : 公钥私钥 客户端 : 123456用秘钥加密======&gt;&gt;服务端 : 用秘钥解密得到123456 秘钥相同称之为对称加解密 秘钥不相同称之为非对称加解密 客户端 : 123456用公钥加密======&gt;&gt;服务端 : 用私钥解密得到123456 http协议学习 :1234图解http协议 http://www.cnblog.com/10158wsj/p/6762848.html http协议是基于tcp的, 交互之前建立连接, 三次握手 udp传输协议, 只需要知道ip和端口即可发送消息 请求 :12345678910111213包含请求行, 请求头, 请求内容请求行 : 请求方式, 请求资源, 协议版本号请求头 : accept : 浏览器通过这个头告诉服务器, 它所支持的数据类型 Accept-Charset : 浏览器通过这个头告诉服务器, 它支持哪种字符集 Accept-Encoding : 浏览器通过这个头告诉服务器, 支持的压缩格式 Accept-Language : 浏览器通过这个头告诉服务器, 它的语言环境 Host : 浏览器通过这个头告诉服务器, 想访问哪台主机 If-Modified-Since : 浏览器通过这个头告诉服务器, 缓存数据的时间 Referer : 浏览器通过这个头告诉服务器, 客户机是哪个页面来的, 防盗链 Connection : 浏览器通过这个头告诉服务器, 请求完后是断开链接还是继续链接 X-Requested-With : XMLHttpRequest 代表ajax的请求 响应 :12345678910111213141516响应行, 响应头, 响应内容响应行里面, 常见的状态码响应头 : 对我们来说不重要 Location : 服务器通过这个头, 来告诉浏览器跳到哪里 Server : 服务器通过这个头, 告诉浏览器服务器的型号 Content-Encoding : 服务器通过这个请求头, 告诉浏览器, 数据的压缩格式 Content-Length : 服务器通过这个头, 告诉浏览器回送数据的长度 Content-Language: 服务器通过这个头，告诉浏览器语言环境 Content-Type ：服务器通过这个头，告诉浏览器回送数据的类型 Refresh ：服务器通过这个头，告诉浏览器定时刷新 Content-Disposition : 服务器通过这个头，告诉浏览器以下载方式打数据 Transfer-Encoding ：服务器通过这个头，告诉浏览器数据是以分块方式回送的 Expires: -1 控制浏览器不要缓存 Cache-Control: no-cache Pragma: no-cache 响应内容：html、css、js、图片 3.抓包工具 :(1) 谷歌浏览器自带抓包工具1234右键开发者工具 ==&gt; network XHR : XMLHttpRequest 前端要想发送ajax请求, 通过它创建对象，发送请求 query_string_parameters : 请求字符串, get参数 formdata : 如果是post参数 (2) 专业工具 fiddler12345678910111213141516171819202122232425专业抓包工具, 比谷歌强在了跳转的时候很多请求都能抓取到 见文档 1.配置抓取 2.清楚所有请求 3.暂停和启动抓包 4.fiddler介绍 左边栏 : 显示所有的请求 &lt;&gt; : 代表的是html请求 右边栏 : 点击某个请求, 查看这个请求的详细信息 选中Inspectors 右上 : 请求信息 raw : 有关所有请求的纯文本内容 WebForms : 请求的参数 上面 : query_string get参数 下面 : body post参数 右下 : 响应信息 raw : 以纯文本的形式响应所有的内容 json : 如果响应为json格式数据, 在这里查看 左下角黑色窗口输入指令 : cls : 清除掉所有请求 select html : 选择html请求 select js : ?baidu : 4.urllib库 :12345678910111213141516171819202122232425262728293031323334urllib 库是什么 ? 自带的Python库, 模拟浏览器发送http请求Python 2系列 : urllib urllib2Python 3系列 : urllib 三个模块 : 1. urllib.request 模拟发送请求 函数 : urlopen() urlretrieve() 2. urllib.parse 处理参数或者url 3. urllib.error 如何处理异常 urllib.request 模拟发送请求 urlopen(url) : 向url发送请求，得到响应对象 urlretrieve(url, filepath) ： 向url发送请求，直接将响应写入到filepath中 response属性和方法 字符串格式==》字节格式 encode(&apos;utf8&apos;) 字节格式==》字符串格式 decode(&apos;gbk&apos;) response.read() : 读取字节格式内容 response.url : 获取请求url response.headers: 响应头部 response.status: 状态码 https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533639915215&amp;di=1bbd3901c9991b363ac0211dc861a909&amp;imgtype=0&amp;src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F225a5f3f75d1d4c59532704782eebd25d323fd801e57a-VlY5c4_fw658 下载图片：得到图片的src属性，就可以将图片下载到本地 urllib.parse 处理参数或者url urllib.error 如何处理异常sublime使用方法 : 插件安装 : 首先安装插件管理器(package control)见文档 安装插件 : Ctrl+shift+p imesupport 解决光标跟随问题 anaconda python只能提示工具 emmet html快速插件 [注] sublime 安装完毕之后, 默认会自动关联Python的可执行程序, 如果没有自动关联, 点击tools里面的build system，手动选择python，如果还不行，自己按照固定的格式新建一个build system即可，如果还不行，算了，别用了 fiddler的使用方法 :12345678910111213141516171819202122232425262728293031321、配置抓取https包 tools==》teletick options==》https 选中capture https connects\\decrypt https traffic\\ingnore xxxx 点击actions==》trust root certificate 配置完毕，重启fiddler让其生效 如果有问题，参考这个博客 https://blog.csdn.net/d1240673769/article/details/742984292、清楚所有请求 叉号==》remove all3、暂停和启动抓包 file==&gt;capture traffic4、fiddler介绍 左边栏 显示所有的请求 &lt;&gt; : 代表的是html请求 右边栏 点击某个请求，查看这个请求的详细信息 选中inspectors 右上：请求信息 raw：有关所有请求的纯文本内容 webforms：请求参数 上面：query_string get参数 下面：body post参数 右下：响应信息 raw：所有响应的纯文本内容 json：如果响应为json格式数据，在这里查看 左下角黑色窗口输入指令 cls：清除掉所有请求 select html: 选择html请求 select js: 选择js请求 ?baidu: 选择带baidu的请求 常见的http状态码 :123456789101112131415161718192021222324252627282930313233343536373839100：继续 客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。101： 转换协议 在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。102：继续处理 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。200：请求成功 处理方式：获得响应的内容，进行处理（重要）201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到 处理方式：爬虫中不会遇到202：请求被接受，但处理尚未完成 处理方式：阻塞等待204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL（永久重定向，重要）302：请求到的资源在一个不同的URL处临时保存 处理方式：重定向到临时的URL（临时重定向，重要）304：请求的资源未更新 处理方式：丢弃，使用本地缓存文件（没有发送请求，用的是本地缓存文件，重要）400：非法请求 处理方式：丢弃401：未授权 处理方式：丢弃403：禁止 处理方式：丢弃（重要）404：没有找到 处理方式：丢弃（重要）405：请求方式不对（了解）500：服务器内部错误 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。（服务器问题，代码有问题，重要）501：服务器无法识别 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。502：错误网关 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。503：服务出错 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。 sublime安装流程 :123456789101112131415161718安装 package control , 按view下面的 show console, 输入如下指令敲enter即可import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read())解决输入pci，找不到包库的问题在view-show console里面输入如下指令，敲enterimport urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-、package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)解决鼠标跟随问题 安装IMESupport插件代码提示插件 Anaconda终止程序运行 Tools==&gt;Cancel Build 设置快捷键 &#123; &quot;keys&quot;: [&quot;ctrl+shift+p&quot;], &quot;command&quot;: &quot;cancel_build&quot; &#125;","categories":[],"tags":[{"name":"关于爬虫","slug":"关于爬虫","permalink":"http://yoursite.com/tags/关于爬虫/"}]},{"title":"Django","slug":"axf项目部署上线流程","date":"2018-07-23T03:02:11.000Z","updated":"2018-07-23T03:03:13.263Z","comments":true,"path":"2018/07/23/axf项目部署上线流程/","link":"","permalink":"http://yoursite.com/2018/07/23/axf项目部署上线流程/","excerpt":"","text":"初始化服务器 :云服务器ESC - 进入实例化 - 选择实例ID/名称 -&gt; 实例状态停止 - 重新初始化磁盘 - 输入root密码 - 初始化成功后自动启动成功后就可以在控制台直接进行测试环境部署了(CentOS7部署). 安装python3.6 :在centos中，系统默认只提供python2.7的版本，但是项目我们使用的python3.6的版本。所有我们自己安装python3 安装Python3的方法首先安装依赖包 123yum -y groupinstall &quot;Development tools&quot;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 然后根据自己需求下载不同版本的Python3，我下载的是Python3.6.2 12345678wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz然后解压压缩包，进入该目录，安装Python3tar -xvJf Python-3.6.2.tar.xzcd Python-3.6.2./configure --prefix=/usr/local/python3make &amp;&amp; make install 最后创建软链接 123ln -s /usr/local/python3/bin/python3 /usr/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 安装MariaDB : – 数据库安装命令 1yum -y install mariadb mariadb-server 安装完成MariaDB，首先启动MariaDB 1systemctl start mariadb 设置开机启动 1systemctl enable mariadb 设置密码命令: mysql_secure_installation 12345678910111213141516171819202122Enter current password for root:&lt;–初次运行直接回车设置密码Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车(一般输入y)New password: &lt;– 设置root用户的密码(输入个人数据库密码123456)Re-enter new password: &lt;– 再输入一次你设置的密码(再一次输入个人数据库密码123456)其他配置Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，j回车(一般选择Y)Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车(一般选择n)Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车(一般选n不删除)Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车(一般选y重写加载)初始化MariaDB完成，接下来测试登录mysql -u root -p(进入数据库) 连接本地数据库 :1234567在Navicat工具中新建连接 - 选择MariaDB连接名 : 个人ip(120.79.135.242) 或者自定义名称主机名或IP地址 : 个人ip(120.79.135.242)端口 : 默认3306用户名 : root密码 : 输入刚刚新设置的个人数据库新密码(123456)测试连接成功即可 开启远程连接在mysql数据库中的user表中可以看到默认是只能本地连接的，所有可以添加一个新的用户，该用户可以远程访问 1. 创建用户12345678# 先使用数据库use mysql;(请先输入这个命令)# 针对ip# create user &apos;root&apos;@&apos;192.168.10.10&apos; identified by &apos;password&apos;;# 全部 create user &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;;(一般使用数据库后创建全部password改为个人密码123456) 2. 授权1234567891011121314151617# 给用户最大权限grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;;(一般使用最大权限 - 个人数据库密码password改为个人密码123456)# 给部分权限(test 数据库)# grant all privileges on test.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos; with grant option;# 刷新权限表flush privileges;(接着使用这个)# 查看# show grants for &apos;root&apos;@&apos;localhost&apos;;接下来就可以在远程的数据库可视化工具中直接访问该服务器中的mysql了。# 访问数据库mysql -u root -p(接着) 配置文件 :123456此路径切换到home : root/python-3.6.2 # cd /home/此路径下创建四个文件 root/home : mkdir env logs src confenv : 放虚拟环境logs : 放日志src : 放项目(代码)conf : 放配置文件 安装环境 :123456789101. 安装virtualenv 此路径下root/home : yum install python-virtualenv is this ok[y/d/N] : y2. 创建虚拟环境 此路径root/home/env : virtualenv --no-site-packages axfenv # 激活虚拟环境 进入此路径root/home/env/axfenv/bin : source activate # 退出虚拟环境 此路径root/home/env/axfenv/bin : deactivate 将代码传输到服务器 :123此路径root/home/src : 连接Xftp 6 : 服务器此路径/home/src : 找到自己项目代码本地所在路径(C:workspace/projects/axf) 点击右键传输 部署该部署采用的是cenots7系统来部署 Django的项目中，在工程目录下settings.py文件中有一个DEBUG=True参数，如果DEBUG=False则会出现js,css，img无法加载的情况出现。 原因如下： Django框架仅在开发模式下提供静态文件服务。当我开启DEBUG模式时，Django内置的服务器是提供静态文件的服务的，所以css等文件访问都没有问题，但是关闭DEBUG模式后，Django便不提供静态文件服务了。想一想这是符合Django的哲学的：这部分事情标准服务器都很擅长，就让服务器去做吧！ 1. 测试环境中部署方式urls.py中的修改在测试环境中一般都直接使用python manage.py runserver的方式去运行项目。其中就涉及到DEBUG=False的修改，静态目录的修改等，具体修改如下： 12345678910111213141516171819202122231.此路径root/home/src/axf : vim axf/settings.py 修改settings.py配置文件中的DEBUG=False模式 修改ALLOEWD_HOST=[&apos;*&apos;] (允许访问的ip)2.修改工程目录下的urls.py此路径root/home/src/axf : vim axf/urls.pyfrom django.views.static import serve(需导包)urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^axf/&apos;, include(&apos;axf.urls&apos;, namespace=&apos;axf&apos;)), # 增加以下的url路由 url(r&apos;^static/(?P&lt;path&gt;.*)$&apos;, serve, &#123;&quot;document_root&quot;: settings.STATICFILES_DIRS[0]&#125;), url(r&apos;^media/(?P&lt;path&gt;.*)$&apos;, serve, &#123;&quot;document_root&quot;: settings.MEDIA_ROOT&#125;), url(r&apos;^$&apos;, views.home)] 安装环境需要的包:123456789此路径创建文件root/home/src/axf : touch re_install.txt此路径创建文件root/home/src/axf : vim re_install.txt django==1.11 pymysql pillow# 进入虚拟环境此路径root/home/env : source axfenv/bin/activate# 找到代码 并指定文件 安装环境此路径root/home/src/axf : pip3 install -r re_install.txt 创建数据库 : 本地数据库迁移 : 表/字段/数据同步到远程服务器1234567891011进入Navicat 在连接的Maria DB120.79.135.242中 : # 创建数据库 数据库名 : axf3 字符集 : utf8 排序规则 : utf8_general_ci # 数据传输 源 目标 本地服务器 同步到 远端服务器(120.79.135.242)数据库 axf3 axf3 同步对象 表 启服务:12345678(axfenv)root/home/src/axf : python3 manage.py runserver 0.0.0.0:80网页中访问 : 120.79.135.242即可服务器执行中会报302 : 权限问题 中间件 - 重定向问题 复制SSH渠道 : 查看中间件 # 添加static 此路径root/home/src/axf : vim utils/UserAuthMiddleware.py # 添加media 此路径root/home/src/axf : vim axf/urls.py 中间件的修改 : 添加static/media路径(正则匹配)如图 :如果中间件是过滤哪些地址不需要登录验证的话, 就可以设置如下的static和media过滤地址的参数: urls.py配置文件修改如图 : 以上启动服务是在虚拟环境中的启动的 : python3 manage.py runserver 0.0.0.0:80 将启动服务的命令写入一个文件在后端启动 :1234567891011121314151617181920212223242526272829303132此路径root/home/env/axfenv : netstat -lntp # 查看启动的端口此路径启服务(axfenv)root/env/axf : /home/env/axfenv/python3 manage.py runserver 0.0.0.0:80此路径后台启服务(axfenv)root/env/axf : python3 manage.py runserver 0.0.0.0:80 &amp;杀进程 : kill -9 80端口进程号28491# 创建一个start.sh文件此路径root/home/src/axf : vim start.sh此文件中输入执行的命令 : python3 manage.py runserver 0.0.0.0:80 保存此路径root/home/env : rm -rf axfenv/ 删除虚拟环境重新创建虚拟环境 : 此路径root/home/env : virtualenv --no-site-packages -p /usr/local/python3/bin/python3 axfenv激活虚拟环境 : root/home/env : source axfenv/bin/activate查看python3的路径 : pwd启动服务 : 直接启动文件root/home/src/axf: ./start.sh # 权限限制授权 : root/home/src/axf : chmod -R 777 start.sh查看长格式 : ls -l虚拟环境中创建包(axfenv)root/home/src/axf : pip3 install -r re_install.txt安装包成功后可直接启动文件root/home/src/axf : ./start.sh挂载起来可直接访问页面启动命令(关闭服务器窗口后也可访问页面) root/home/src/axf : nohup ./start/sh查看控制台打印的内容(会输出到nuhup.out的文件中 - 此文件自动生成) : root/home/src/axf : tail -f nohup.out (f表示展示的行数) 中间件配置 加入首页:123root/home/src/axf : vim utils/UserAuthMiddleware.py加入首页后重启服务 : root/home/src/axf : tail -f nohup.out302 : 重定向 安装虚拟环境后 - 创建文件 - 自动启服务 - 三点左右正式环境中部署 :正式环境中部署由nginx + uwsgi来部署django项目 安装nginx添加nginx存储库 - root/home/src/axf : 1yum install epel-release Is this ok [y/d/N] : y 安装nginx - root/home/src/axf : 1yum install nginx Is this ok [y/d/N] : y 运行nginx nginx不会自行启动, 要运行Nginx 1systemctl start nginx django常见的部署方式 : nginx + uwsgi / Apache(阿帕奇)等不是固定的组合 root/home/src/axf查看进程 : netstat -lntp 杀掉80端口进程关掉测试环境项目 nginx的运行命令 : 12systemctl status nginx 查看nginx的状态systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动 浏览器端直接访问IP : 120.79.135.242 显示如图页面nginx方可安装成功 : 配置uwsgi :安装uwsgi: - (axfenv) root/home/src/bin :1pip install uwsgi 配置项目代码，配置项目nginx，配置uwsgi.ini等本案例的配置文件，都习惯将每一个项目的配置文件，日志文件，虚拟环境放在一起，这样开发方便，运维也方便维护 项目的目录结构如下： 其中： conf是配置文件，用于存放项目的nginx.conf文件，uwsgi.ini文件 logs是日志文件，用于存放nginx的启动成功和失败文件，以及uwsgi的运行日志文件 env是用于存放虚拟环境 src是项目文件，该目录下上传的是目录代码 4.1 配置nginx.conf文件首先：编写自己项目的nginx.conf文件如下： 每一个项目对应有一个自己定义的nginx的配置文件，比如爱鲜蜂项目，我定义为axfnginx.conf文件 : 1(axfenv)root/home/conf : vim axfnginx.conf 配置uwsgi文件 :在conf文件夹下除了包含自定义的axfnginx.conf文件，还有我们定义的uwsgi.ini文件 : 1(axfenv)root/home/conf : vim /etc/nginx/nginx.conf 第二个include处添加 : 此操作完成后查看nginx状态 : 1(axfenv)root/home/conf : systemctl status nginx 接着重新启动nginx : 1(axfenv)root/home/conf : systemctl restart nginx 启动uwsgi : 1(axfenv)root/home/conf : uwsgi --ini uwsgi.ini","categories":[],"tags":[{"name":"axf项目部署","slug":"axf项目部署","permalink":"http://yoursite.com/tags/axf项目部署/"}]},{"title":"Django","slug":"表单与Cookie与Settings","date":"2018-07-07T02:09:11.000Z","updated":"2018-07-07T02:09:12.927Z","comments":true,"path":"2018/07/07/表单与Cookie与Settings/","link":"","permalink":"http://yoursite.com/2018/07/07/表单与Cookie与Settings/","excerpt":"","text":"模型:1234567urls : 所有的映射templates 模板 : 里面放的才是视图 - 子文件夹 - 模板页控制器接收用户的请求与输入 - 对模型进行增删改查 - 把最后操作的结果显示出来控制器(视图函数)作用 : 1.接收和验证用户的输入 2.对模型进行CRUD(增删改查)的操作 - 这里不用写SQL语句, 直接使用django的ORM框架(自动发SQL语句)进行面向对象的操作 - 自己所要做的就是定义好模型 3.为用户生成(渲染)视图 templates模板配置:1&apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)], static静态资源配置:123css/js/imagesSTATICFILES_DIRS = [os.path.join(BASE_DIR, &apos;static&apos;)]STATIC_URL = &apos;/static/&apos; # 浏览器访问静态资源的路径清晰 /static/images/1.jpg : 可以看到图片 本地MySQL安装流程 :12启动mysql57服务 : net start mysql57或者计算机右键 - 管理 - 服务 - 手动启mysql57 类与类 :12345678910类与类之间的关系 : is-a - 继承(学生是人, 人是动物) has-a - 关联(聚合/合成)(老板有一辆汽车)(学生有电脑) - 一个类的属性又是另一个类的对象 - 强关联(引擎是车的一部分) use-a - 依赖(我使用了这个水杯) - 对象方法的参数或返回值是另一个对象class Person(object): def miehuo(meihuoqi): pass def buy_house(): return House()对象与对象之间的关系: 映射:12Django框架中包含了ORM(对象关系映射)框架ORM可以帮助我们完成对象模型到关系模型的双向转换 函数:123456整个页面加载完成后的回调函数:$(function() &#123; # 绑定事件 # ajax请求 &#125;); 一对一是一对多的特例 : unique=True / OneToOne 实际开发中多对多会转换成 两个一对多关系 提示中 : m表示方法, f表示属性 用户看到空白页 = 违反最小惊讶原则 因特网 : 基于tcp/ip协议构建的网络 互联网 : 什么协议都可以 总结 :1234567知识点一 : 模型一对多外键关联知识点二 : 请求视图函数时往里面传参知识点三 : 利用ORM框架 - 通过学科反查老师, 如果禁用反查应该怎么写 - 用学科编号查老师知识点四 : 如果请求不是页面请求, ajax, json 好评/差评 - a标签绑定事件源 编程大师 - 马丁富乐 - 代码的坏味道 - 重复是最坏的味道 完整路径 : get_full_path 注 : s为路径 / 多个url可以对应到一个视图CSRF - 跨站身份伪造 : 避免跨站身份伪造 : 加入令牌 - {csrf_token}1234好处 : 1.防止跨站身份伪造 2.防止网络重放攻击 3.防止表单重复提交 sha1摘要 - 算法 / md5算法 :1234567哈希码 - 数字摘要 - 数字指纹 - 数字签名密码原文 --- 单向哈希函数 ---&gt; 摘要(不用存明文)MD5 : 长度 - 128bitSHA1 : 长度 - 160bitSHA256: 长度 - 256bitSHA512 : 长度 - 512bit百度云盘 : 秒传 - 根本没有上传 - 只是上传了一个摘要 - 服务器上有这个资源 生成摘要 : 创建对象 - 底层分配内存 - 复制对象(内存拷贝) - python底层用C语言写得 面向对象七个设计原则 :12345671.单一职责原则2.开闭原则 3.依赖倒转原则 4.里氏替换原则5.接口隔离原则 6.合成聚合复用原则 7.迪米特法则 表单:1wiget小组件 - 指表单中的表单控件 ORM :123456拿到集合 - 拿到指定主键的老师 - :冒号后面的内容就用到了ORM框架ctx = &#123;&apos;teachers_list&apos;: list(Teacher.objects.all())&#125;# 自定义模型Teacher一定要继承models - 才能使用ORM框架# Django框架中包含了ORM(对象关系映射)框架# ORM可以帮助我们完成对象模型到关系模型的双向转换 Cookie:1234567891011# 因为HTTP协议本身是一个无状态协议(不能在两次请求之间保存用户的相关信息),所以服务器为了实现用户跟踪(收到请求时要识别是不是之前访问过的用户)就要使用其他的辅助方式# 目前实现用户跟踪最常用的手段是使用Cookie(保存在浏览器中的临时数据)# 我们在Cookie中可以保存一个sessionid(用户跟服务器进行会话的唯一标识)# 每次浏览器向服务器发送HTTP请求时会在请求头中携带Cookie(也就是携带了sessionid)# 服务器通过sessionid就可以确定请求来自于之前访问过服务器的哪个用户# 如果浏览器发起的请求中没有Cookie或者Cookie中没有sessionid的信息,那么服务器会认为这是一个新的请求那么会给新的请求分配sessionid并将其写入浏览器# 对于新的请求服务器会分配sessionid并将其写入浏览器的Cookie中# 在默认情况下Djanngo对session做了持久化(保存在django_session表中)# 如果要清理django_session表中过期的会话数据可以执行下面的命令 : python manage.py clearsessions 设置会话:12345678910# 设置是否在关闭浏览器窗口时让会话过期()# 如果设置为True表示Cookie是基于浏览器窗口的而不是持久化的# 只要浏览器窗口一关闭Cookie就自动消失了(没有持久化) SESSION_EXPIRE_AT_BROWSER_CLOSE = False# Cookie的过期时间(以秒为单位)# Django框架默认的 SESSION_COOKIE_AGE = 1800 1 + n 查询问题 :123select_related(&apos;subject&apos;)方法将1 + n --&gt; 连查解决 : 连查 配置已安装的应用 :123456789INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;应用名(APP)&apos;,] 中间件:123456789MIDDLEWARE = [ &apos;django.middleware.security.SecurityMiddleware&apos;, &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;, &apos;django.middleware.common.CommonMiddleware&apos;, &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, &apos;django.contrib.messages.middleware.MessageMiddleware&apos;, &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,] 配置模板 :123456789101112131415TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)], # 配置路径 &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 配置数据库 :1234567891011DATABASES = &#123; &apos;default&apos;: &#123; # 引擎 ENGINE &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, # 数据库类型 &apos;NAME&apos;: &apos;应用名&apos;, &apos;HOST&apos;: &apos;阿里云或者本地数据库&apos;, &apos;PORT&apos;: 端口号, &apos;USER&apos;: &apos;超级用户&apos;, &apos;PASSWORD&apos;: &apos;密码&apos;, &#125;&#125; 语言与时区设置 :1234567891011LANGUAGE_CODE = &apos;zh-hans&apos;TIME_ZONE = &apos;Asia/Chongqing&apos;# 国际化 - internationalizationUSE_I18N = True# 本地化 - localizationUSE_L10N = TrueUSE_TZ = True 序列化设置 :1234# 序列化 - 把对象写入数据流 - 串行化 / 归档 / 腌咸菜# 反序列化 - 从数据流中恢复出对象 - 反串行化 / 解归档# Python有三个支持序列化的模块 :# json - JSON / pickle - 二进制 / shelve 1234# 设置Django框架Session序列化的方式为PickleSerializer# 从Django 1.6开始Django框架默认的序列化方式是JsonSerializationSESSION_SERIALIZER = &apos;django.contrib.sessions.serializers.PickleSerializer&apos; 静态资源设置 :1234567# 配置静态资源的目录 STATICFILES_DIRS = [os.path.join(BASE_DIR, &apos;static&apos;)]# 配置统一资源定位符 STATIC_URL = &apos;/static/&apos; 配置日志 :可以配多个handlers level : 日志级别(五级) - DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL 项目上线日志级别配置 : WARNING 或者 ERROR 1234567891011121314151617# 配置将日志输出到控制台日志级别为DEBUG(最详细的日志)# DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICALLOGGING = &#123; &apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: False, &apos;handlers&apos;: &#123; &apos;console&apos;: &#123; &apos;class&apos;: &apos;logging.StreamHandler&apos;, &#125;, &#125;, &apos;loggers&apos;: &#123; &apos;django&apos;: &#123; &apos;handlers&apos;: [&apos;console&apos;], &apos;level&apos;: os.getenv(&apos;DJANGO_LOG_LEVEL&apos;, &apos;DEBUG&apos;), &#125;, &#125;,&#125; 子类重写父类方法 :123456789# save方法 - 子类继承父类时对方法进行子类重写父类方法(重点) - 在save时对密码进行摘要 def save(self, force_insert=False, force_update=False, using=None, update_fields=None): # 外部创建一个对象 - 用时复制对象 hasher = proto.copy() # 更新需要摘要的内容 hasher.update(self.password.encode(&apos;utf-8&apos;)) # 拿到一个16进制形式的摘要 self.password = hasher.hexdigest() super().save(force_insert, force_update, using, update_fields) 数据库中索引 : 建目录 - 加速查询周末作业 : 车辆违章查询 - 添加违章记录 / 查询违章记录","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"Web应用与Django","slug":"Web应用与Django","date":"2018-07-02T12:42:11.000Z","updated":"2018-07-02T12:42:34.958Z","comments":true,"path":"2018/07/02/Web应用与Django/","link":"","permalink":"http://yoursite.com/2018/07/02/Web应用与Django/","excerpt":"","text":"静态页面 — 动态页面 :页面中的内容是动态生成的页面中的内容是用程序自动生成的Python(的程序) —&gt; HTML(页面)Web应用:(可以做服务器端的应用程序) - 知识点一//123456789知识点一 : Web应用 - 基于浏览器来使用的应用程序 只要有网络和浏览器就能使用它如果应用程序升级那么用户不用做任何特殊处理 计算机网络诞生:(发展史) 分组交换网 - ARPANET 国际标准化组织 ISO 开放系统互联参考模型 - OIS / RM TCP / IP模型 1991年 - 浏览器出现了 PHP / ASP / JSP - P值得是page 应用级协议: 知识点二 //HTTP(s) - 应用级协议 - 使用了TCP协议的传输服务 HTTP / HTTPS : 应用级协议 - 底层传输协议 - TCP - 保证可靠通信 / 数据不流失 TCP / IP模型 : 四层(面试)1物理链路层(解决分帧 + 校验) -&gt; 两台计算机就可以通信了 - 网络层(IP协议 / TCMP协议-协议族)(解决寻址与路由)-&gt; 端到端的数据传输 - 传输层(TCP(承诺三件事) / UDP) -&gt; 解决端到端的可靠通信 - 应用层(定义应用级协议)(QQ - ICQ协议 / QQ协议(现用) / HTTP / HTTPS / SMTP / FTP / Telnet / SSH) 冗余校验码(科普): 浏览器中 : 有渲染引擎与JS引擎 术语: (面试)123456789URL/URI : 统一资源定位符/统一资源标识符，网络资源的唯一标识域名 : 与Web服务器地址对应的一个易于记忆的字符串名字DNS : 域名解析服务，可以将域名转换成对应的IP地址(翻译成ip地址就可以访问服务器)IP地址 : 网络上的主机的身份标识，通过IP地址可以区分不同的主机(路由器通过ip地址找到你)HTTP : 超文本传输协议，基于TCP建立可靠传输的应用层协议，万维网数据通信的基础(浏览器与服务器之间传输的载体)反向代理 : 代理客户端向服务器发出请求，然后将服务器返回的资源返回给客户端(存在web浏览器 与 web服务器之间)(请求发送给反向代理 - 反向代理帮你找到离你最近的服务器)Web服务器 : 接受HTTP请求，然后返回HTML文件、纯文本文件、图像等资源给请求者(支撑HTTP请求 - 部署在上面)Nginx : 高性能的Web服务器，也可以用作反向代理，负载均衡 和 HTTP缓存(体积小, 性能好) - 俄罗斯人出品的 - 最好的服务器另外还有一个阿帕奇服务器 - 美国人出品的 页面 / js / 静态资源 - 返回给用户界面 URL :1协议://IP地址或域名:端口号/路径1/路径2/资源 HTTP :12345678910111213141516171819HTTP请求（请求行+请求头+空行+[消息体]）：(所用工具 - Ethereal --&gt;现在的名字 Wireshark)例子: 网卡设置成混杂模式 - 可以看到用户名与密码(如果没有走TCP-HTTPS协议) 抓取HTTP协议下的数据: HTTP(s) ---&gt; Charles(花瓶) - 抓包工具 Chrome ---&gt; 开发人员工具HTTP响应（响应行+响应头+空行+消息体）：常用请求 : get请求 / post请求 index/ : 代表首页 \\r\\n : 代表换行 冒号 : 键值对存在 冒号前是键 , 冒号后是值 如果是post请求 : 空行后面有消息体 如果是get请求 : 空行后面没有消息体 405 : 请求方法不正确 403 : 禁止访问 401 : 授权访问 500: 服务器错误(500开头都是) 404 : 请求资源不存在 HTTP请求（请求行+请求头+空行+[消息体]） HTTP响应（响应行+响应头+空行+消息体） Django概念:12345Python的Web框架中比较有名的有：Flask、Django、Tornado、Pyramid、Bottle、Web2py、web.py等企业开发 - 最好是Java产品快速占领市场 : Python / PHPPython中有35个关键字做web应用需要MVC架构 版本关系: MVC架构模式: 12345678model : 程序中的数据view : 展现给用户看的页面(同样的数据可以展现出不同的视图/ 同一个视图可以加载不同的模型)controller : 控制器, 负责把分离的视图与模型结合起来(连接视图与模型的桥梁)架构理念 : 模型与理念分开 : 数据与数据的解耦合解耦合 : 高内聚, 低耦合高内聚 : 低耦合 : 模块与模块之间标签装数据 / 样式表渲染页面 MTV:123model : 模型Template : 模板view : 控制 内容管理系统 —&gt; Django - Web框架: 知识点三 //1234567891011121314151617181920212223检查版本 : python --version先建项目文件夹 : mkdir hellodjango再建虚拟环境目录 : 方法一 :python3 -m venv venv(虚拟环境目录文件夹) 方法二 : virtualenv --no-site-packages helloenv进入虚拟环境文件夹 : cd helloenv / cd venv cd Scripts / cd bin激活虚拟环境 : source venv/bin/activate(阿里云)/activate(Windows) / source activate更新pip环境 : python -m pip install -U pip安装django : pip install django(如果没有指定版本, 就装的是最新的稳定版本)查看django版本 : django-admin --version创建项目 : django-admin startproject hellodjango .运行服务器 : python manage.py runsever 172.18.206.219:80终止服务器 : Ctrl + c创建应用 : python manage.py startapp demo(应用名称)包 : __init__.py视图 : views.py - (控制器)模型 : models.py应用 : app.py迁移 : migrations - 数据迁移DIRS: 目录绝对路径 : abspath路径连接 : &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)],渲染 : render 总结 : ​ 1.Web应用及其特点 , 流程 ​ 2.HTTP(s) - 应用级协议 - 使用了TCP协议的传输服务 ​ 3.Django - Web框架 - MVC架构模式(MV*) - [放之四海而皆知] - MTV","categories":[],"tags":[{"name":"Web与Django","slug":"Web与Django","permalink":"http://yoursite.com/tags/Web与Django/"}]},{"title":"hexo","slug":"搭建个人博客","date":"2018-06-30T02:14:11.000Z","updated":"2018-06-30T02:14:59.384Z","comments":true,"path":"2018/06/30/搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/06/30/搭建个人博客/","excerpt":"","text":"使用hexo和github搭建个人博客声明: 以下所有操作都是在windows操作系统下进行 什么是Hexo ?Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1. 安装在安装Hexo前我们需要电脑已经安装以下程序 : Node.js Git 这两个程序的安装很简单, windows用户可以使用安装程序进行安装, 简单高效. 请务必将这两个程序安装好, 否则我们不能进行以下操作. 1-1-1安装GitWindows用户建议使用这个下载地址下载, 找到合适的版本进行下载安装即可, 安装时的操作请自行参考百度 1-1-2安装Node.jsWindows用户安装这个最好也是下载对应的安装程序进行安装, 这里也请参考百度 值得一提的是建议不要下载最新的版本, 尽量下载大多数人用的版本. 1-1-3安装Hexo检查是否安装好以上两个程序, 在桌面点击鼠标右键, 选择 在打开的类似Linux的命令行中输入命令; 1$ git --version 1$ node --version 在以上的两个必备的应用程序安装完成之后我们可以安装Hexo了. 使用如下命令安装 1$ npm install -g hexo-cli 2. 建站2-1 初始化安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt; # folder 是文件夹 即 hexo init 文件夹$ cd &lt;folder&gt;$ npm install 命令执行成功没有 error 错误的时候，我们就建站成功了； 2-2 安装server并启动接着执行以下命令。 1$ npm install hexo-server --save 1$ hexo server 2-3 进入默认主题博客这两条命令执行完成后会生成一个如下的地址： 我们把这个网址复制下来并粘贴到浏览器中打开即可看到 Hexo 默认的主题博客了，如果没有成功的话建议查看自己是否有操作不当的地方或者命令错误。 3. 部署3-1 建立Git仓库因为要使用到 Git ， 所以我们需要先建立一个新的仓库，建立仓库这个就不再赘述，这里只做简要的描述，不会的同学还请自行百度=。= 注意: 这里在建仓库的时候, 仓库的名字一定要按照 &lt;用户名&gt;.github.io 这样的格式来写 3-2 生成SSH keys这个很重要！ 这个如果没有添加 ssh keys 那么等会必定会报错。 使用如下操作生成SSH key 生成密钥完成后， 我们将 id_rsa.pub 中的所有内容拷贝到github中相应的位置中去。 找到 github 中的设置 : 生成一个新的SSH key 并将我们生成的在 id_rsa.pub 中的内容 拷贝到其中 添加到其中即可 3-3 更该配置在你的初始化文件夹下找到 _config.yml 这个文件并打开 这里最好使用 Sublime或者 Hbuilder 打开. 打开后做如下修改，这里注意空格 repository 就是 github 为我们生成的一个地址。 3-4 生成静态网页并部署123$ hexo clean # 清理缓存$ npm install hexo-deployer-git --save$ hexo g -d 最后最后在浏览器中输入我们的地址即可 即 username.github.io 其中username为你自己创建仓库的名字","categories":[],"tags":[{"name":"搭建个人博客","slug":"搭建个人博客","permalink":"http://yoursite.com/tags/搭建个人博客/"}]},{"title":"Flask","slug":"Flask部署项目","date":"2018-06-30T01:59:21.000Z","updated":"2018-06-30T01:59:42.683Z","comments":true,"path":"2018/06/30/Flask部署项目/","link":"","permalink":"http://yoursite.com/2018/06/30/Flask部署项目/","excerpt":"","text":"Flask项目部署项目生产环境Flask + mariadb + uwsgi + nginx12345678910111. 服务器系统Centos7.42.数据库mariadb redis 3. 程序运行环境python3.x 由于Centos系统中自带的python版本是的2.x版本的.没有python3. 所以说需要我自己进行安装. 介绍了这么多就开始我们安装我们需要的软件和环境. 1. 安装python3首先需要安装python3的依赖包,可以复制下面的两行命令进行安装 123yum -y groupinstall &quot;Development tools&quot;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 安装好相关的依赖包之后要根据我们自己的项目需求选择对应的python3的版本,我这里使用的是python3.6.5的版本 123使用wget命令下载我们的python3wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xz 我是是用的root账户登录的系统,所以默认的下载文件的地址是在[/root的目录].这样我们是用命令进入root目录找到我们python3.6.5程序使用xz命令进行文件的解压 1234567# 解压文件xz -d Python-3.6.5.tar.xz# 解归档tar -xvf Python-3.6.5.tar 切换至Python源代码目录并执行下面的命令进行配置和安装。 1234567891011# 切换到源代码目录cd Python-3.6.5# 配置./configure --prefix=/usr/local/python36 --enable-optimizations# 编译和安装make &amp;&amp; make install 执行上面的三条命令,然后我们就要经历10-20分钟左右的等待(取决于机器的配置).执行完成后会看到Complete! 这样就表示我们的python3.6.5已经安装好. 但是有一个问题是到这里我们的python3.6.5还是不能运行的.我们需要做最后一步操作.建立软件了到系统的环境变量中去. 1234567# 建立python3的软连接ln -s /usr/local/python36/bin/python3 /usr/bin/python3# 建立pip3的软件链接ln -s /usr/local/python36/bin/pip3 /usr/bin/pip3 执行了这两步操作我们的python3就可以正常的在Centos系统中正常运行了. 2. 安装Mariadb数据库安装命令. 同时安装mariadb的数据库和客户端程序 1yum -y install mariadb mariadb-server 安装完成后我们要启动mariadb数据库[有如下常用的命令] 12345678910111213141516171819# 启动数据库systemctl start mariadb# 重启数据库systemctl restart mariadb# 停止数据库systemctl stop mariadb# 查看数据库的运行状态systemctl status mariadb# 设置数据库开机自动启动systemctl enable mariadb 启动好数据库后.由于我们是首次使用数据库我们需要配置数据库的初始密码 设置密码的命令是: 1mysql_secure_installation 这样就会进入到如下的页面,按照要求进行设置. 123456789101112131415161718Enter current password for root:&lt;–初次运行直接回车设置密码Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车New password: &lt;– 设置root用户的密码Re-enter new password: &lt;– 再输入一次你设置的密码其他配置Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车,Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车 初始化MariaDB完成，接下来测试登录的命令: 1mysql -u root -p 会提示我们数据密码,这个时候我们输入刚才设置的密码就可以登录到数据库中了. 因为项目需要远程连接数据库,数据库默认是没有开启的所以我们需要开启远程连接.在mysql数据库中的user表中可以看到默认是只能本地连接的，所有可以添加一个新的用户，该用户可以远程访问 创建用户 123456789# 先使用数据库use mysql;# 针对ipcreate user &apos;root&apos;@&apos;192.168.10.10&apos; identified by &apos;password&apos;;#全部 create user &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;; [本项目选择的这条命令,password要替换成自己需要设置的root密码] 授权 123456789101112# 给用户最大权限 [本项目选择这条命令,password要替换成自己需要设置的root密码]grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;;# 给部分权限(test 数据库)grant all privileges on test.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos; with grant option;# 刷新权限表flush privileges;# 查看show grants for &apos;root&apos;@&apos;localhost&apos;; 接下来就可以在远程的数据库可视化工具中直接访问该服务器中的mysql了。 本项目用的是Nacicat 3. 安装项目需要使用的虚拟环境 安装virtualenv 1yum install python-virtualenv 创建虚拟环境 123456virtualenv --no-site-packages ajenvcd ajenv# 激活虚拟环境source bin/activate 安装环境需要的包 项目文件夹下面自己建立了有一个requirement文件夹下面有一个re_install的文件.就是本项目需要用到的包.这样我们一次性就能全部安装好. 123pip3 install -r re_install.txt其中re_install.txt文件中记录的是需要安装包的名称以及对应的版本 部署前面三个准备工作做好了这样我们就可以放心的做我们部署工作了. 1. 安装nginx服务器 添加nginx存储库 1yum install epel-release 安装nginx 1yum install nginx 运行启动nginx 1systemctl start nginx 常用的nginx运行命令 12345678910#查看nginx的状态systemctl status nginx # 启动systemctl start nginx# 停止关闭systemctl stop nginx# 设置开机启动systemctl enable nginx# 禁止开机启动systemctl disable nginx 需要检查一下如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信： 12345sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reloa 这些都弄好了我们就可以输入服务器的ip地址到浏览器中看到如下界面: 2. 安装uwsgi 安装uwsgi (因为我们是python3的环境所以我们一定要使用pip3来安装,否则就安装到python2中去了.) 1pip3 install uwsgi 将uwsgi配置到环境变量中,建立软链接 1ln -s /usr/local/python36/bin/uwsgi /usr/bin/uwsgi 3. 配置项目代码,配置项目nginx.配置uwsgi.ini等本案例的配置文件，都习惯将每一个项目的配置文件，日志文件，虚拟环境放在一起，这样开发方便，运维也方便维护.项目的目录结构如下： 123[root@izm5eifctth7468z9e6fz0z home]#conff envf logf srcf 由于我的系统中配置过其他项目.这个项目我重新命名了如上面的四个文件夹.其中： conff是配置文件，用于存放项目的nginx.conf文件，uwsgi.ini文件 logf是日志文件，用于存放nginx的启动成功和失败文件，以及uwsgi的运行日志文件 envf是用于存放虚拟环境 srcf是项目文件，该目录下上传的是目录代码 4. 配置nginx.conf文件首先进入conff文件夹中创建一个名称为ajnginx.conf 的文件. 每一个项目对应有一个自己定义的nginx的配置文件，比如爱家项目，我定义为ajnginx.conf文件.具体配置内容如下: 123456789101112131415server &#123; listen 80; server_name 47.104.205.141 localhost; access_log /home/logf/access.log; error_log /home/logf/error.log; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8890; uwsgi_param UWSGI_CHDIR /home/srcf/Aj; uwsgi_param UWSGI_SCRIPT manage:app; &#125;&#125; 说明: listen — 表示监听的端口 server_name — 表示服务名称(有域名可以换成域名) access_log — nginx成功的文件日志地址 error_log — nginx失败了的错误日志文件地址 location — 接收请求 include uwsgi_params — 固定写法 uwsgi_param UWSGI_SCRIPT manage:app; # 启动flask的文件:Flask的实例 uwsgi_param UWSGI_CHDIR 项目的目录 这个配置文件写好之后我们需要修改nginx总的配置文件.这个文件在: 1vim /etc/nginx/nginx.conf 修改如下图的位置: 修改完成之后我们需要重新启动nginx服务器 1systemctl restart nginx 看到如下界面表示我们nginx服务器已经正常启动了 5. 配置uwsgi文件在conff文件夹下在定义一个名称为uwsgi.ini文件.写入如下的配置信息 12345678910111213141516[uwsgi]socket=127.0.0.1:8890chdir=/home/srcf/Ajpythonpath=/usr/local/python36/bin/python3pythonhome=/home/envf/ajenvcallbale=applogto = /home/logf/uwsgi.log 说明: [uwsgi] — 固定写法必须要有 socket — 要与nginx中uwsgi_pass一致 chdir — 项目所在的目录 pythonpath — python3所在的目录 pythonhome — 项目虚拟环境的目录 logto — 项目日志文件位置 这里配置完成就可以开始启动我们的项目了. 6. 迁移我们的数据库 运行项目必须进入到conff文件夹下面,运行的命令是: 1uwsgi --ini uwsgi.ini 结果:","categories":[],"tags":[{"name":"flask部署","slug":"flask部署","permalink":"http://yoursite.com/tags/flask部署/"}]},{"title":"Redis","slug":"redis常用命令","date":"2018-06-28T12:09:21.000Z","updated":"2018-06-30T01:16:22.542Z","comments":true,"path":"2018/06/28/redis常用命令/","link":"","permalink":"http://yoursite.com/2018/06/28/redis常用命令/","excerpt":"","text":"NoSQL - 非关系型数据库(四大类) :1234561 - 键值对数据库(- K - V) : Redis - 高速缓存 - 内存中运行 键值对特点 : 存储效率高 内存读写速率 : GHZ/s (G赫兹每秒)2 - 文档数据库 Document : MongDB3 - 图数据库 Graph : Neo4j(脉脉 - 挖掘人脉的APP 社交网站)4 - 列簇数据库 : HBase - 数据归约 CAP定理（CAP theorem）:123456Consistency : 一致性Availability : 可用性Partition tolerance : 分隔容忍CAP理论 : C.A和P三个只能占上两个 传统应用金融类应用基本上考虑的是CA 互联网和移动联网时代的应用更注重AP Redis :确定是否安装redis12redis-server --versionredis-cli --version 安装redis命令:12345一 : yum 安装 (版本会过低)二 : 源代码构建安装: cd redis cd redis-3.2.12 make &amp;&amp; make install 重要配置文件 : redis.conf(redis配置文件) / sentinel.conf(哨兵配置文件) 1.修改redis.conf配置文件1234567891011回到主目录 : cd ~ 输入pwd - 返回/root 用户主目录下复制一份redis.conf进行修改 : cp redis-3.2.12/redis.conf ./redis.conf 拷贝文件避免更改错误vim打开配置文件 : vim redis.conf命令模式Esc : 61gg - 去到当前行数 - 修改内网ip (行数 + gg --&gt; 去到指定行数):!ip address - 查看内网ip地址61行 -- bind 172.27.0.11 绑定内网地址84行 -- port 6379 默认端口480行 -- requirepass 1qaz2wsx 删除注释,修改密码179行 -- databases 16 默认redis下16个数据库 2. redis-server 服务器1234567891011121314启动服务器 redis-server redis.conf 启动redis服务器 redis-sercer redis.conf &amp; 后台运行 redis-server myredis.conf &gt; myredis.log &amp; 后台运行关闭服务器 jobs --&gt; fg %1 --&gt; ^c 关闭redis服务器(自动保存) ps -ef | grep redis 查看进程 bg %1 : 后台运行进程 jobs : 查看进程状态 netstat -nap | grep redis : 查看端口 redis-cli -h 172.18.61.250 : 连接服务器 auth + 密码 : 输入密码命令 ping ---&gt; PONG : 查看服务器是否连接成功 ping为命令, PONG为方法 kill 进程号 关闭redis服务器 不保存 3. redis-cli 客户端 12345678910111213设置缓存时间 : set username(键) lronlin(值) ex 30拿到值 : get username存活时间(time to live) : ttl username空值 : nil超级时间 : expire username 120查看所有键 : keys *保存数据 : save阻塞保存数据 : bgsave清空数据库 : flushdb切换数据库 : select 3(数据库)清空所有 : flushall判断键是否存在 : exists关掉服务器默认保存数据 : shutdown (nosave 不保存数据) 了解 :123451998 - 提出NOSQL概念 2008 - Big Data 大数据时代No SQLNo, SQL!Not Only SQL! 用命令kill多个进程(运维):12345678awk - 工具ps -ef | grep redisredis 10223 jdkf asjdkfjdkf ajsdfkdsaf asjdfkjdps -ef | grep redis | awk &apos;&#123;print $2&#125;&apos;10223 ps -ef | grep redis | awk &apos;&#123;print $2&#125;&apos; | xargs kill命令别名 : alias shit=&apos;ps -ef | grep redis | awk &apos;&#123;print $2&#125;&apos; | xargs kill&apos; shit redis是键值对的数据库，有5种主要数据类型：字符串类型（string），散列类型（hash），列表类型（list），集合类型（set，有序集合类型（zset） 几个基本的命令： 123456789101112131415KEYS * 获得当前数据库的所有键EXISTS key [key ...] 判断键是否存在，返回个数，如果key有一样的也是叠加数DEL key [key ...] 删除键，返回删除的个数TYPE key 获取减值的数据类型（string，hash，list，set，zset）FLUSHALL 清空所有数据库CONFIG [get、set] redis配置-inf 负无穷+inf正无穷 字符串类型string123456789101112# 追加 append username# 字符串长度 strlen username# 设置范围 setrange# 增加数量 incr number# 批量增加 incry number 100# 拿到原来的设置现在的 getset username wangdachui 散列类型hash12345678910111213141516hash : 字典(嵌套字典 - 字典存字典) - 保存对象(优点)hset# 拿到所有(键值对) hgetall stu1(键值对) # 删除hash内存中的某个字段 hdel syu1 age# 判断哈希表里某个字段是否存在 hexists stu1 name# 获取所有字段 hkeys stu1# 获取字段长度 hlen stu1# 给键里的某个字段加值 hincry / hincryby / hincrybyfolat# 获取所有字段的值 hvalues 列表类型（list）1234567891011121314151617181920列表 - 元素可重复push : 放pop : 取# 往列表里放东西(lpush 从左往右放) lpush mylist apple orange apple peach grape# 取一个(从右往左取) lpop mylist#rpush(从右往左放) rpush mylist1 apple orange apple peach grape# (从左往右取) rpop mylist1rpush mylist2 100 30 98 75 200 15 66# 从左往右取一个范围(取下标) lrange mylist2 0 2# 从右往左取 # 取所有(整个列表取完) lrange mylist2 0 -1# 限定只取某个范围(截取元素 - 模拟栈与队列) ltrim mylist2 2 4 集合类型（set）12345678910111213141516171819集合自动去重 - 元素不可重复sadd set1 apple orange apple apple grape# 查看集合所有元素 smembers set1# 元素数量 scard set1sadd set2 banana grape pitaya# 交集 sinter set1 set2# 并集 sunion set1 set2# 差集 sdiff set1 set2 / siddf set2 set1# 根据哈希码取元素(取走) spop set1# 随机取元素(未取走) srandmember set2 2# 判断元素是否在集合中 sismemeber set2 grape 有序集合类型1234567891011zset - 自动排序 - 有序集合方法(游戏动态排位) - 每个元素都有一个附加的值# 放元素(元素前赋值) zadd players 100 zhao 85 qian 200 sun 120 lee 180 zhou# 取元素(从小到大顺序) zrange players 0 -1# (从大到小顺序) zrevrange players 0 -1# 查看元素数量 zcard players# 统计(范围)- 元素数量 zcount players 150 200 GED(地理位置)扩充:1234LBS - Location-Based Service : 基于位置的服务# 经纬度范围(东经/ 北纬) geoadd常用功能 : 送餐距离 / 打车范围 / 半径范围 事务:1234开启事务:(银行系统)放弃 : discard提交 : exec单线程 + 多路I/O复用(多个读写操作同时进行) 线程:123456789101112线程安全 : 线程不安全 : # 多个线程共享数据so easy / 只能用到CPU的一个核# 多进程优点可以用到多核特性多线程/多进程优点 : - 耗时间的任务扔到一个单独的线程或者进程里去做 1.改善性能, 程序执行更快 2.改善用户体验, 不让程序假死, 提升程序的性能多线程/多进程缺点: 1.程序既不好写又不好调试 2.对其他运行的程序是不友好的协程 :微线程 : 总结:123456网页图片 - string保存对象 - hash栈与消息队列 - list排序 - set动态排位 - zsetios - ged Python中操作redis12341.服务器 : redis / mysql : 配内网 - 连公网2.路由器配端口映射 : 公网 访问 内网 3.内网访问公网 - NAT -网络地址转换(会话)4.公网访问内网 - 端口映射 - 请求走到路由器, 路由器通过端口绝顶将对该端口的请求映射到内网那一台主机上 redis主从复制12显示主从复制的信息 : info replication奴隶变主人 : slave of no one redis 正常操作中 - 读操作 : 写操作 (3 : 1) 读写分离 : 3台服务器读 - 1台服务器写 - 主从复制 sentinel哨兵:12345678910111213141516171819202122232425262728从机与主机密码一致master -- 主 -- 读写数据 info replication -- 查看状态信息 config slaves -- 从 -- 只能读不能写 更改 redis.conf 配置, 链接master 265行 slaveof 120.77.222.217 11223 272行 masterauth 密码 info replication -- 查看状态信息 master --&gt; down 更改sentinel.conf配置 15 bind 内网地址 绑定地址 17 port 26379 服务器打开26379端口 70行 sentinel montor mymaster IP 端口号 1 --slaves 投票 73行 sentinel auth-pass mymaster 密码 bind 172.18.61.250 port 26379 sentinel monitor mymaster 120.77.222.217 11225 1 sentinel down-after-milliseconds mymaster 5000 sentinel auth-pass mymaster 1qaz2wsx 起哨兵 redis-sentinel sentinel.conf &amp; 起redis服务器 redis-server myredis.conf --sentinel &amp; 起客户端 redis-cli -h 120.77.222.217 -p 11223 集群123集群 - 多个节点当成一个节点来使用单点故障 - 把单个节点搞成多个节点集群之前配置 : Nginx/LVS负载均衡算法 : (RR)轮循 / (Hash)哈希 / (MCC)连接数 + Keepalived双活(热备份) redis集群123安装语言环境: Ruby - 集群语言Django / Flask 项目 用redis缓存(单机版) / 爬虫也会用到","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"Spider","slug":"爬虫与User-Agent","date":"2018-06-25T11:37:21.000Z","updated":"2018-06-25T11:37:41.705Z","comments":true,"path":"2018/06/25/爬虫与User-Agent/","link":"","permalink":"http://yoursite.com/2018/06/25/爬虫与User-Agent/","excerpt":"","text":"前言网络爬虫（Web Spider。又被称为网页蜘蛛。网络机器人，又称为网页追逐者），是一种依照一定的规则，自己主动的抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁，自己主动索引。模拟程序或者蠕虫。假设把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。 网络蜘蛛是通过网页的链接地址来寻找网页的。从站点某一个页面（一般是首页）开始，读取网页的内容。找到在网页中的其他链接地址。然后通过这些链接地址寻找下一个网页。这样一直循环下去，直到把这个站点全部的网页都抓取完为止。假设把整个互联网当成一个站点。那么网络蜘蛛就能够用这个原理把互联网上全部的网页都抓取下来。这样看来，网络爬虫就是一个爬行程序，一个抓取网页的程序。 简单地说，网络爬虫的基本任务就是抓取网页内容。 1.数据分析和采集此爬虫教程中使用的Python版本统一为Python3.X的版本 1.1数据分析爬取网页信息可以使用很多的技术: 1.获取网页信息: urllib \\ urllib3 \\ requests 12requests 为第三方库, 需要安装爱才能使用pip install requests 2.解析网页信息: beautifulsoup4(bs4) \\ re \\ xpath \\ lxml 123bs4 为第三方的库, 需要安装才能使用pip install beautifulsoup4使用的时候 from bs4 import BeautifulSoup 这样导入 Python 标准库中自带了 xml 模块，但是性能不够好，而且缺乏一些人性化的 API，相比之下，第三方库 lxml 是用 Cython 实现的，而且增加了很多实用的功能。 12345安装lxml，在新版本中无法使用from lxml import etreepip install lxml 并不推荐这样去安装lxml推荐安装的方法：访问网站(https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml)下载lxml的安装whl文件，然后进行安装。 在这里下载的是lxml-4.2.1-cp36-cp36m-win_amd64.whl，安装命令如下 1pip install lxml-4.2.1-cp36-cp36m-win_amd64.whl 截图： 3.动态数据解析 ​ 通用: selenium(自动化测试框架) 1.2数据采集1.存储 : mysql \\ redis \\ mongodb \\ sqlalchemy 2.序列化 : json 3.调度器 : 进程 \\ 线程 \\ 协程 2.请求头分析123456789101112131415161718192021222324# 浏览器告诉服务器可以接收的文本类型, */*表示任何类型都可以接收Accept: text/html, */*;q=0.8# 浏览器告诉服务器, 数据可以压缩, 页面可以解压数据然后进行渲染, 做爬虫的时候, 最好不要写该参数Accpet-Encoding: gzip, deflate# 语言类型Accept-Language: zh-CN,zh;q=0.9 Cache-Control: max-age=0# 保持连接Connection: keep-alive # 会话 Cookie: Hm_lvt_3bfcc098e0da26d58c321ba579b04b2f=1527581188,1528137133# 域名Host: www.cdtopspeed.com Upgrade-Insecure-Requests: 1# 用户代理, 使得服务器能够识别请求是通过浏览器请求过来的，其中包含浏览器的名称/版本等信息User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36 其中在爬虫中最重要的就是User-Agent：在下面urllib的使用中就会详细的解释User-Agent的使用 3.urllib的使用使用urllib来获取百度首页的源码 1234import urllib.requestr = urllib.request.urlopen(&apos;http://www.baidu.com&apos;)print(r.read().decode(&apos;utf-8&apos;)) 按照我们的想法来说，输出的结果应该是百度首页的源码才对，但是输出却不对(多请求几次，就会出现如下的结果)，如下结果： 12345678910&lt;html&gt;&lt;head&gt; &lt;script&gt; location.replace(location.href.replace(&quot;https://&quot;,&quot;http://&quot;)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;noscript&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;&lt;/noscript&gt;&lt;/body&gt;&lt;/html&gt; 以上的结果并不是我们想要的，我们可以来查看一下为什么会出现这种问题的原因。我们可以想到刚才说的，请求头中的最重要的参数User-Agent参数，该参数是用来告诉服务器，请求的url是来源于哪儿的，是来源于浏览器还是来源于其他地方的。如果是来源于非浏览器的会就不会返回源码信息给你的，直接拦截掉你的请求 分析以上代码中，默认提交的请求头中的User-Agent到底传递了什么值： 接下来，就是优化以上的代码，实现目的就是告诉服务器我们这个请求是来源于浏览器的。 12345678header = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/65.0.3325.181 Safari/537.36&apos;&#125;res = urllib.request.Request(&apos;http://www.baidu.com&apos;, headers=header)# 读取url的页面源码r = urllib.request.urlopen(res)# decode解码, encode编码print(r.read().decode(&apos;utf-8&apos;)) 按照这样去解析，就可以获取到百度的首页源代码了，展示部门代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;&lt;meta content=&quot;always&quot; name=&quot;referrer&quot;&gt;&lt;meta name=&quot;theme-color&quot; content=&quot;#2932e1&quot;&gt;&lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;&lt;link rel=&quot;search&quot; type=&quot;application/opensearchdescription+xml&quot; href=&quot;/content-search.xml&quot; title=&quot;百度搜索&quot; /&gt;&lt;link rel=&quot;icon&quot; sizes=&quot;any&quot; mask href=&quot;//www.baidu.com/img/baidu_85beaf5496f291521eb75ba38eacbd87.svg&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//s1.bdstatic.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t1.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t2.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t3.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t10.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t11.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t12.baidu.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//b1.bdstatic.com&quot;/&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;style id=&quot;css_index&quot; index=&quot;index&quot; type=&quot;text/css&quot;&gt;html,body&#123;height:100%&#125;html&#123;overflow-y:auto&#125;body&#123;font:12px arial;text-align:;background:#fff&#125;body,p,form,ul,li&#123;margin:0;padding:0;list-style:none&#125;body,form,#fm&#123;position:relative&#125;td&#123;text-align:left&#125;img&#123;border:0&#125;a&#123;color:#00c&#125;a:active&#123;color:#f60&#125;input&#123;border:0;padding:0&#125;#wrapper&#123;position:relative;_position:;min-height:100%&#125;#head&#123;padding-bottom:100px;text-align:center;*z-index:1&#125;...忽略.......忽略.......忽略....&lt;/body&gt;&lt;/html&gt; 4. ssl认证什么是 SSL 证书？ SSL 证书就是遵守 SSL 安全套接层协议的服务器数字证书。 而 SSL 安全协议最初是由美国网景 Netscape Communication 公司设计开发的，全称为：安全套接层协议 (Secure Sockets Layer) ， 它指定了在应用程序协议 ( 如 HTTP 、 Telnet 、 FTP) 和 TCP/IP 之间提供数据安全性分层的机制，它是在传输通信协议 (TCP/IP) 上实现的一种安全协议，采用公开密钥技术，它为 TCP/IP 连接提供数据加密、服务器认证、消息完整性以及可选的客户机认证。由于此协议很好地解决了互联网明文传输的不安全问题，很快得到了业界的支持，并已经成为国际标准。 SSL 证书由浏览器中“受信任的根证书颁发机构”在验证服务器身份后颁发，具有网站身份验证和加密传输双重功能。 如果能使用 https:// 来访问某个网站，就表示此网站是部署了SSL证书。一般来讲，如果此网站部署了SSL证书，则在需要加密的页面会自动从 http:// 变为 https:// ，如果没有变，你认为此页面应该加密，您也可以尝试直接手动在浏览器地址栏的http后面加上一个英文字母“ s ”后回车，如果能正常访问并出现安全锁，则表明此网站实际上是部署了SSL证书，只是此页面没有做 https:// 链接；如果不能访问，则表明此网站没有部署 SSL证书。 案例: 访问加密的12306的网站 如果不忽略ssl的安全认证的话，网页的源码会提示ssl认证问题，需要提供ssl认证。我们在做爬虫的时候，自动设置忽略掉ssl认证即可。代码如下： 123456789101112import sslimport urllib.requestdef main(): url = &apos;http://www.12306.cn/mormhweb/&apos; # 忽略未经审核的ssl认证 context = ssl._create_unverified_context() res = urllib.request.urlopen(url, context=context) print(res.read().decode(&apos;utf-8&apos;)) if__name__ == &apos;__main__&apos;: main() 5. 分析百度的搜索当我们通过百度搜索引擎去搜索python语言的时候，可以发现百度搜索的url中有很多无用的参数，过滤掉无用的参数，最后的请求url可以展示为，如下的信息： 1https://www.baidu.com/s?wd=python%E8%AF%AD%E8%A8%80 5.1 使用urllib进行中文的编码和解码1234567891011from urllib import parse# 编码enstr = parse.urlencode(&#123;&apos;kd&apos;: &apos;千峰&apos;&#125;)# 打印的结果为 kd=%E5%8D%83%E5%B3%B0print(enstr)# 解码destr = parse.unquote(enstr)# 解码的结果为 kd=千峰print(destr) 1.2 简单案例–百度搜索(search_spider03.py)自定义百度的搜索url，获取页面源码。以下案例中，我搜索易烊千玺，查看一下搜索e的结果页面如何。 12345678910111213141516import urllib.requestfrom urllib import parsedef baidu_api(search): url = &apos;http://www.baidu.com/?&apos; + search header = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&apos; &#125; res = urllib.request.Resquest(url=url, headers=header) r = urllib.request.urlopen(res) print(r.read().decode(&apos;utf-8&apos;)) if__name__ == &apos;__main__&apos;: search = input(&apos;请输入搜索的数据: &apos;) wd = parse.urlencode(&#123;&apos;wd&apos;: search&#125;) baidu_api(wd) 1.3 智联岗位爬取(zhilian_spider.py)123456789101112131415161718192021222324252627282930313233343536373839404142import reimport urllib.requestfrom urllib import parsedef get_zhilian_html(url): &quot;&quot;&quot; 获取智联上招聘信息 获取职位的个数 &lt;span class=&quot;search_yx_tj&quot;&gt; 共&lt;em&gt;1473&lt;/em&gt;个职位满足条件 &lt;/span&gt; &quot;&quot;&quot; header = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36&apos; &#125; req = urllib.request.Request(url, headers=header) res = urllib.request.urlopen(req) # 正则匹配, 查询的结果为职位的个数def get_job_num(html): result = re.findall(&apos;&lt;em&gt;(\\d+)&lt;/em&gt;, html&apos;) if result: return result[0] else: return 0 if __name__ == &apos;__main__&apos;: # 获取从客户端接收到的参数 city = input(&apos;请输入所搜城市: &apos;) job = input(&apos;请输入搜索岗位: &apos;) # 将输入的参数进行解码, 输入参数Python和成都, 输出结果为:j1=%E6%88%90%E9%83%BD&amp;kw=python search = parse.urlencode(&#123;&apos;j1&apos;: city, &apos;kw&apos;: job&#125;) # urllib进行解析网站的url url = &apos;https://sou.zhaopin.com/jobs/searchresult.ashx?%s&apos; % search&apos; html = get_zhilian_html(url) # 进行解析地址 result = get_job_num(html) print(&apos;城市: %s 岗位: %s 需求量: %s&apos; % (city, job, result)) 调试：搜索成都的python岗位的职位个数","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"Flask","slug":"flask多对多关系","date":"2018-06-15T09:01:21.000Z","updated":"2018-06-15T09:01:41.827Z","comments":true,"path":"2018/06/15/flask多对多关系/","link":"","permalink":"http://yoursite.com/2018/06/15/flask多对多关系/","excerpt":"","text":"1.关联关系 —&gt; 多对多定义模型: 引入SQLALchemy 123from flask_sqlalchemy import SQLALchemydb = SQLALchemy 创建中间表 123sc = db.Table(&apos;sc&apos;, db.Column(&apos;s_id&apos;, db.Integer, db.ForeignKey(&apos;student.s_id&apos;), primary_key=True), db.Column(&apos;c_id&apos;), db.Integer, db.ForeignKey(&apos;course.c_id&apos;), primary_key=True) 创建学生类Student 1234567891011121314class Student(db.Model): s_id = db.Column(db.Integer, primary_key=True, autoincrement=True) s_name = db.Column(db.String(16), unique=True) s_age = db.Column(db.Integer, defauult=18) s_g = db.Column(db.Integer, db.Foreignkey(&apos;grade.g_id&apos;), nullable=True) __tablename__ = &apos;student&apos; def __init__(self, name, age): self.s_name = name self.s_age = age self.s_g = None 创建课程表的模型, Course类 12345678910111213class Course(db.Model): c_id = db.Column(db.Integer, primary_key=True, autoincrement=True) c_name = db.Column(db.String(20), unique=True) students = db.relationship(&apos;Student&apos;, secondary=sc, backref=&apos;cou&apos;) __tablename__ = &apos;courses&apos; def __init__(self, name): self.s_name = name sc表由db.Table声明，我们不需要关心这张表，因为这张表将会由SQLAlchemy接管，它唯一的作用是作为students表和courses表关联表，所以必须在db.relationship()中指出sencondary关联表参数。lazy是指查询时的惰性求值的方式，这里有详细的参数说明，而db.backref是声明反向身份代理，其中的lazy参数是指明反向查询的惰性求值方式. 2. 添加学生和课程之间的关系通过页面中传递学生的id和课程的id，分别获取学生的对象和课程的对象，在使用关联关系append去添加学生对象，并且add以后再commit后，就可以在中间表sc中查看到新增的关联关系了。 123456789userid = request.form.get(&apos;userid&apos;)courseid = request.form.get(&apos;courseid&apos;)stu = Student.query.get(userid)cou = Course.query.get(courseid)cou.students.append(stu)db.session.add(cou)db.session.commit() 3. 删除学生和课程之间的关系通过页面获取传递的学生的id和课程的id，分别获取学生对象和课程对象，在使用关联关系remove去删除学生对象，并commit将事务提交到数据库中 12345stu = Student.query.get(s_id)cou = Course.query.get(c_id)cou.students.remove(stu)db.session.commit() 4. 通过课程查询学生的信息以下定义在课程course的模型中，所以通过课程查询学生的信息，语法为课程的对象.studengs。如果知道学生的信息反过来找课程的信息，则使用backref的反向关联去查询，语语法为学生的对象.cou(反向) students = db.relationship(‘Student’,secondary=sc,backref=’cou’) 12cou = Course.query.get(3)stus = cou.students 5. 通过学生去查询课程的信息12stu = Student.query.get(id)cous = stu.cou 6.开发, 页面调试工具debugtoolbar1.1安装1pip install flask-debugtoolbar 1.2配置1234567891011from flask import Flaskfrom flask_debugtoolbar import DebugToolbarExtensionapp = Flask(__name__)app.debug = Trueapp.config[&apos;SECRET_KEY&apos;] = &apos;&lt;replace with a secret key&gt;&apos;toolbar = DebugToolbarExtension(app) 2. restfulFlask-RESTful 提供的最主要的基础就是资源(resources)。资源(Resources)是构建在 Flask 可拔插视图 之上，只要在你的资源(resource)上定义方法就能够容易地访问多个 HTTP 方法 官网上描述了一个最简单的restful风格的api，如下： 1234567891011121314from flask import Flaskfrom flask.ext import restfulapp = Flask(__name__)api = restful.Api(app)class HelloWorld(restful.Resource): def get(self): return &#123;&apos;hello&apos;: &apos;world&apos;&#125; api.add_resource(HelloWorld, &apos;/&apos;)if __name__ == &apos;__main__&apos;: app.run(debug=True) 2.1安装1pip install flask_restful 2.2配置在create_app()获取Flask(name)对象中，设置如下配置 12345from flask_restful import Apiapi = Api()api.init_app(app=app) 在views中需要引入配置的api还有Resource 123456789101112131415161718192021222324252627282930313233343536373839# 导入包和restful中的Api对象from flask_restful import Resourcefrom tuils.functions import api# 定义类, 启动包含了对数据处理的GET, POST, PATCH, PUT, DELETE请求class CreateCourse(Resource): def get(self, id): course = Course.query.get(id) return course.to_dict() def post(self): courses = [&apos;大学英语&apos;, &apos;大学物理&apos;, &apos;线性代数&apos;, &apos;高数&apos;, &apos;大学语文&apos;, &apos;马克思主义&apos;, &apos;C++&apos;, &apos;课外拓展&apos;] course_list = [] for course in courses: c = Course() c.c_name = course course_list.append(c) db.session.add_all(course_list) db.session.commit() courses = Course.query.all() return [course.to_dict() for course in courses] def patch(self, id): c_name = request.form.get(&apos;c_name&apos;) course = Course.query.get(id) course.c_name = c_name db.session.commit() return &#123;&apos;code&apos;:200, &apos;data&apos;: course.to_dict(), &apos;msg&apos;: &apos;请求成功&apos;&#125; def delete(self, id): course = Course.query.get(id) db.session.delete(course) db.seesion.commit() return &#123;&apos;code&apos;: 200, &apos;msg&apos;: &apos;删除成功&apos;&#125; # 绑定处理url api.add_resource(CreateCourse, &apos;/api/course/&lt;int:id&gt;/&apos;, &apos;/api/course/&apos;) 2.3 端点(Endpoints)在一个 API 中，你的资源可以通过多个 URLs 访问。你可以把多个 URLs 传给 Api 对象的 Api.add_resource() 方法。每一个 URL 都能访问到你的 Resource 如： 1api.add_resource(CreateCourse, &apos;/api/course/&lt;int:id&gt;/&apos;, &apos;/api/course/&apos;) 2.4 返回响应Flask-RESTful 支持视图方法多种类型的返回值。同 Flask 一样，你可以返回任一迭代器，它将会被转换成一个包含原始 Flask 响应对象的响应。Flask-RESTful 也支持使用多个返回值来设置响应代码和响应头 如： 123def get(self, id): course = Course.query.get(id) return course.to_dict(), 200","categories":[],"tags":[{"name":"多对多关系","slug":"多对多关系","permalink":"http://yoursite.com/tags/多对多关系/"}]},{"title":"Flask","slug":"增删改查与一多","date":"2018-06-13T12:30:21.000Z","updated":"2018-06-13T12:08:00.733Z","comments":true,"path":"2018/06/13/增删改查与一多/","link":"","permalink":"http://yoursite.com/2018/06/13/增删改查与一多/","excerpt":"","text":"1.数据库增删改查定义模型, 并定义初始化的函数: 123456789101112class Student(db.Model): s_id = db.Column(db.Integer, autoincrement=True, primary_key=True) s_name = db.Column(db.String(16), unique=True) s_age = db.Column(db.Integer(17), default=False) grades = db.Column(db.Integer, db.ForeignKey(&apos;grade.g_id&apos;), nullable=True) __tablename__ = &apos;student&apos; def __init__(self, name, age): self.s_name = name self.s_age = age 1.1增 —&gt; 批量增加第一种方式: 12345678910111213141516@user_blueprint.route(&apos;/create_stus&apos;)def create_stus(): stus = [] for i in range(5): # 实例化Student的对象 s = Student() # 对象的属性赋值 s.s_name = &apos;南弦%s&apos; % random.randrange(1000) s.s_age = &apos;%d&apos; % random.randrange(100) stus.append(s) # 添加需要创建的数据 db.session.add_all(stus) # 提交事务到数据库 db.session.commit() return &apos;创建成功&apos; 注: 在创建单条数据的时候使用db.session.add(), 在创建多条数据的时候使用db.session.add_all() 第二种方式: 1234567891011@user_blueprint.route(&apos;/create_stus/&apos;)def create_stus(): stus = [] for i in range(5): # 使用类似的初始化去创建Student对象 s = Student(&apos;南弦%s&apos; % random.randomrange(1000),&apos;%d&apos; % randomrange(100)) stus.append(s) db.session.add_all(stus) db.session.commit() retrun &apos;创建成功&apos; 1.2查 —&gt; 使用运算符获取查询集: 123filter(类名.属性名.运算符(&apos;自写内容&apos;))filter(类名.属性名 数学运算符 值) 1.11运算符 语法: 12345678910111213141516171819filter(model_name.属性名.运算符())contains : 包含startswith : 以什么开始endswith : 以什么结束in_ : 在范围内like : 模糊__ge__:大于等于__gt__:大于__lt__:小于__le__:小于等于 例子: 1.查询学生的id在3到15之间的学生信息 1stus = Student.query.filter(Student.s_id.in_([3, 4, 5, 6, 7, 8, 9])) 2.查询学生的年龄小于19岁的 1stus = Student.query.filter(Student.s_age.__le__(19)) 3.查询姓名以9结束的学生信息 1stus = Student.query.filter(Student.s_name.endswith(&apos;9&apos;)) 4.查询id为5的学生信息 12stus = Student.query.filter(Student.s_id == 5).all()stus = Student.query.get(5) 1.12.筛选 1234567891011limit()offset()order_by(&apos;-id&apos;)paginate() 分页get()first() 1.13.逻辑运算 1234567891011与 and_ filter(and_(条件),条件…)或 or_ filter(or_(条件),条件…)非 not_ filter(not_(条件),条件…) 例子1: 1.查询学生的id为3, 4, 5, 6, 16的学生信息, 使用in_逻辑运算 12345@user_blueprint.route(&apos;/get_stu_by_ids/&apos;)def get_stu_by_ids(): stus = Student.query.filter(Student.s_id.in_([3, 4, 5, 6, 16])) return render_template(&apos;students.html&apos;, stus=stus) 2.查询学生的年龄小于18岁的学生的信息 1stus = Student.query.filter(Student.s_age &lt; 18) 3.查询学生的年龄小于18岁的学生的信息，lt小于 1stus = Student.query.filter(Student.s_age.__lt__(15)) 4.查询学生的年龄小于等于18岁的学生的信息，le小于等于 1stus = Student.query.filter(Student.s_age.__le__(15)) 5.查询学生的姓名以什么开始或者以什么结尾的学生的信息startswith和endswith 12stus = Student.query.filter(Student.s_name.startswith(&apos;张&apos;))stus = Student.query.filter(Student.s_name.endswith(&apos;2&apos;)) 6.查询id=4的学生的信息 12Student.query.get(4)获取的结果是学生的对象 7.模糊搜索like 1234%：代表一个或者多个_：代表一个Student.query.filter(Student.s_name.like(&apos;%张%&apos;)) 8.分页，查询第二页的数据4条 12第一个参数是那一页，第二个参数是一页的条数，第三个参数是是否输出错误信息students = Student.query.paginate(2, 4, False).items 例子2: 跳过offset几个信息, 截取limit结果的几个值 123456789101112131415161718# 按照id降序排列stus = Student.query.order_by(&apos;-s_id&apos;)# 按照id降序获取三个stus = Student.query.order_by(&apos;-s_id&apos;).limit(3)# 获取年龄最大的一个stus = Student.query.order_by(&apos;-s_age&apos;).first()# 跳过3个数据, 查询5个信息stus = Student.query.order_by(&apos;-s_age&apos;).offset(3).limit(5)# 跳过3个数据stus = Student.query.order_by(&apos;-s_age&apos;).offset(3)# 获取id等于24的学生stus = Student.query.filter(Student.s_id==24)stus = Student.query.get(24) 例子3： 1.查询 1234567891011121314151617from sqlalchemy import and, or, not_查询多个条件stus = Student.query.filter(Student.s_age==16, Student.s_name==&apos;温暖&apos;)and_ 并且条件stus = Student.query.filter(and_(Student.s_age==16, Student.s_name==&apos;温暖&apos;))or_ 或者条件stus = Student.query.filter(or_(Student.s_age==18, Student.s_name==&apos;南弦&apos;))not_ 非stus = Student.query.filter(not_(Student.s_age==18), Student.s_name==&apos;南弦&apos;) 例子4： 分页： 后端数据处理： 12345678910# 查询第几页的数据page = int(request.args.get(&apos;page&apos;, 1))# 每一页的条数多少, 默认为10条per_page = int(request.args.get(&apos;per_page&apos;, 10))# 查询当前第几个的多少条数据paginate = Student.query.order_by(&apos;-s_id&apos;).paginate(page, per_page, error_out=False)stus = paginate.items 前端数据展示: 123456789101112131415161718192021222324252627&lt;h2&gt;学生信息&lt;/h2&gt;&#123;% for stu in stus %&#125; id: &#123;&#123; stu.s_id &#125;&#125; 姓名: &#123;&#123; stu.s_name &#125;&#125; 年龄: &#123;&#123; stu.s_age &#125;&#125; &lt;br&gt;&#123;% endfor %&#125;&lt;br&gt;总页数: &#123;&#123; paginate.pages &#125;&#125;&lt;br&gt;一共&#123;&#123; paginate.total &#125;&#125;条数据&lt;br&gt;当前页数: &#123;&#123; paginate.page &#125;&#125;&lt;br&gt;&#123;% if paginate.has_prev %&#125; &lt;a herf=&quot;/user/paginate/?page=&#123;&#123; paginate.prev_num &#125;&#125;&quot;&gt;上一页&lt;/a&gt;: &#123;&#123; paginate.prev_num &#125;&#125;&#123;% endif %&#125;&#123;% if paginate.has_next %&#125; &lt;a herf=&quot;/user/paginster/?page=&#123;&#123; paginate.next_num &#125;&#125;&quot;&gt;下一页&lt;/a&gt;: &#123;&#123; paginate.next_num&#125;&#125;&#123;% endif %&#125;&lt;br&gt;&lt;br&gt;页码: &#123;% for i in paginste.iter_pages() %&#125; &lt;a herf=&quot;/user/paginate/?page=&#123;&#123; i &#125;&#125;&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; 2. 关联关系2.1 一对多建立模型学生模型： 12345678class Student(db.Model): s_id = db.Column(db.Integer, primary_key=True, autoincrement=True) s_name = db.Column(db.String(20), unique=True) s_age = db.Column(db.Integer, default=18) s_g = db.Column(db.Integer, db.ForeignKey(&apos;grade.g_id&apos;), nullable=True) __tablename__ = &apos;student&apos; 班级模型： 123456789class Grade(db.Model): g_id = db.Column(db.Integer, primary_key=True, autoincrement=True) g_name = db.Column(db.String(10), unique=True) g_desc = db.Column(db.String(100), nullable=True) g_time = db.Column(db.Date, default=datetime.now) students = db.relationship(&apos;Student&apos;, backref=&apos;stu&apos;, lazy=True) __tablename__ = &apos;grade&apos; 官网解释有如下几个lazy的参数： lazy 决定了 SQLAlchemy 什么时候从数据库中加载数据:，有如下四个值: select/True: (which is the default) means that SQLAlchemy will load the data as necessary in one go using a standard select statement. joined/False: tells SQLAlchemy to load the relationship in the same query as the parent using a JOIN statement. subquery: works like ‘joined’ but instead SQLAlchemy will use a subquery. dynamic: is special and useful if you have many items. Instead of loading the items SQLAlchemy will return another query object which you can further refine before loading the items. This is usually what you want if you expect more than a handful of items for this relationship 12345select就是访问到属性的时候，就会全部加载该属性的数据。joined则是在对关联的两个表进行join操作，从而获取到所有相关的对象。dynamic则不一样，在访问属性的时候，并没有在内存中加载数据，而是返回一个query对象, 需要执行相应方法才可以获取对象， 2.2 通过班级查询学生信息 1234567891011@grade.route(&apos;/selectstubygrade/&lt;int:id&gt;/&apos;)def select_stu_by_grade(id): grade = Grade.query.get(id) # 通过班级对象.定义的relationship变量去获取学生的信息 stus = grade.students return render_template(&apos;grade_student.html&apos;, stus=stus, grade=grade ) 通过学生信息查询班级信息 1234567891011@stu.route(&apos;/selectgradebystu/&lt;int:id&gt;/&apos;) def select_grade_by_stu(id): stu = Student.query.get(id) # 通过学生对象.定义的backref参数去获取班级的信息 grade = stu.stu return render_template(&apos;student_grade.html&apos;, grade=grade, stu=stu) 注意：表的外键由db.ForeignKey指定，传入的参数是表的字段。db.relations它声明的属性不作为表字段，第一个参数是关联类的名字，backref是一个反向身份的代理,相当于在Student类中添加了stu的属性。例如，有Grade实例dept和Student实例stu。dept.students.count()将会返回学院学生人数;stu.stu.first()将会返回学生的学院信息的Grade类实例。一般来讲db.relationship()会放在一这一边。 3. 数据库迁移在django中继承了makemigrations，可以通过migrate操作去更新数据库，修改我们定义的models，然后在将模型映射到数据库中。 在flask中也有migrate操作，它能跟踪模型的变化，并将变化映射到数据库中 2.1 安装migrate1pip install flask-migrate 2.2 配置使用migrate2.2.1 初始化，使用app和db进行migrate对象的初始化1234from flask_migrate import Migrate#绑定app和数据库Migrate(app=app, db=db) 2.2.2 安装了flask-script的话，可以在Manager()对象上添加迁移指令1234567from flask_migrate import Migrate, MigrateCommandapp = Flask(__name__)manage = Manager(app=app)manage.add_command(&apos;db&apos;, MigrateCommand) 操作： 123456789python manage.py db init 初始化出migrations的文件，只调用一次python manage.py db migrate 生成迁移文件python manage.py db upgrade 执行迁移文件中的升级python manage.py db downgrade 执行迁移文件中的降级python manage.py db --help 帮助文档","categories":[],"tags":[{"name":"数据库增删改查与一对多关系","slug":"数据库增删改查与一对多关系","permalink":"http://yoursite.com/tags/数据库增删改查与一对多关系/"}]},{"title":"Flask","slug":"Flask模型","date":"2018-06-12T12:30:21.000Z","updated":"2018-06-12T12:26:09.882Z","comments":true,"path":"2018/06/12/Flask模型/","link":"","permalink":"http://yoursite.com/2018/06/12/Flask模型/","excerpt":"","text":"Flask模型1. Flask模型Flask默认并没有提供任何数据库操作的API 我们可以选择任何适合自己项目的数据库来使用 Flask中可以自己的选择数据，用原生语句实现功能，也可以选择ORM（SQLAlchemy，MongoEngine） SQLAlchemy是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy提供了高层ORM，也提供了使用数据库原生SQL的低层功能。 ORM： 123456将对对象的操作转换为原生SQL优点 易用性，可以有效减少重复SQL 性能损耗少 设计灵活，可以轻松实现复杂查询 移植性好 针对于Flask的支持，官网地址 1pip install flask-sqlalchemy 安装驱动 1pip install pymysql 2.定义模型使用SQLALchemy的对象去创建字段 其中__tablename__指定创建的数据库的名称 12345678910111213创建models.py文件, 其中定义模型from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()class Student(db.Model): s_id = db.Coumn(db.Integer, primary_key=Ture, autoincrement=Ture) s_name = db.Coumn(db.String(16), unique=Ture) s_age = db.Coumn(db.Integer, default=1) __tablename__ = &apos;student&apos; 其中： Integer表示创建的s_id字段的类型为整形， primary_key表示是否为主键 String表示该字段为字符串 unique表示该字段唯一 default表示默认值 autoincrement表示是否自增 3. 创建数据表在视图函数中我们引入models.py中定义的db 1234567891011from App.models imprt db@blue.route(&apos;/createdb/&apos;)def create_db(): db.create_all() return &apos;创建成功&apos; @blue.route(&apos;/dropdb/&apos;)def drop_db(): db.drop_all() return &apos;删除成功&apos; 其中： db.create_all()表示创建定义模型中对应到数据库中的表 db.drop_all()表示删除数据库中的所有的表 4. 初始化SQLALchemy在定义的init.py文件中使用SQLALchemy去整合一个或多个Flask的应用 有两种方式： 123456789101112131415第一种:from flask_sqlalchemy import SQLAlchemyapp = Flask(__name__) db = SQLAlchemy(app)第二种:db = SQLAlchemy()def create_app(): app = Flask(__name__) db.init_app(app) return app 5. 配置数据库的访问地址官网配置参数 数据库连接的格式： 12345dialect_driver://username:password@host:port/databasedialect 数据库实现driver数据库的驱动 例子： 访问mysql数据库，驱动为pymysql，用户为root，密码为123456，数据库的地址为本地，端口为3306，数据库名称HelloFlask 设置如下： “mysql+pymysql://root:123456@localhost:3306/HelloFlask” 在初始化init.py文件中如下配置： 12app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &quot;mysql+pymysql://root:123456@localhoust:3306/HelloFlask&quot;app.config[&apos;SQLALCHEMY_TRACK_MODIFICATIONS&apos;] = Flase 6.对学生数据进行CRUD操作语法: 1类名.query.xxx 获取查询集: 12345all()filter(类名.属性名==xxx)filter_by(属性名=xxx) 数据操作: 1234567891011在事务中处理, 数据插入db.session.add(object)db.session.add_all(list[object])db.session.delete(object)db.session.commit()修改和删除基于查询 6.1向学生表中添加数据1234567891011@blue.route(&apos;/createstu/&apos;)def create_stu(): s = Student() s.s_name = &apos;小白%d&apos; % random.randrange(100) s.s_age = &apos;%d&apos; % random.randrange(30) db.session.add(s) db.session.commit() return &apos;添加成功&apos; 提交事务, 使用commit提交我们的添加数据的操作 6.2获取所有学生信息将学生的全部信息获取到，并且返回给页面，在页面中使用for循环去解析即可 1234@blue.route(&quot;/getstudents/&quot;)def get_students(): students = Student.query.all() return reender_template(&quot;StudentList.html&quot;, students=students) 6.3获取s_id的学生的信息写法一: 1students = Student.query.filter(Student.s_id==1) 写法二: 1students = Student.query.filter_by(s_id=2) 注意: filter中可以接多个过滤条件 写法三: 12sql = &apos;select * from student where s_id=1&apos;students = db.session.execute(sql) 修改学生信息写法一: 123students = Student.query.filter_by(s-id=3).first()student.s_name = &apos;呵呵&apos;db.session.commit() 写法二: 12Student.query.filter_by(s_id=3).update(&#123;&apos;s_name&apos;: &apos;呵呵哒&apos;&#125;)db.session.commit() 6.5删除一个学生的信息写法一: 123student = Student.query.filter_by(s_id=2).first()db.session.delete(students)db.session.commit() 写法二: 123students = Student.query.filter_by(s_id=1).all()db.session.delete(student[0])db.session.commit() 注意：filter_by后的结果是一个list的结果集 重点注意：在增删改中如果不commit的话，数据库中的数据并不会更新，只会修改本地缓存中的数据，所以一定需要db.session.commit()","categories":[],"tags":[{"name":"模型","slug":"模型","permalink":"http://yoursite.com/tags/模型/"}]},{"title":"Flask","slug":"cookie与session","date":"2018-06-12T12:21:21.000Z","updated":"2018-06-12T12:21:59.514Z","comments":true,"path":"2018/06/12/cookie与session/","link":"","permalink":"http://yoursite.com/2018/06/12/cookie与session/","excerpt":"","text":"cookie/session前言:访问者的标识问题服务器需要识别来自同一访问者的请求。这主要是通过浏览器的cookie实现的。 访问者在第一次访问服务器时，服务器在其cookie中设置一个唯一的ID号——会话ID(session)。 这样，访问者后续对服务器的访问头中将自动包含该信息，服务器通过这个ID号，即可区 隔不同的访问者。 1.cookie概念: 12345678a) 客户端会话技术, 浏览器的会话技术b) 数据全部存储在客户端中c) 存储使用的键值对结构进行存储特性: 支持过期时间 默认会自动携带本网站的cookie 不能跨域名 不能跨浏览器 创建: 123456Cookie是通过服务器创建的Response来创建的设置: set_cookie(&apos;key&apos;, value, max_ages=&apos;&apos;, expries=&apos;&apos;)删除, 有三种删除方式: 1. 直接清空浏览器的cookie 2. del_cookie(&apos;key&apos;) 直接使用del_cookie函数 3. set_cookie(&apos;key&apos;, &apos;&apos;, expires=0) 重新设置key的值为空, 过期时间为0 获取: 12在每次请求中, url都会向服务器传递Response, 在request中可以获取到cookie的信息request.cookies.get(&apos;name&apos;) 例子1, 设置cookie: 12345678910import datetime@blue.route(&apos;/setcookie/&apos;)def set_cookie() temp = render_template(&apos;index.html&apos;) response = make_response(temp) outdate=datetime.datetime.today() + datetime.timedelta(days=30) # 设置cookie中的name的存在时长, 设置为30天才过期 response.set_cookie(&apos;name&apos;, &apos;小白&apos;, expires=outdate) return response 例子2,删除cookie中的值 123456789@blue.route(&apos;/setcookie/&apos;)def set_cookie(): temp = render_template(&apos;index.html&apos;) response = make_response(temp) # 第一种方式, 通过set_cookie去删除 response.set_cookie(&apos;name&apos;, &apos;&apos;, expires=0) # 第二种方式, del_cookie删除 response.del_cookie(&apos;name&apos;) return response 例子3, 获取cookie中的值 1234@blue.route(&apos;/getcookie/&apos;)def get_cookie(): name=request.cookies.get(&apos;name&apos;) return name 2.sessionflask-session是flask框架的session组件 该组件则将支持session保存到多个地方 如： 1234redis: 保存数据的一种工具, 五大类型, 非关系型数据库mencachedmongodbsqlalchmey: 拿数据存到数据库表里面 2.1安装1pip install flask-session 如果指定存在session的类型为redis的话, 需要安装redis 1pip install redis 2.2语法设置session: 1session[&apos;key&apos;] = value 读取session: 12result = session[&apos;key&apos;] : 如果内容不存在, 将会报异常result = session.get.(&apos;key&apos;) : 如果内容不存在, 将返回None 删除session: 1session.pop(&apos;key&apos;) 清空session中的所有数据: 1session.clear 2.3使用我们在初始化文件中创建一个方法, 通过调用该方法来获取到Flask的app对象 1234567891011121314151617def create_app(): app = Flask(__name__) # SECRET_KEY 秘钥 app.config[&apos;SECREET_KEY&apos;] = &apos;secret_key&apos; # session 类型为redis app.config[&apos;SESSION_TYPE&apos;] = &apos;redis&apos; # 添加前缀 app.config[&apos;SESSION_KEY_PREFIX&apos;] = &apos;flask&apos; # 加载app的第一种方式 se = Session() se.init_app(app=app) # 加载app的第二种方式 Session(app=app) app.regiter_blueprint(blueprint=blue) return app 2.4案例定义一个登陆的方法，post请求获取到username，直接写入到redis中，并且在页面中展示出redis中的username 1.需要先启动redis，开启redis-server，使用redis-cli进入客户端 2.定义方法 12345678910@blue.route(&apos;/login/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def login(): if request.method == &apos;GET&apos;: username = session.get(&apos;username&apos;) return render_tempalte(&apos;login.html&apos;, username=username) else: username = request.form.get(&apos;username&apos;) session[&apos;username&apos;] = username return redirect(url_for(&apos;first.login&apos;)) 3.定义模板 1234567&lt;body&gt;&lt;h3&gt;欢迎:&#123;&#123; username &#125;&#125;&lt;/h3&gt;&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请输入你的名字&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt; 4.redis中数据 注意：我们在定义app.config的时候指定了SESSION_KEY_PREFIX为flask，表示存在session中的key都会加一个前缀名flask e) cookie和session的联系 访问者在第一次访问服务器时，服务器在其cookie中设置一个唯一的ID号——会话ID(session)。 这样，访问者后续对服务器的访问头中将自动包含该信息，服务器通过这个ID号，即可区 隔不同的访问者。然后根据不同的访问者来获取其中保存的value值信息。","categories":[],"tags":[{"name":"Cookie与Session","slug":"Cookie与Session","permalink":"http://yoursite.com/tags/Cookie与Session/"}]},{"title":"Flask","slug":"Flask请求响应错误处理","date":"2018-06-11T11:40:21.000Z","updated":"2018-06-11T11:35:14.286Z","comments":true,"path":"2018/06/11/Flask请求响应错误处理/","link":"","permalink":"http://yoursite.com/2018/06/11/Flask请求响应错误处理/","excerpt":"","text":"Flask请求/响应/错误处理1. 请求request服务端在接收到客户端的请求后，会自动创建Request对象 由Flask框架创建，Requesy对象不可修改 属性： 123456789101112131415161718192021url：完整的请求地址base_url：去掉GET参数的urlhost_url：只有主机和端口号的urlpath：路由中的路径method：请求方法remote_addr：请求的客户端的地址args：GET请求参数form：POST请求参数files：文件上传headers：请求头cookies：请求中的cookie 1.1 args–&gt;GET请求参数包装a）args是get请求参数的包装，args是一个ImmutableMultiDict对象，类字典结构对象 b）数据存储也是key-value 1.2 form–&gt;POST请求参数包装a）form是post请求参数的包装，args是一个ImmutableMultiDict对象，类字典结构对象 b）数据存储也是key-value 重点：ImmutableMultiDict是类似字典的数据结构，但是与字典的区别是，可以存在相同的键。在ImmutableMultiDict中获取数据的方式，dict[‘key’]或者dict.get(‘key’)或者dict.getlist(‘key’) 2. 响应ResponseResponse是由开发者自己创建的 创建方法： 123from flask import make_responsemake_response创建一个响应，是一个真正的Response对象 状态码： 格式：make_reponse(data，code)，其中data是返回的数据内容，code是状态码 123a）直接将内容当做make_response的第一个参数，第二个参数直接写返回的状态码b）直接在render后加返回的状态码 例子1： 定义一个获取GET请求的request的方法，并将返回成功的请求的状态码修改为200 123456@blue.route(&apos;/getrequest/&apos;, methods=[&apos;GET&apos;])def get_request(): print(request) return &apos;获取request&apos;, 200 例子2： 返回response响应，并添加返回结果的状态码200 1234@blue.route(&apos;/getresponse/&apos;)def get_response(): response = make_response(&apos;&lt;h2&gt;我是响应&lt;/h2&gt;&apos;, 500) return response 3. 重定向/反向解析1url_for(&apos;蓝图定义的名称.方法名&apos;) 例子1: 定义跳转方法，跳转到get_response的方法上 1234@blue.route(&apos;/getredirect/&apos;)def get_redirect(): return redirect(&apos;getresponse&apos;) 例子2： 使用url_for反向解析 123456from flask import redirect, url_for@blue.route(&apos;/getredirect/&apos;)def get_redirect(): return redirect(url_for(&apos;first.get_response&apos;)) 4. 终止/异常捕获自动抛出异常：abort(状态码) 捕获异常处理：errorhandler(状态码)，定义的函数中要包含一个参数，用于接收异常信息 4.1 定义终止程序1234@blue.route(&apos;/make_abort/&apos;)def get_abort(): abort(400) return &apos;终止&apos; 4.2 捕获定义的异常1234@blue.errorhandler(400)def handler(exception): return &apos;捕获到异常信息:%s&apos; % exception","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Flask","slug":"Flask蓝图","date":"2018-06-11T11:32:21.000Z","updated":"2018-06-11T11:32:54.148Z","comments":true,"path":"2018/06/11/Flask蓝图/","link":"","permalink":"http://yoursite.com/2018/06/11/Flask蓝图/","excerpt":"","text":"Flask蓝图1. 什么是蓝图在Flask项目中可以用Blueprint(蓝图)实现模块化的应用，使用蓝图可以让应用层次更清晰，开发者更容易去维护和开发项目。蓝图将作用于相同的URL前缀的请求地址，将具有相同前缀的请求都放在一个模块中，这样查找问题，一看路由就很快的可以找到对应的视图，并解决问题了。 2. 使用蓝图2.1 安装1pip install flask_blueprint 2.2 实例化蓝图应用1blue = Blueprint(‘first’，\\_\\_name\\_\\_) 注意：Blueprint中传入了两个参数，第一个是蓝图的名称，第二个是蓝图所在的包或模块，name代表当前模块名或者包名 2.3 注册123app = Flask(\\_\\_name\\_\\_)app.register_blueprint(blue, url_prefix=&apos;/user&apos;) 注意：第一个参数即我们定义初始化定义的蓝图对象，第二个参数url_prefix表示该蓝图下，所有的url请求必须以/user开始。这样对一个模块的url可以很好的进行统一管理 3 使用蓝图修改视图上的装饰器，修改为@blue.router(‘/’) 1234@blue.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def hello(): # 视图函数 return &apos;Hello World&apos; 注意：该方法对应的url为127.0.0.1:5000/user/ 4 url_for反向解析语法: 1url_for(&apos;蓝图中定义的第一个参数.函数名&apos;, 参数名=value) 定义跳转： 12345678from flask import url_for, redirect@blue.route(&apos;/redirect/&apos;)def make_redirect(): # 第一种方法 return redirect(&apos;/hello/index/&apos;) # 第二种方法 return redirect(url_for(&apos;first.index&apos;))","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Flask","slug":"Flask简介","date":"2018-06-11T11:30:21.000Z","updated":"2018-06-11T11:30:31.378Z","comments":true,"path":"2018/06/11/Flask简介/","link":"","permalink":"http://yoursite.com/2018/06/11/Flask简介/","excerpt":"","text":"Flask 简介1. flask介绍Flask是一个基于Python实现的web开发的’微’框架 中文文档地址 Flask和Django一样，也是一个基于MVC设计模式的Web框架 flask流行的主要原因： 12345a）有非常齐全的官方文档，上手非常方便b) 有非常好的拓展机制和第三方的拓展环境，工作中常见的软件都有对应的拓展，自己动手实现拓展也很容易c) 微型框架的形式给了开发者更大的选择空间 2. 安装flask2.1虚拟环境搭建12345virtualenv --no-site-packages falskenv激活windows下虚拟环境cd Scriptsactivate 2.2 安装1pip install flask 3. 基于flask的最小的应用创建hello.py文件 1234567891011from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def gello_world(): return &apos;Hello World&apos;if __name__ == &apos;__main__&apos;: app.run() 运行：python hello.py 3.1 初始化123from flask import Flaskapp = Flask(__name__) Flask类构造函数唯一需要的参数就是应用程序的主模块或包。对于大多数应用程序，Python的name变量就是那个正确的、你需要传递的值。Flask使用这个参数来确定应用程序的根目录，这样以后可以相对这个路径来找到资源文件。 3.2 路由1@app.route(&apos;/&apos;) 客户端例如web浏览器发送 请求 给web服务，进而将它们发送给Flask应用程序实例。应用程序实例需要知道对于各个URL请求需要运行哪些代码，所以它给Python函数建立了一个URLs映射。这些在URL和函数之间建立联系的操作被称之为 路由 。 在Flask应程序中定义路由的最便捷的方式是通过显示定义在应用程序实例之上的app.route装饰器，注册被装饰的函数来作为一个 路由。 3.3 视图函数在上一个示例给应用程序的根URL注册gello_world()函数作为事件的处理程序。如果这个应用程序被部署在服务器上并绑定了 www.example.com 域名，然后在你的浏览器地址栏中输入 http://www.example.com 将触发gello_world()来运行服务。客户端接收到的这个函数的返回值被称为 响应 。如果客户端是web浏览器，响应则是显示给用户的文档。 类似于gello_world()的函数被称作 视图函数 。 3.4 动态名称组件路由你的Facebook个人信息页的URL是 http://www.facebook.com/ ，所以你的用户名是它的一部分。Flask在路由装饰器中使用特殊的语法支持这些类型的URLs。下面的示例定义了一个拥有动态名称组件的路由： 12345@app.route(&apos;/hello/&lt;name&gt;&apos;)def gello_world(name): return &apos;Hello World %s&apos; % name 用尖括号括起来的部分是动态的部分，所以任何URLs匹配到静态部分都将映射到这个路由。当视图函数被调用，Flask发送动态组件作为一个参数。在前面的示例的视图函数中，这个参数是用于生成一个个性的问候作为响应。 在路由中动态组件默认为字符串，但是可以定义为其他类型。例如，路由/user/int:id只匹配有一个整数在id动态段的URLs。Flask路由支持int、float 如下： 12345@app.route(&apos;/hello/&lt;int:id&gt;&apos;)def gello_stu_id(id): return &apos;Hello World id: %s&apos; % id 3.5 服务启动123if __name__ == &apos;__main__&apos;: app.run() 注意： name == ‘main‘在此处使用是用于确保web服务已经启动当脚本被立即执行。当脚本被另一个脚本导入，它被看做父脚本将启动不同的服务，所以app.run()调用会被跳过。 一旦服务启动，它将进入循环等待请求并为之服务。这个循环持续到应用程序停止，例如通过按下Ctrl-C。 有几个选项参数可以给app.run()配置web服务的操作模式。在开发期间，可以很方便的开启debug模式，将激活 debugger 和 reloader 。这样做是通过传递debug为True来实现的。 run()中参数有如下： 12345debug 是否开启调试模式，开启后修改python的代码会自动重启port 启动指定服务器的端口号host主机，默认是127.0.0.1 4. 修改启动方式，使用命令行参数启动服务4.1 安装插件1pip install flask-script 调整代码 manager = Manager(app=‘自定义的flask对象’) 启动的地方 manager.run() 4.2 启动命令1python hellow.py runserver -h 地址 -p 端口 -d -r 其中：-h表示地址。-p表示端口。-d表示debug模式。-r表示自动重启 5. route规则5.1 规则写法：converter:variable_name converter类型： 123456string 字符串int 整形float 浮点型path 接受路径，接收的时候是str，/也当做字符串的一个字符uuid 只接受uuid字符串any 可以同时指定多种路径，进行限定 例子： 123456789@app.route(&apos;/helloint/&lt;int:id&gt;/&apos;)@app.route(&apos;/getfloat/&lt;float:price&gt;/&apos;)@app.route(&apos;/getstr/&lt;string:name&gt;/&apos;，methods=[&apos;GET&apos;, &apos;POST&apos;])@app.route(&apos;/getpath/&lt;path:url_path&gt;/&apos;)@app.route(&apos;/getbyuuid/&lt;uuid:uu&gt;/&apos;，methods=[&apos;GET&apos;, &apos;POST&apos;]) 实现对应的视图函数： 123456789101112131415161718192021222324252627282930313233343536373839@blue.route(&apos;/hello/&lt;name&gt;/&apos;)def hello_man(name): print(type(name)) return &apos;hello name:%s type:%s&apos; % (name, type(name))@blue.route(&apos;/helloint/&lt;int:id&gt;/&apos;)def hello_int(id): print(id) print(type(id)) return &apos;hello int: %s&apos; % (id)@blue.route(&apos;/index/&apos;)def index(): return render_template(&apos;hello.html&apos;)@blue.route(&apos;/getfloat/&lt;float:price&gt;/&apos;)def hello_float(price): return &apos;float: %s&apos; % price@blue.route(&apos;/getstr/&lt;string:name&gt;/&apos;)def hello_name(name): return &apos;hello name: %s&apos; % name@blue.route(&apos;/getpath/&lt;path:url_path&gt;/&apos;)def hello_path(url_path): return &apos;path: %s&apos; % url_path@blue.route(&apos;/getuuid/&apos;)def gello_get_uuid(): a = uuid.uuid4() return str(a)@blue.route(&apos;/getbyuuid/&lt;uuid:uu&gt;/&apos;)def hello_uuid(uu): return &apos;uu:%s&apos; % uu 5.2 methods请求方法常用的请求类型有如下几种 12345GET : 获取POST : 创建PUT : 修改(全部属性都修改)DELETE : 删除PATCH : 修改(修改部分属性) 定义url的请求类型: 1@blue.route(&apos;/getrequest/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Django","slug":"Centos部署Django项目","date":"2018-06-11T11:23:21.000Z","updated":"2018-06-11T11:24:04.889Z","comments":true,"path":"2018/06/11/Centos部署Django项目/","link":"","permalink":"http://yoursite.com/2018/06/11/Centos部署Django项目/","excerpt":"","text":"Centos部署Django项目安装MariaDB安装命令 1yum -y install mariadb mariadb-server 安装完成MariaDB，首先启动MariaDB 1systemctl start mariadb 设置开机启动 1systemctl enable mariadb 设置密码命令: mysql_secure_installation 12345678910111213141516171819202122Enter current password for root:&lt;–初次运行直接回车设置密码Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车New password: &lt;– 设置root用户的密码Re-enter new password: &lt;– 再输入一次你设置的密码其他配置Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车,Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车初始化MariaDB完成，接下来测试登录mysql -u root -p 开启远程连接在mysql数据库中的user表中可以看到默认是只能本地连接的，所有可以添加一个新的用户，该用户可以远程访问 1. 创建用户12345678# 先使用数据库use mysql;# 针对ipcreate user &apos;root&apos;@&apos;192.168.10.10&apos; identified by &apos;password&apos;;#全部 create user &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;; 2. 授权123456789101112# 给用户最大权限grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;;# 给部分权限(test 数据库)grant all privileges on test.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos; with grant option;# 刷新权限表flush privileges;# 查看show grants for &apos;root&apos;@&apos;localhost&apos;; 接下来就可以在远程的数据库可视化工具中直接访问该服务器中的mysql了。 12# 访问数据库mysql -u root -p 安装python3.6在centos中，系统默认只提供python2.7的版本，但是项目我们使用的python3.6的版本。所有我们自己安装python3 安装Python3的方法首先安装依赖包 123yum -y groupinstall &quot;Development tools&quot;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 然后根据自己需求下载不同版本的Python3，我下载的是Python3.6.2 12345678wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz然后解压压缩包，进入该目录，安装Python3tar -xvJf Python-3.6.2.tar.xzcd Python-3.6.2./configure --prefix=/usr/local/python3make &amp;&amp; make install 最后创建软链接 123ln -s /usr/local/python3/bin/python3 /usr/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 安装环境1. 安装virtualenv1yum install python-virtualenv 2. 创建虚拟环境123456virtualenv --no-site-packages envcd env# 激活虚拟环境source bin/activate 3. 安装环境需要的包123pip3 install -r re_install.txt其中re_install.txt文件中记录的是需要安装包的名称以及对应的版本 部署该部署采用的是cenots7系统来部署 Django的项目中，在工程目录下settings.py文件中有一个DEBUG=True参数，如果DEBUG=False则会出现js,css，img无法加载的情况出现。 原因如下： Django框架仅在开发模式下提供静态文件服务。当我开启DEBUG模式时，Django内置的服务器是提供静态文件的服务的，所以css等文件访问都没有问题，但是关闭DEBUG模式后，Django便不提供静态文件服务了。想一想这是符合Django的哲学的：这部分事情标准服务器都很擅长，就让服务器去做吧！ 1. 测试环境中部署方式在测试环境中一般都直接使用python manage.py runserver的方式去运行项目。其中就涉及到DEBUG=False的修改，静态目录的修改等，具体修改如下： 123456789101112131415修改settings.py配置文件中的DEBUG=False模式，修改ALLOEWD_HOST=[&apos;*&apos;]修改工程目录下的urls.pyfrom django.views.static import serveurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^axf/&apos;, include(&apos;axf.urls&apos;, namespace=&apos;axf&apos;)), # 增加以下的url路由 url(r&apos;^static/(?P&lt;path&gt;.*)$&apos;, serve, &#123;&quot;document_root&quot;: settings.STATICFILES_DIRS[0]&#125;), url(r&apos;^$&apos;, views.home)] 2. 正式环境中部署方式正式环境中部署为nginx+uwsgi来部署django项目 2.1 安装nginxa）添加nginx存储库 1yum install epel-release b) 安装nginx 1yum install nginx c) 运行nginx Nginx不会自行启动。要运行Nginx 1systemctl start nginx nginx的运行命令： 12systemctl status nginx 查看nginx的状态systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动 d）系统启动时启用Nginx 1systemctl enable nginx e）如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信： 12345sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 运行结果如下: 3.配置uwsgi3.1 安装uwsgi1pip3 install uwsgi 然后进行环境变量的配置， 建立软连接 1ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi 4. 配置项目代码，配置项目nginx，配置uwsgi.ini等本案例的配置文件，都习惯将每一个项目的配置文件，日志文件，虚拟环境放在一起，这样开发方便，运维也方便维护 项目的目录结构如下： 其中： conf是配置文件，用于存放项目的nginx.conf文件，uwsgi.ini文件 logs是日志文件，用于存放nginx的启动成功和失败文件，以及uwsgi的运行日志文件 env是用于存放虚拟环境 src是项目文件，该目录下上传的是目录代码 4.1 配置nginx.conf文件首先：编写自己项目的nginx.conf文件如下： 每一个项目对应有一个自己定义的nginx的配置文件，比如爱鲜蜂项目，我定义为axfnginx.conf文件 1234567891011121314151617server &#123; listen 80; server_name 39.104.176.9 localhost; access_log /home/logs/access.log; error_log /home/logs/error.log; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8890; &#125; location /static/ &#123; alias /home/src/axf/static/; expires 30d; &#125; &#125; 其次：修改总的nginx的配置文件，让总的nginx文件包含我们自定义的项目的axfnginx.conf文件 总的nginx配置文件在：/etc/nginx/nginx.conf中 以上步骤操作完成以后，需要重启nginx： 1systemctl restart nginx 如果自定义的axfnginx.conf文件没有错误的话，查看nginx的运行状态会有如下的结果： 4.2 配置uwsgi文件在conf文件夹下除了包含自定义的axfnginx.conf文件，还有我们定义的uwsgi.ini文件 123456789101112131415161718192021222324252627[uwsgi]projectname = axfbase = /home/src# 守护进程master = true# 进程个数processes = 4# 虚拟环境pythonhome = /home/env/axfenv# 项目地址chdir = %(base)/%(projectname)# 指定python版本pythonpath = /usr/local/python3/bin/python3# 指定uwsgi文件module = %(projectname).wsgi# 和nginx通信地址:端口socket = 127.0.0.1:8890# 日志文件地址logto = /home/logs/uwsgi.log 运行项目: 1uwsgi --ini uwsgi.ini","categories":[],"tags":[{"name":"Centos部署Django项目","slug":"Centos部署Django项目","permalink":"http://yoursite.com/tags/Centos部署Django项目/"}]},{"title":"Django","slug":"爱鲜蜂项目","date":"2018-06-11T11:18:21.000Z","updated":"2018-06-11T11:18:16.590Z","comments":true,"path":"2018/06/11/爱鲜蜂项目/","link":"","permalink":"http://yoursite.com/2018/06/11/爱鲜蜂项目/","excerpt":"","text":"爱鲜蜂项目day01：1）开发流程—先演示配置好的，并且运行起来的项目 123a) 先看运行起来的项目，大致看看开发功能有那些，实现技术要使用那些b）需要使用的模型创建，字段的定义c）提供数据---事先准备好插入数据的sql，第二天提供 2） 项目搭建 123456789101112131415161718a）虚拟环境搭建 a1）pychram的解释器interpreter的配置 a2）debug的配置 virtualenv --no-site-packages -p D:/python3/python3.6.exe envb）创建项目 b1）创建app b2）创建templates b3）创建静态文件 b4）开发接口文档doc目录的创建 b4）settings.py文件中的installed_app的配置，databases的配置，templates的配置，static的配置, login_url = &apos;/login/&apos; b5）工程的__init__.py中初始化pymysql，install_as_mysqldbc）前端页面渲染 c1）模板的继承，定义base.html，挖坑&#123;% block title%&#125;&#123;% endblock %&#125;以及填坑 c2）静态css，js，img的渲染。&#123;% load static %&#125;以及直接/static/css/xxx.css 3）功能的梳理 123456789101112131415a）框架分析 a1）用户中心 a2）首页商品展示 a3) 闪购（商品列表） a4）购物车 a4.1）订单系统 a4.2）收货地址 a4.3）支付 a4.4）积分系统 a4.5）vip a4.6）物流 a4.7）评论系统 a4.8）优惠券b）开发过程 b1）首页--闪购--购物车--个人模块 4）后端页面渲染 12a）编写urls--&gt;views的逻辑b）把首页/闪购/购物车/我的页面，全部render渲染出来，不用加载数据都可以 5）首页展示信息模型定义 1234a）banner轮播模型定义b）导航栏模型定义c）必购模型定义d）商店模型定义 ----&gt;以上模型定义都一样 6）闪购模型定义（FoodType） 12345678a）闪购左侧菜单分类b）顶测分类 b1）全部类型----全部分类 b2）综合排序----综合排序、销量排序、价格排序、价格升序c）定义搜索url、/axf/market/ID1/ID2/ID3/ c1）ID1:左侧菜单分类id c2）ID2：全部类型的分类（0） c3）ID3：综合排序的分类（0,1,2,3） 部分功能图片: 以下展示首页 作业：先演示讲模板拆分为基础模板，然后通过继承挖坑等技术来完成模板的拆分 12341）拆分所有的模板2）页面可点击各模板，展示对应的页面，首页/闪购/购物车/个人中心等3）登录注册退出----使用中间件的方式4）头像上传 day02：*）上午演示登录注册注销功能（客户端和服务端都验证令牌的时效） 1234a) 令牌验证，创建单独的表，存令牌和过期时间b) cookie中设置缓存时间c) 也可以使用django自带的登录 authenticate login logout 1）中间件的配置 1234a）判断cookies中是否有登录的令牌ticket，如果没有不做任何处理b）如果cookies中有令牌，则去数据库userticket表中去判断令牌是否有效c）令牌无效或者过期的话，不做任何处理d）令牌有效的话，将user的数据给request.user 个人中心模块 a）先验证request中是否有user的信息，如果有则在个人中心页面中渲染用户名，头像图片等信息 a1）待付款和待收货的数据刷新，通过user找到order订单表，查看订单表的订单状态 c）没有验证到request中的user信息的话，则在个人中心页面中，展示登录以及注册的按钮的信息 3）购物车页面 1a）如果request中没有user的信息，则跳转到登录页面 4）注册 1a）ajax在用户名的onblur的点击的时候，执行查询用户名是否重复的请求，并展示查询的结果，用户名重复或者用户名可用 5）登录 12a）随机生成ticket，存放在cookies中，设置过期时间b）userticket表中存用户和ticket的信息，以及过期时间，过期时间和cookies中的过期时间一致 部分功能展示： 登录注册, 个人中心 day03：a）购物车模型 （CartModel） 1a1）购物车页面展示，购物车中信息展示 b）购物车逻辑分析，模型和订单模型的关联等 1b1) 关联用户，关联商品，数量等 d）增加或者删除选购商品数量,使用ajax异步修改数据 123b1）增加/axf/addtocart/?goodsid=475b2）删除/axf/subtocart/?goodsid=475b3）选中下单的商品，is_select字段，创建订单的时候过滤掉is_select为False的商品数据 e）下单订单生成 12e1）订单模型order，购物车下单以后生成订单信息，包括用户信息，订单支付状态，订单创建时间等e2）根据订单信息创建订单和商品的表信息，该表中关联订单，关联商品，商品的数量等信息 作业： 12341. 商品购物车全选或者全不选实现2. 商品购物车中的总价展示实现3. 商品购物车中删除商品的个数为0时，该商品不展示4. 闪购页面的商品数量数据的刷新，使用ajax去刷新 部分功能展示：闪购，购物车 day04：1） 订单支付 1a1）点击订单支付alipay的按钮，实现修改订单的支付状态，并且跳转到个人中心页面 2）个人中心页面 123b）个人中心的待支付页面，待收货页面c）个人中心的待收货刷新，代付款订单个数刷新 部分功能展示： 支付页面，待收货/代付款页面 day05:复习1： 1a）复习所有代码 部署2: 测试环境部署方式和线上环境nginx+uwsgi部署方式： 部署的服务器采用的是ubuntu16系统 环境搭建: 安装包 123sudo apt update apt install mysql-server mysql-client 设置远程访问mysql 12345678910111213141516a) 查找 mysql.conf find / -name mysql.cnf b）注释mysql.cof文件的bind_address cd /etc/mysql/mysql.conf.d vim mysqld.cnf c）切换mysql数据库 use mysql; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root123&apos; WITH GRANT OPTION; flush privileges; d) 重启 service mysql restart /status/ stop/ start 在测试环境中部署方式： 修改django的配置文件 1234567891011121314a）修改settings.py文件中的DEBUG=FALSE，ALLOWED_HOST=[&apos;*&apos;] b）修改urls.py b1）url中加入以下配置 from django.views.static import serve url(r&apos;^static/(?P&lt;path&gt;.*)$&apos;, serve, &#123;&quot;document_root&quot;: settings.STATIC_ROOT&#125;), url(r&apos;^media/(?P&lt;path&gt;.*)$&apos;, serve, &#123;&quot;document_root&quot;: settings.MEDIA_ROOT&#125;), b2）setting中 STATIC_ROOT = os.path.join(BASE_DIR, &apos;static&apos;) b3）url中修改首页访问的地址 url(r&apos;^$&apos;, views.home) 修改首页的启动地址 1修改工程目录中的url ，并修改url(r&apos;^$&apos;, views.home) 安装pip3 1apt install python3-pip 安装必备库 123pip3 install django==1.11pip3 install pymysqlpip3 install Pillow 查看进程 1netstat -lntp 启动项目 1python3 manage.py runserver 0.0.0.0:80 使用nginx+uwsgi配置django项目 安装nginx 1sudo apt install nginx 查看nginx的状态 123456systemctl status nginx 查看nginx的状态systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动或者是如下命令： service nginx status/stop/restart/start 安装uwsgi 1pip install uwsgi nginx的配置文件中加载自定义的nginx的配置文件 123vim /etc/nginx/nginx.conf在server中加入以下配置：include /home/app/conf/*.conf; 配置自定义的nginx配置文件 1234567891011121314151617server &#123; listen 80; server_name 47.92.164.198 localhost; access_log /home/app/log/access.log; error_log /home/app/log/error.log; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8890; &#125; location /static/ &#123; alias /home/app/day11axf0/static/; expires 30d; &#125; &#125; 配置uwsgi，名称为uwsgi.ini 12345678910111213141516[uwsgi]# variablesprojectname = day11axf0newprojectname = day11axfbase = /home/app # config#plugins = pythonmaster = true#protocol = uwsgiprocesses = 4#env = DJANGO_SETTINGS_MODULE=%(projectname).settingspythonpath = %(base)/%(projectname)module = %(newprojectname).wsgisocket = 127.0.0.1:8890logto = %(base)/log/uwsgi.log 启动方式： uwsgi –ini uwsgi.ini 重点：nginx + uWSGI + django的处理流程 首先nginx 是对外的服务接口，外部浏览器通过url访问nginx, nginx 接收到浏览器发送过来的http请求，将包进行解析，分析url，如果是静态文件请求就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件， 如果不是静态文件，而是一个动态的请求，那么nginx就将请求转发给uwsgi,uwsgi 接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi,wsgi 根据请求调用应用程序的某个文件，某个文件的某个函数，最后处理完将返回值再次交给wsgi,wsgi将返回值进行打包，打包成uwsgi能够接收的格式，uwsgi接收wsgi发送的请求，并转发给nginx,nginx最终将返回值返回给浏览器。 要知道第一级的nginx并不是必须的，uwsgi完全可以完成整个的和浏览器交互的流程，但是要考虑到某些情况 安全问题，程序不能直接被浏览器访问到，而是通过nginx,nginx只开放某个接口，uwsgi本身是内网接口，这样运维人员在nginx上加上安全性的限制，可以达到保护程序的作用。 负载均衡问题，一个uwsgi很可能不够用，即使开了多个work也是不行，毕竟一台机器的cpu和内存都是有限的，有了nginx做代理，一个nginx可以代理多台uwsgi完成uwsgi的负载均衡。 静态文件问题，用django或是uwsgi这种东西来负责静态文件的处理是很浪费的行为，而且他们本身对文件的处理也不如nginx好，所以整个静态文件的处理都直接由nginx完成，静态文件的访问完全不去经过uwsgi以及其后面的东西。 uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。","categories":[],"tags":[{"name":"axf","slug":"axf","permalink":"http://yoursite.com/tags/axf/"}]},{"title":"Django","slug":"restful的使用","date":"2018-06-01T12:06:21.000Z","updated":"2018-06-01T12:06:24.617Z","comments":true,"path":"2018/06/01/restful的使用/","link":"","permalink":"http://yoursite.com/2018/06/01/restful的使用/","excerpt":"","text":"restful1.分页修改settings.py配置文件, 增加分页的配置信息 123456REST_FRAMEWORK = &#123; &apos;DEFAULT_PAGINATION_CLASS&apos;: &apos;rest_framework.pagination.PageNumberPagination&apos;, &apos;PAGE_SIZE&apos;: 2, &apos;DEFAULT_RENDERER_CLASSES&apos;: ( &apos;utils.functions.CustomJsonRenderer&apos;, ), 123456789101112131415161718&#123; &quot;code&quot;: 0, &quot;msg&quot;: &quot;请求成功&quot;, &quot;data&quot;: &#123; &quot;count&quot;: 1, &quot;next&quot;: null, &quot;previous&quot;: null, &quot;results&quot;: [ &#123; &quot;s_name&quot;: &quot;瑶瑶&quot;, &quot;s_yuwen&quot;: 88, &quot;g&quot;: 1, &quot;id&quot;: 3, &quot;g_name&quot;: &quot;python1&quot; &#125; ] &#125;&#125; 注意: 在结果在data对应的value值中, 有一个count的key, 表示返回数据有1条, next表示下一个的url, pervious表示上一页的url 2.过滤修改settings.py配置文件, 增加filter过滤的信息 2.1安装过滤的库1pip install django-filters 2.2配置settings.py的信息配置DEFAULT_FILTR_BANNCKENDS 123456789101112REST_FRAMEWORK = &#123; # 分页显示 &apos;DEFAULT_PAGINATION_CLASS&apos;: &apos;rest_framework.pagination.PageNumberPagination&apos;, &apos;PAGE_SIZE&apos;: 2, # 配置过滤 &apos;DEFAULT_FILTER_BACKENDS&apos;: ( &apos;rest_framework.filters.DjangoFilterBackend&apos;, &apos;rest_framework.filters.SearchFilter&apos;), &apos;DEFAULT_RENDERER_CLASSES&apos;: ( &apos;utils.functions.CustomJsonRenderer&apos;, ),&#125; 2.3views中指定filter_class12345678910111213class api_student(mixins.ListModelMixin, mixins.UpdateModelMixin, mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.DestroyModelMixin, viewsets.GenericViewSet): # 学生的所有信息 queryset = Student.objects.all().filter(delete=False) # 序列化学生的所有信息(表现层, 将数据按照一定格式返回给用户) serializer_class = StudentSerializer # 过滤 filter_class = StudentFilter 2.4编写filter_class过滤信息12345678910111213141516import django_filtersfrom rest_framework import filtersfrom app.models import Studentclass StudentFilter(filters.FilterSet): # 模糊查询学生的s_name姓名 s_name = django_filters.CharFilter(&apos;s_name&apos;, lookup_expr=&apos;contains&apos;) # 查询语文成绩大于80分的学生 s_yuwen = django_filters.NumberFilter(&apos;s_yuwen&apos;, lookup_expr=&apos;gte&apos;) s_yuwen_max = django_filters.NumberFilter(&apos;s_yuwen&apos;, lookup_expr=&apos;lte&apos;) class Meta: model = Student fields = [&apos;s_name&apos;, ] 2.5实现方法2.5.1查询学生的姓名中包含瑶的学生使用filter_class进行过滤筛选 : 1http://127.0.0.1:8080/stu/student/?name=瑶 不使用filter_class进行筛选: 123def get_queryset(self): query = self.queryset return query.filter(s_name__contaions=&apos;瑶&apos;) 2.5.2查询学生的创建时间在2018年5月1日到2018年6月1日的学生信息使用filter_class进行过滤筛选: 1http://127.0.0.1:8080/stu/student/?create_min=2018-05-01&amp;create_max=2018-06-01 不使用filter_class进行筛选: 1234def get_queryset(self): query = self.queryset return query.filter(s_create_time__gte=&apos;2018-05-01&apos;, s_create_time__lte=&apos;2018-06-01&apos;) 2.53查询状态为休学的学生信息1http://127.0.0.1:8080/stu/student/?status=LEAVE_SCH 2.5.4查询所有的学生, 按照id从大到小排序123def get_queryset(self): query = self.queryset return query.order_by(&apos;-id&apos;)","categories":[],"tags":[{"name":"restful的使用","slug":"restful的使用","permalink":"http://yoursite.com/tags/restful的使用/"}]},{"title":"Django","slug":"Django Rest 框架","date":"2018-05-31T09:17:23.000Z","updated":"2018-05-31T12:23:48.066Z","comments":true,"path":"2018/05/31/Django Rest 框架/","link":"","permalink":"http://yoursite.com/2018/05/31/Django Rest 框架/","excerpt":"","text":"Django rest 框架实例网: xyty.klicen.com 官方文档www.django-rest-framework.org REST是所有Web应应用都应该遵守的架构设计指导原则 Representational State Transfer - 翻译是 ‘表现层状态转化’ REST核心 : 资源 , 状态转移, 统一接口资源 : 是REST最明显的特征, 是指对某类信息实体的抽象, 资源是服务器上一个可命名的抽象概念的, 资源是以名词为核心来组织的, 首先关注的是名词 状态转移 :是指客户端与服务端进行交互的过程中, 客户端能够通过对资源的表述, 实现操作资源的目的 统一接口 :RSET要求, 必须通过统一的接口来对资源执行各种操作, 对于每个资源只能执行一组有限的操作, 比如, 客户端通过HTTP的4个请求方式(POST, GET, PUT, PATCH)来操作资源, 也就意味着, 不管你的url是什么, 不管请求的资源是什么但操作的资源接口都是统一的 GET用来获取资源 , POST用来新建资源(也可用于更新资源), PUT(PATCH)用来更新资源, DELETE用来删除资源 状态码服务端向用户返回请求api的结果, 在结果中包含了status code 状态码的, 可以通过状态码去判断请求api的状态是成功还是失败 123456789101112200 OK - [GET]: 服务器成功返回用户请求的数据, 该操作是幂等的(Idempotent)201 CREATED - [POST/PUT/PATCH]: 用户新建或修改数据成功202 Accepted - [*]: 表示一个请求已经进入后台排队(异步任务)204 NO CONTENT - [DELETE]: 用户删除数据成功400 INVALID REQUEST - [POST/PUT/PATCH]: 用户发出的请求有误, 服务器没有进行新建或修改数据的擦操作, 该操作是幂等的401 Unauthorized -[*]: 表示用户没有权限(令牌, 用户名, 密码错误)403 Forbidden - [*]: 表示用户得到授权(与401错误相对), 但是访问时被禁止的404 NOT FOUND -[*]: 用户发出的请求针对的是不存在的记录, 服务器没有进行操作, 该操作的幂等的406 Not Accepted - [GET]: 用户请求的格式不可得(比如用户请求JSON格式, 但只有XML格式)410 Gone -[GET]: 用户请求的资源被永久删除, 且不会再得到的422 Unprocesable entity - [POST/PUT/PATCH]: 当创建一个对象时, 发生一个验证错误500 INTERNAL SERVER ERROR - [*]: 服务器发生错误, 用户将无法判断发出的请求是否成功 rest 资源 , 统一接口 , 状态转移 1234567891011127.0.0.1:8080/app/student/ - (student为资源) : 获取所有的学生 GET127.0.0.1:8080/app/student/ : 创建的学生 POST127.0.0.1:8080/app/student/1/: 获取学生中id为1的那一个学生 GET 127.0.0.1:8080/app/student/1/ : POST \\ PUT \\ PATCH127.0.0.1:8080/app/student/1/ : DELETE127.0.0.1:8080/app/grade/ : 获取所有的班级 GET 2.http请求方式 123456789GET : 用于获取POST : 用于创建PUT : 用于修改, 全部属性都会修改PATCH : 用于修改, 部分属性进行修改DELETE : 删除 3.旧接口 123127.0.0.1:8080/app/student/?id=1127.0.0.1:8080/app/student/1/ - 符合restframe风格 接口文档 : 4.安装 , django中使用restful 12pip install djangorestframeworkpip install django_filter # Filtering support 添加内容到settings配置文件 1234567891011INSINSTALLED_APPS = ( ... &apos;rest_framework&apos;, )# settings最后添加下面内容REST_FRAMEWORK = &#123; &apos;DEFAULT_PAGINATION_CLASS&apos;: &apos;rest_framework.pagination.PageNumberPagination&apos;, &apos;PAGE_SIZE&apos;: 2,&#125; 添加urls.py文件中的内容 1234urlurlpatterns = [ ... url(r&apos;^api-auth/&apos;, include(&apos;rest_framework.urls&apos;))] 5.删除 请求url:http://127.0.0.1:8000/app/api/student/2/ 12345678910def destory(self, request, *args, **kwargs):instance = self.get_objects()self.perform_destory(instance)return Response(status=status.HTTP_204_NO_CONTENT)def perform_destory(self, instance): instance.delete() instance = self.get_object() 等价于 stu=Student.objects.get(id=2)instance.delete() 等价于 stu.delete() 6.to_representation中instance是当前循环学生的对象 7.rest的配置, 分页配置, 还有权限设置 1234567RESREST_FRAMEWORK = &#123; &apos;DEFAULT_PAGINATION_CLASS&apos;: &apos;rest_framework.pagination.PageNumberPagination&apos;, &apos;PAGE_SIZE&apos;: 2, &apos;DEFAULT_AUTHENTICATION_CLASSES&apos;:() &#125;&#125; 8.ajax 请求方式 1234567$.(url, function(msg)&#123; &#125;)$.post(url, function(msg)&#123; &#125;) 以上方式: url表示请求的地址, function(msg)代表, 请求成功后的回调函数, msg是api返回的结果 12345678910111213$.aj$.ajax(&#123; url:&apos;&apos;, # 请求的url地址 type:&apos;&apos;, # GET POST PATCH PUT DELETE data:&#123;&apos;name&apos;:name, &apos;sex&apos;:sex&#125;, # 代表请求的参数 dataType:&apos;json&apos;, headers:&#123;&apos;X-CSRFToken&apos;: csrf&#125; # 代表传递的csrf值 success:function(msg)&#123; 成功执行回调函数 &#125;, error:function(msg)&#123; 失败执行回调函数 &#125;&#125;); API接口 code : 状态码 前端VUE框","categories":[],"tags":[{"name":"rest","slug":"rest","permalink":"http://yoursite.com/tags/rest/"}]},{"title":"Django","slug":"Django装饰器","date":"2018-05-30T10:27:23.000Z","updated":"2018-05-31T12:34:00.970Z","comments":true,"path":"2018/05/30/Django装饰器/","link":"","permalink":"http://yoursite.com/2018/05/30/Django装饰器/","excerpt":"","text":"定义闭包(装饰器) 123def is_longin(func): def check_login(request): 如果登录, 返回函数func 123ticket = request.COOKIES.get(&apos;ticket&apos;) if not ticket: 如果没有登录, 跳转到登录页面 12345678910111213return HttpResponseRedirect(reverse(&apos;user:login&apos;)) user = Users.objects.filter(ticket=ticket) if not user: # 如果没有登录, 跳转到登录页面 return HttpResponseRedirect(reverse(&apos;user:login&apos;)) return func return check_login 2.模板 1234567891011在基础base.html中挖坑 &#123;% block xxx %&#125; &#123;% endblock %&#125;在index.html页面中, 需要先继承&#123;% extends &apos;base.html &apos;%&#125; &#123;% block xxx %&#125; &#123;% endblock %&#125;加载上一次填坑的内容 &#123;% block.super %&#125; 3.F/Q 12345678910111213141516171819202122last(): 最后一个first() : 第一个一对多: 多找一: student.g.g_name student.g.id 一找多: grade.student_set.all()一对一: student.g.g_name grade.student.all() F(): 用于做计算 1students.filters(s_yuwen__gt= F(&apos;s_shuxue&apos;) + 10) Q - 用于过滤信息 |或者 &amp;并且 ~取反 查询python班语文大于等于80或者数学小于等于80的学生 12345678910111213 grade = Grade.objects.filter(g_name=&apos;python&apos;).first() students = grade.student_set.all() stu = students.filter(Q(s_yuwengte=80) | Q(s_shuxue__lte=80))查询python班语文小于80并且数学小于等于80的学生 stu = students.filter(~Q(s_yuwengte=80) &amp; Q(s_shuxue__lte=80)) 4.模板 1234567891011121314151617ifforifequal : 判断是否相等forloop.counter : 循环, 从1开始forloop.revcounter : 倒循环, 倒1结束 forloop.counter0 : 循环, 从0开始forloop.revcounter0 : 倒循环, 倒0结束Ctrl shift + Delete ----删除浏览器缓存 创建班级的模型 12345class Grade(models.Model): g_name = models.CharField(max_length=20) g_create_time = models.DateTimeField(auto_now_add=True) 12class Meta: db_table = &apos;grade&apos; 创建学生的模型： 123456789101112131415161718192021class Student(models.Model): stu_name = models.CharField(max_length=6, unique=True) stu_sex = models.BooleanField(default=0) stu_birth = models.DateField() stu_delete = models.BooleanField(default=0) stu_create_time = models.DateField(auto_now_add=True) stu_operate_time = models.DateField(auto_now=True) stu_tel = models.CharField(max_length=11) stu_yuwen = models.DecimalField(max_digits=3, decimal_places=1, default=0) stu_shuxue = models.DecimalField(max_digits=3, decimal_places=1, default=0) g = models.ForeignKey(Grade) 12class Meta: db_table = &apos;stu&apos; 创建学生拓展的模型： class StuInfo(models.Model): 123456stu_addr = models.CharField(max_length=30)stu_age = models.IntegerField()stu = models.OneToOneField(Student)class Meta: db_table = &apos;stu_info&apos; 实际操作: 1234561.通过某个学生拓展表去获取学生信息2. 通过学生表获取个人拓展表的信息3. 获取python班下的所有学生的信息和拓展表的信息4. 获取python班下语文成绩大于80分的女学生5. 获取python班下语文成绩超过数学成绩10分的男学生6. 获取出生在80后的男学生，查看他们的班级","categories":[],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]},{"title":"关于Django的基本操作","slug":"Categories","date":"2018-05-26T03:22:22.000Z","updated":"2018-05-26T07:38:56.764Z","comments":true,"path":"2018/05/26/Categories/","link":"","permalink":"http://yoursite.com/2018/05/26/Categories/","excerpt":"","text":"windows环境下使用Django $ mkdir 文件夹名 #创建项目目录 $ cd 文件夹名 #进入项目目录 在项目目录: $ python -m venv hello_django_venv #创建虚拟环境并命名(hello为文件名) $ cd hello_django_venv #进入虚拟环境 $ cd Script #进入Scripts $ activate #激活环境 在虚拟环境的script目录下: deactivate #退出虚拟环境 pip install django #在虚拟环境下安装django依赖库 pip install django==指定版本号 #安装指定版本的django django-admin –version #查看安装的django版本 在虚拟环境的项目目录下: django-admin startproject hello_django #创建名为hello的项目 cd hello_django #切换到项目目录 python manage.py runserver #启动django服务器 python manage.py startapp hrs #创建一个名为hrs的应用 linux下使用Django mkdir hello_django #创建项目目录 cd hello_django/ #切换到项目目录 进入目录之后: python3 -m venv hd_venv #使用venv模块创建虚拟环境，目录名hd_venv source hd_venv/bin/activate #激活虚拟环境 在虚拟环境bin目录下: python -m pip install –upgrade pip #更新pip到最新版本 pip install django #使用pip安装django django-admin –version #通过安装django时安装的脚本工具django-admin检查django版本 在虚拟环境的项目目录下: django-admin startproject 项目名 #创建项目 python manage.py startapp 应用名 #创建应用名 python manage.py runserver (0.0.0.0:80) #启动django服务器,可以指定端口号","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"你好 世界 !","slug":"hello-world","date":"2018-05-25T09:01:15.146Z","updated":"2018-05-26T03:18:47.765Z","comments":true,"path":"2018/05/25/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Redis主从切换","slug":"Redis主从切换","date":"2018-05-24T12:53:58.000Z","updated":"2018-05-26T08:28:01.005Z","comments":true,"path":"2018/05/24/Redis主从切换/","link":"","permalink":"http://yoursite.com/2018/05/24/Redis主从切换/","excerpt":"","text":"公网IP:120.79.000.00 uname:查看操作系统 cat /ect/centos-release:查看操作系统版本 ps -ef (| grep &lt;进程名&gt;):查看进程,使用管道可以查询某个进程 top :查看进程,是进程的当前状态一次性快照属于动态查看,ps -ef 是进程过去状态的一次性快照,属于静态查看 netstat -nap:查看进程状态,例如listening ,connected等 ifconfig -a:查看ip地址 kill (-9) PID:关闭一个进程,-9显示最高级别的删除,强制终止,可能会导致数据丢失 adduser 用户名:创建一个非root的用户,权限较低 userdel 用户名:删除指定用户 passwd (用户名):为指定用户添加密码,若用户已有密码,则修改密码,如果不添加用户名,则默认修改当前用户密码 logout(exit):退出当前用户 su 用户名:切换用户 shutdown(init 0):关机 reboot(init 6):重启 man 指令:查看指令手册 info 指令:更为详细的解释指令 指令 –help:查看指令帮助 whatis 指令: 简短解释指令 whereis 指令(文件):从Linux的数据库中查询指定指令或者文件 find 文件:用于查询文件 pwd:查看当前所处目录 sudo 指令:使用管理员身份运行指令,普通用户使用该命令 mkdir 文件夹:创建一个空的文件夹 rmdie 文件夹:删除一个空的文件夹 touch 文件:创建一个文件 rm -rf 文件(文件夹):递归删除一个文件夹,也可以用户删除文件 ls -al:查看当前目录所有文件的长格式,包括隐藏文件 cd :改变目录 cat -n 文件:查看文件内容并显示行数 cat -n | more(less):一页一页的查看文件内容 head -num 文件:查看文件的开头几行 tail -num 文件:查看文件的末尾几行 cp 文件 文件路径/(文件名):将文件拷贝到文件夹中,同时可以对其重命名 mv 文件 文件:对文件进行重命名 mv 文件 文件路径/(文件名):将文件剪切到文件夹中,同时可以对其重命名 grep 搜索内容 文件 :在文件中搜索指定内容 cat 文件 | grep 内容:在文件中搜索指定内容并查看 ctrl c:终止正在前台运行的程序 ctrl z:将前台正在运行的程序拿到后台并停止运行 jobs:查看后台有无程序在执行 fg %num:将后台正在执行的任务拿到前台 bg %num:将后台停止运行的程序继续执行,一般配合ctrl z使用 wc 文件 (-l -w -c):计算文件中有多少行,多少字符,多少字节 diff 文件 文件:比较两个文件的差别 file 文件:查看文件性质 history:查看历史命令 last:查看登陆历史 echo:回声命令,其实功能很强大,暂时还没怎么研究 ssh + 用户名@IP地址:登陆到其他用户 ln 文件名 文件夹路径:在某个文件夹中为文件创建一个硬链接^1 ln -s 文件路径 /user/bin:为一个程序创建一个软链接 gunzip 压缩文件(后缀为gz):对一个文件进行解压缩 gzip 文件:将一个文件压缩成.gz后缀文件 xz -d 压缩文件(后缀为xz):对一个文件进行解压缩 xz -z 文件:将一个文件压缩成xz后缀文件 tar -xvf 归档文件:解归档 tar -cvf 文件名 文件,文件,…(*):将文件进行归档并对归档后的文件进行命名 tar -tf 归档文件:读取归档文件中的内容 wget url:下载指定网址内容 alias 新命令 ‘旧命令’:为一个命令重新进行命名 unalias 命令:取消重命名 chmod 755 文件:将文件的执行模式更改为当前用户可读可写可执行,其他用户或者组成员只能读和执行[^ 2] vim的命令模式[^3 ] vim的默行模式[^4] yum install 软件:安装开源软件 yum list installed:查看安装的所有软件 yum search 软件:搜索软件 yum update 软件:更新软件 rpm -ivh 软件:安装软件,可以查看安装过程 rpm -e 软件:删除软件 rpm -qa:查看所有安装的软件 rpm -qa | grep 软件:搜索安装的某个文件 rpm -qa |grep 软件 | xargs rpm -r :搜索软件并将其删除 nginx:启动nginx nginx -s stop:停止nginx,也可以使用kill 进程号来结束进程 systemctl start mariadb:启动MySQL,systemctl命令用于执行系统服务 systemctl stop mariadb:停止MySQL systemctl status mariadb:查看服务的运行状态 systemctl enable mariadb:开机自启MySQL systemctl disable mariadb:取消自启MySQL make &amp;&amp; make install:进行源代码安装 redis-server redis.conf :启动redis服务器 redis-cli -h ip:连接redis服务器 auth password:连接服务器后输入密码 pip3 install ipython:安装ipython ln -s /user/local/python3.6/bin/ipython3 /user/bin/ipython3:创建软链接 firewall-cmd –zone=public –list-ports:查看防火墙所有的打开端口 firewall-cmd –zone=public –add-port=80/tcp –permanent:永久打开防火墙80端口 firewall-cmd –zone=public –remove-port=80/tcp –permanent:永久删除防火墙80端口 启动redis服务器 配置redis.conf文件 bind &lt;内网地址&gt; port &lt;端口号&gt; requirepass &lt;服务器密码&gt; 启动redis服务器 redis-server redis.conf &amp; 启动redis客户端 redis-cli -h &lt;服务器地址&gt; -p &lt;服务器端口&gt; -a &lt;服务器密码&gt; 进去之后输入Info replication查看master,slaver信息 redis中主从切换在作为master的服务器中: 在redis.conf文件中写入masterauth &lt;master服务器密码&gt;[^5 ] 在sentinel.conf文件中进行哨兵的配置[^6 ] bind &lt;本服务器内网地址&gt; port &lt;哨兵端口号&gt; sentinel monitor mymaster &lt;master服务器地址&gt; &lt;master服务器端口号&gt; &lt; 投票数&gt;至少小于哨兵个数的一半) sentinel auth-pass mymaster &lt;master服务器密码&gt; sentinel down-after-milliseconds mymaster 5000:指定服务器已经断线所需的毫秒数,超时则主观下线 sentinel failover-timeout mymaster 18000:表示master超时期限,超时则客观下线 在作为salve的服务器中: 在redis.conf文件中写入slaveof &lt;master服务器外网地址&gt; &lt;master服务器端口号 &gt; 在redis.conf文件中写入 masterauth &lt;master服务器密码&gt; [^ 2]: 同时可以使用chmod u+w+r+x,g+w+r+x,o+w+r+x 文件来更改执行模式[^3 ]: dd:删除整行 dw:删除光标所在的单词 g:回到内容的第一行 G:回到内容的最后一行 pg+down:向下翻页 pg+up:向上翻页[^4]: /:搜索关键词,可以使用正则表达式来进行匹配,但是量词前面需要加上/,例如/+,/.,1,%s/…/…/g:全局替换 ! 命令:可以在vim模式下使用外部命令,并且会切换到外部进行执行[^5 ]: 该master很有可能在将来成为slave,所有要在配置文件输入以后可能成为master的服务器密码,其实我感觉应该是所有的redis服务器都使用同一个密码,不然谁知道谁成为master.[^6 ]: 哨兵在master和slave服务器都可以进行配置","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"非关系型数据库","slug":"非关系型数据库Redis","date":"2018-05-18T01:05:13.000Z","updated":"2018-05-26T08:19:06.575Z","comments":true,"path":"2018/05/18/非关系型数据库Redis/","link":"","permalink":"http://yoursite.com/2018/05/18/非关系型数据库Redis/","excerpt":"","text":"非关系型数据库Redis1988 提出了NoSQL (非关系型数据库的补充) 2008/2010 — Big Data(大数据) NoSQL = No SQL NoSQL = No Only SQL 关系型数据库(锁) - 数据价值高强一致性 NoSQL产品: 四大类非关系型数据库 : — Redis - 高速缓存(内存比硬盘快, 内存比硬盘小) - 键值对数据库 — MongoDB - 存放结构不严谨价值不高的数据 - 文档数据库 — Neo4j - 社交网站 - 图数据库 — HBase - 列族数据库 查看是否安装redis1cd user/local/bin - ll | grep redis - cd ~ - 配置文件 - ls - cp - vim -61行 - :!ifconfig - 内网地址复制 - enter - i进入编辑模式 - 粘贴到61行 - 84行改端口 改成11223(0到2的10次方-1) - 命令模式480行/requirepass 1qaz2wsx - 命令模式 database可以改库数量 启服务器1234567891011121314151617181920212223启服务: redis-server myredis.conf &amp; - 杀进程kill 5021 (会显示关机过程, 数据显示已保存) - 查看后台进程jobs - 前台运行 fg %2 - ctrl+c - redis benchmark -h 120.77.222.217 -p 11223 -a 1qaz2wsx查看是否成功ps -ef | grep redis 查进程redis-cli -h 120.77.222.217 -p 11223 -- set username admin - keys*(看到所有键) / keys u*(查看u打头的键) / keys [u,p]*(查看u,p打头的键) - set foo hello ex 300 - get foo - get bar - ttl foo(查看存活时间) - expire username 15(15秒后过期) - ttl username - get username - ttl username - ttl email save (保存) / bgsave(后台保存)select 1(切换到2号库)set foo bar - get foo - select 0 - get fooselect 15 - flushdb - keys* - select 0 - keys* - flushall(清理底层所有库)dbsizeinfo - 查看服务器相关信息shutdown save - 关闭服务器并保存数据 / shutdown no save - 关闭服务器不保存数据set - 放键值对del username - 删除数据select index - 切换到指定的数据库 开启防火墙时连接123456操作步骤 :1.systemctl start firewalld(开启防火墙)2.firewall-cmd --add-port=11223/tcp --permanent --zone=public(给防火墙开洞)3.firewall-cmd --reload(重新加载配置)4.redis-cli -h 120.79.135.242 -p 11223 (客服端连接服务器)5.auth 1qaz2wsx(输入密码)6.ping 回复PONG 就成功了(ping是否连接成功) 关闭防火墙时连接12345操作步骤 :1.systemctl stop firewalld2.redis-benchmark -h 120.79.135.242 -p 11223 -a 1qaz2wsx3.redis-cli -h 120.79.135.242 -p 11223 4.auth 1qaz2wsx5.ping 回复PONG 就成功了 五种数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970key(键) - 键都是字符串 String(字符串) : set foo 1set bar 1.23set username helloincr foo (网站投票, 网站页面首页缓存,SQL语句查询结果缓存)incr fooincrby foo 50 (网站投票) - redis中操作incrbyfloat bar 1.23 Strlen - 长度decr - 减少append user name - 键后面追加内容与set相似 JSON格式的字符串也可以-------------------------------------------Hash(哈希表) : 键值对存放数据 - 字典里面放字典hset student1 name &quot;Hao Luo&quot;hset student1 age 38hset student1 gender Malehget student1 namehget student1 genderhgetall student1 哈希表最适合放对象-------------------列子------------hset 10 dno 10hset 10 dname 财务部hset 10 dloc 重庆get 10hgetall 10三个字节utf-8hset 20 dno 20hset 20 dname 研发部hset 20 dloc 成都hgetall 20field - value 方式存在hdel 10 dloc - 删哈希表里的字段del key - 删键hexists ... - 判断是否有...hincrby - 增加------------------------List(列表) - push lpush foo 10 20 30 40lrange - 取指定范围元素-1 表示全部拿完元素lrange foo 0 -1 - 倒序rpush foo 10 20 30 40lrange foo 0 -1 - 顺序pop - 拿走元素nil - 空, 元素没有了lindex - 查看元素linsert - 插入元素lrem - 删除元素列表应用场景(微博,生产者-消费者模式 - 消息队列)------------------------------Set(集合) - 元素不能重复 - 去重sadd foo 10 10 20 10 20 30 sinter 求交集 foo barsunion 并集 foo barsddif 差集 foo barsremove - 删元素smembers - 删元素 fooscard foo -------------------------SortedSet(有序集合) : zadd foo 100 hell 75 good 102 world 300 apple根据设定的值排序zrange foo 0 -1 zrevrange foo 0 -1(自动排序) - 游戏排位zincrby foo 400 hello (加值) - 改变排位的值zincrange foo 0 -1 可以看到改变后排位的值type - 查看键的类型","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Python基础","slug":"Python基础","date":"2018-05-17T10:32:19.000Z","updated":"2018-05-26T05:18:43.342Z","comments":true,"path":"2018/05/17/Python基础/","link":"","permalink":"http://yoursite.com/2018/05/17/Python基础/","excerpt":"","text":"Python基础 数据类型数字型(Number) 字符型(String) 布尔型(boolean) 空类型(None) 列表型(list) 元组型(tuple) 字典型(dict) 集合型(set) 标准数据类型Python3 中有六个标准的数据类型： 1Number（数字） ​ String（字符串） 1List（列表） ​ Tuple（元组）​ Dictionary（字典） 1Sets（集合） 变量对变量类型进行转换时可以使用Python的内置函数 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 Number（数字）整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）复数(complex) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 数学函数函数 返回值 ( 描述 )abs(x) 返回数字的绝对值，如abs(-10) 返回 10ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃 。使用 使用 (x&gt;y)- (x&lt;y) 替换。 exp(x) 返回e的x次幂(ex), 如math.exp(1) 返回2.718281828459045fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。pow(x, y) x**y 运算后的值。round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。sqrt(x) 返回数字x的平方根。 String（字符串）字符串常用内建函数 str1 = ‘’hello, world!’ str1.split( ) 通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 len() len函数计算字符串的长度 len(str1) # 13 str1.capitalize() 获得字符串首字母大写的拷贝 str1.capitalize() # Hello, world! str1.upper() 获得字符串变大写后的拷贝 str1.upper() # HELLO, WORLD! str1.find(str2, beg=0 end=len(string)) 检测 str2 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 12345678&gt;&gt;&gt;str1 = 'abca'&gt;&gt;&gt; print(str1.find('a')) # 从下标0开始，查找在字符串里第一个出现的子串，返回结果：00&gt;&gt;&gt; print(str1.find('a', 1)) # 从下标1开始，查找在字符串里第一个出现的子串：返回结果33&gt;&gt;&gt; print(str1.find('3')) # 查找不到返回-1-1&gt;&gt;&gt; index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常. str1.startswith(str2) 检查字符串是否以指定的字符串开头 12print(str1.startswith('He')) # Falseprint(str1.startswith('hel')) # True str1.endswith(str2) 检查字符串是否以指定的字符串结尾 1print(str1.endswith('!')) # True str1.center(width, &#39;=&#39;) 将字符串以指定的宽度居中并在两侧填充指定的字符 1print(str1.center(20, '=')) #===hello, world!==== rjust ljust 右对齐/左对齐 str1.rjust(width, &#39; &#39;) 将字符串以指定的宽度靠右放置左侧填充指定的字符 str1.isdigit() 检查字符串是否只由数字构成 ,返回 True 或 False str1.isalpha() 检查字符串是否只由字母构成 ,返回 True 或 False str1.isalnum() 检查字符串是否以数字和字母构成 ,返回 True 或 False str1.strip() 获得字符串修剪左右两侧空格的拷贝 12str1 = ' jackf1234@166.com 'print(str1.strip()) # jackf1234@166.com List（列表）list1 = [1, 3, 5, 7, 100] len(list1) 列表元素个数 max(list1) 返回列表元素最大值 min(list1) 返回列表元素最小值 list(对象) 将对象转换为列表 , 对象:字符串,元组,集合; 字典只能把键转成列表 list1.append(元素) 在列表末尾添加新的元素list1.insert(下标, 元素) 在指定下标出添加一个元素,原来位置处的元素往后移动 list1.pop() 将列表中指定下标的元素删除, 如果默认不传递参数,则删除的是最后一个元素 list1.remove() 移除列表中指定的元素 list1.clear() 清除列表中所有的元素 list1.reverse() 用于反向列表中元素 等同于[::-1] reversed(seq) 函数返回一个反转的迭代器。 seq – 要转换的序列，可以是 tuple, string, list 或 range list1.sort() 应用在 list 上的方法, 返回的是对已经存在的列表进行操作 12345list1 = [4, 1, 45, 21, 2, 7]# print(list1.sort()) 打印为None,没有返回值,只对原来列表排序list2 = list1.sort()print(list2) #结果还是为None print(list1) #[1, 2, 4, 7, 21, 45] 123456# 0 1 2 3 4 5 6 7 8a = [1, 2, 3, 4, 5, 6, 7, 8, 9]b = a[7:3:-1]print(b) #[8, 7, 6, 5]print(a[1:3:-1]) #Noneprint(a[3:1:-1]) #[4, 3] Tuple（元组）元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 len(tuple) 计算元组元素个数。 max(tuple) 返回元组中元素最大值。 min(tuple) 返回元组中元素最小值。 tuple(seq) 将列表转换为元组。 Dictionary（字典）无序集合, key唯一,必须是不可变类型访问获取方式: ​ dict[key] ​ dict.get(key) 添加元素: ​ dict[key] = value # key为原字典中不存在的键 修改: ​ dict[key] = balue # key为原字典中存在的键 dict.keys() 以列表返回字典中所有的键dict.values() 以列表返回字典中所有的值dict.items() 以列表返回可遍历的(键, 值) 元组数组 [(键, 值), (键, 值), (键, 值)]dict.setdefault() 返回指定键的值,如果键不存在于字典中，将会添加键并将值设为默认值dict.pop([key]) 删除指定键值对, 需传入参数 # 没有remove()方法enumerate()用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 字典内置函数dict1 = {‘name’:’shuaixiaohao’, ‘age’:22, ‘weight’:60} len(dict) 计算字典元素个数，即键的总数。 print(len(dict1)) # 3 str(dict) 输出字典，以可打印的字符串表示。 print(str(dict1)) #{‘name’: ‘shuaixiaohao’, ‘age’: 22, ‘weight’: 60}print(type(str(dict1))) # type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 字典内置函数radiansdict.clear()删除字典内所有元素radiansdict.copy()返回一个字典的浅复制radiansdict.fromkeys()创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值radiansdict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值key in dict如果键在字典dict里返回true，否则返回falseradiansdict.items()以列表返回可遍历的(键, 值) 元组数组radiansdict.keys()以列表返回一个字典所有的键radiansdict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为defaultradiansdict.update(dict2)把字典dict2的键/值对更新到dict里radiansdict.values()以列表返回字典中的所有值pop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。popitem()随机返回并删除字典中的一对键和值(一般删除末尾对)。 Sets（集合）set是无序,没有重复元素set集合是不可改变的创建一个空的集合 set1 = set(()); set1 = set([]); set1 = set({}) 注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典set.add(): 增加一个元素(重复元素不能添加) # 没有append()方法set.remove():删除元素, 参数是元素set.pop():删除最后一个元素set1 &amp; set2 交集set1 | set2 并集set1 - set2 差集set1 ^ set2 交并集 12dict--&gt;set 取字典的键, 传入集合set --&gt; dict(错误) # 不能将集合转换成字典, 只有键, 没有值 三元条件运算python中: 1value1 if condition else value2 JavaScript中: conditon ? valuel1 : value2 问号前面的条件如果成立 123function getStyle(elem) &#123; return window.getComputedStyle ? window.getComputedStyle(elem): elem.currentStyle;&#125; 迭代器与生成器迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 字符串，列表或元组对象都可用于创建迭代器 生成器 yield 函数被称为生成器（generator）, 生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器 , 每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。 函数匿名函数python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 1lambda [arg1 [,arg2,.....argn]]:expression #arg-参数 ,expression-表达式 变量作用域变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的 L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域 global 和 nonlocal关键字 当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了 1234567import randomrandom.choice():返回列表,元祖,字典中的某一个值random.choices():返回列表,元祖,字典中的指定个数值个值 k 关键字参数random.random():返回0-1之间的数, [0, 1) random.uniform():返回指定的一个区间范围的随机数 [, )random.randint():返回指定区间范围的随机整数 [, ]random.shuffle():将列表中的数据进行打乱排序 123451. 不定长参数: *args2. 关键字参数: **kw3. 偏函数: 导入模块 import functools functools.partical()就是创建一个新的函数.不需要自行定义函数.直接将结果赋值给一个变量,而 这个变量就是一个函数.这个函数的目的是将默认参数给固定住4. 回调函数: 定义函数时,将函数名作为参数传递过来,然后在函数里边再次调用函数 偏函数正则表达式 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 \\ 匹配字符串的结束\\ .exe\\ 匹配字符串的结束\\ .exe 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?\\exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.ba.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 re模块中的核心函数 1234re.match(pattern, string, flags=0)pattern 匹配的正则表达式string 要匹配的字符串flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 面向对象面向对象的三个基本特征是：封装、继承、多态 封装： ​ 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 隐藏复杂的现实细节，暴露简单的调用接口。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。 保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==&gt;数据封装。 方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==&gt;方法封装。 当对象含有完整的属性和与之对应的方法时称为封装。 从对象外面不能直接访问对象的属性，只能通过和该属性对应的方法访问。 对象的方法可以接收对象外面的消息。 继承： ​ 从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)。继承主要实现重用代码，节省开发时间。 在类名后边的括号里一般写的是基类的类名 子类中继承自父类(基类),则父类的成员属性和成员方法都可以被子类所继承 父类中私有的成员属性不能继承给子类的 多态： “一个接口，多种方法” ​ 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 多态的三个条件: 继承的存在(继承是多态的基础,没有继承就没有多态) 子类重写父类的方法(多态下调用子类重写的方法) 父类引用变量指向子类对象(子类到父类的类型转换) 数据抽象一找到和对象相关的数据一属性( 名词） 行为抽象一 找到和对象相关的行为一方法（动词） __slots__ ​ 限定自定义类型的对象只能绑定某些属性，可以通过在类中定义_slots\\_变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 123class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') 魔法方法区分开函数和方法的含义： 1.函数：类外部定义的，跟类没有直接关系的；形式： def func(*argv): 2.方法：class内部定义的函数（对象的方法也可以认为是属性）；分为两种： ① python自动产生的（魔法方法）：一般形式为 __func__()，python会在对应的时机自动调用该函数； ② 人为自定义的方法：一般和普通函数没有区别，只是定义在了class中而已 3.方法与函数的区别： 方法可认为是函数的特殊情况； ① 方法定义在class内部 ② 方法的第一个参数应为 cls(类方法) 或者 self(实例方法) 列出几个基本魔法方法： __new__(cls[,*argv]) __new__ 是在一个对象实例化的时候所调用的第一个方法 它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法 _new__ 决定是否要使用该 \\_init__方法，因为 __new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__ 没有返回实例对象，则 __init__ 不会被调用 __new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string __init__(self,[…]) 类的初始化方法 ，当一个实例对象被定义时调用 *__del__(self)** 析构器，当一个实例被析构时调用 _new__ 和 \\_init__ 是对象的构造器， __del__ 是对象的销毁器 Python内置装饰器在Python中有三个内置的装饰器，都是跟class相关的：staticmethod、classmethod 和property。 staticmethod 是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用 classmethod 与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型） property 是属性的意思，表示可以通过通过类实例直接访问的信息 类方法、静方法 都是通过给类发消息来调用的 实例方法 发给对象的消息 在类创建对象后，实例方法才能被使用，使用格式为：对象名.实例方法 ​ 名。实例方法可以使用该方法所在类的所有静态成员和实例成员。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from abc import abstractmethod, ABCMeta# 面向对象的三大支柱 - 封装 / 继承 / 多态# 封装 - 隐藏复杂的实现细节 暴露简单的调用接口# 继承 - 从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)# 多态 - 见下面# 在创建类时通过指定metaclass=ABCMeta可以将一个类声明为抽象类# 所谓抽象类就是不能创建对象的类 它存在价值是留给它的子类去继承# 经验: 我们强烈建议将用来继承的类声明为抽象类class Employee(object, metaclass=ABCMeta): def __init__(self, name): self._name = name @property def name(self): return self._name[:-1] + '*' # 被abstractmethod包装器修饰的方法是抽象方法 # 所谓抽象方法就是没有实现专门留给子类去重写的方法 # 如果子类没有重写这个抽象方法 那么子类相当于也是抽象类 不能创建对象 @abstractmethod def get_salary(self): passclass Manager(Employee): def get_salary(self): return 12000class Programmer(Employee): def __init__(self, name): super().__init__(name) self._working_hour = 0 @property def working_hour(self): return self._working_hour @working_hour.setter def working_hour(self, working_hour): self._working_hour = working_hour if working_hour &gt; 0 else 0 def get_salary(self): return 150 * self._working_hourclass Salesman(Employee): def __init__(self, name): super().__init__(name) self._sales = 0 @property def sales(self): return self._sales @sales.setter def sales(self, sales): self._sales = sales def get_salary(self): return 1500 + self._sales * 0.05def main(): emp_list = [Manager('王大锤'), Programmer('骆昊'), Programmer('李大嘴'), Salesman('白元芳')] for emp in emp_list: if isinstance(emp, Programmer): #判断一个对象是否是一个已知的类型 hour = int(input('请输入%s本月工作时间: ' % emp.name)) emp.working_hour = hour elif isinstance(emp, Salesman): sales = float(input('请输入%s本月销售额: ' % emp.name)) emp.sales = sales # 多态 - 给同样的对象发送同样的消息(同样的引用调用同样的方法)做了不同的事情 # 实现多态最关键的就是子类对父类已有方法进行重写 不同的子类给出不同的实现版本 print('%s月薪为￥%.2f元' % (emp.name, emp.get_salary()))if __name__ == '__main__': main() 异常处理123456789try: print('try...') r = 10 / 0 print('result:', r)except ZeroDivisionError as e: print('except:', e)finally: print('finally...')print('END') try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。 无论有没有异常finally语句被执行。 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如: 12except (RuntimeError, TypeError, NameError): pass ​ try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行 ​ 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。 1异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。 文件读、写文件1open(filename, mode) mode：决定了打开文件的模式：只读，写入，追加等 操作模式 具体含义 1234567**&apos;r&apos;** 读取 （默认）**&apos;w&apos;** 写入（会先截断之前的内容）**&apos;x&apos;** 写入，如果文件已经存在会产生异常**&apos;a&apos;** 追加，将内容写入到已有文件的末尾**&apos;b&apos;** 二进制模式**&apos;t&apos;** 文本模式（默认）**&apos;+&apos;** 更新（既可以读又可以写） with语句来自动帮我们调用close()方法 （关闭文件） with 语句就可以保证文件之类的对象在使用完之后一定会正确的执行他的清理方法 1with open(\"myfile.txt\") as f: 文件对象的方法fileObject.read([size]) ​ 从文件读取指定的字节数，如果未给定或为负则读取所有。 fileObject.write() ​ 写文件 # 如果要写入字符串以外的数据,先将他转换为字符串 fileObject.close() ​ 关闭文件 fileObject.readline([size]) ​ 读取整行内容,包括\\n字符, 如果给定参数则从文件开始读取指定的字符个数 fileObject.readlines([sizeint]) ​ 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 f.tell() ​ 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数). f.seek(偏移量,[起始位置]) ​ 用来移动文件指针 #偏移量:单位:比特,可正可负起始位置:0-文件头,默认值;1-当前位置;2-文件尾 操作文件和目录os模块:在这个模块中给我们封装好了系统操作的功能函数(方法) import os os.getcwd() 返回当前的工作目录 # 获取绝对路径 os.listdir(path) 返回指定的文件夹包含的文件或文件夹的名字的列表 os.mkdir(path) 在当前目录下创建新的目录 os.rmdir(path) 删除目录, 只能删除空目录 os.rename(src, dst) 对文件进行重命名 os.stat(file) 获取文件属性 os.remove(file) 删除文件 #可以将本文件删除 os.path.join(path1, path2) 路径拼接 os.path.split(path) 拆分路径 # 返回一个元组(目录, 最后一个文件/目录名称) os.path.splitext(path) 获取文件的或站名 os.path.exists(path) 判断文件/目录是否存在 os.path.isfile(path) 判断是否是文件 os.path.getsize(file) 获取文件的大小 os.path.dirname(path) 获取当前文件的目录 os.path.basename(path) 获取当前文件/目录名 StringIO很多时候，数据读写不一定是文件，也可以在内存中读写 StringIO模块主要用于在内存缓冲区中读写数据。模块是用类编写的，只有一个StringIO类， # 所以它的可用方法都在类中。此类中的大部分函数都与对文件的操作方法类似。 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue())hello world! getvalue()方法用于获得写入后的str。 BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 进程和线程进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位 线程：是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源 一个程序至少有一个进程,一个进程至少有一个线程。线程是最小的执行单元，而进程由至少一个线程组成。 多进程​ Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 fork()是os模块里的函数。 ​ 子进程永远返回 0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 Windows没有 fork调用，multiprocessing模块就是跨平台版本的多进程模块。 multiprocessing模块提供了一个Process类来代表一个进程对象 1234567891011121314from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__=='__main__': print('Parent process %s.' % os.getpid()) #getpid()取得进程识别码 p = Process(target=run_proc, args=('test',)) #创建一个Process实例 print('Child process will start.') p.start() #启动子进程 p.join() #等待子进程结束后再继续往下运行 print('Child process end.') 执行结果如下： 1234Parent process 928.Process will start.Run child process test (929)...Process end. 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用 start()方法启动。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步 Pool如果要启动大量的子进程，可以用进程池的方式批量创建子进程： 多线程Python的标准库提供了两个模块：_thread 和 threading，_thread 是低级模块，threading 是高级模块，对 _thread 进行了封装。绝大多数情况下，我们只需要使用 threading 这个高级模块。 启动一个线程就是把一个函数传入并创建 Thread 实例，然后调用 start() 开始执行 网络编程协议- protocol- 通信双方对话的规范和标准 IP.Internet Protocol- 寻址和路由www.baidu.com---&gt; 180.97.33.108 TCP和UDP是在IP协议之上构建的传输协议它们能够提供传输数据的服务TCP提供了可靠传输服务TCP- Transfer Control Protocol握手机制+冗余校验—&gt; 重发一次 TCP.Transfer Control Protocol I1.可靠通信[数据不传丢也不传错]滑动窗口机制2.流量控制(自动调节发送数据的速度3.拥塞控制(网络拥堵时会降低发送速度) QQ 微信.应用级QQ— ICQ— OICQHTTP— Hyper-Text Transfer ProtocolHTTPS— SecureSMTP– Simple Mail Transfer ProtocolPOP3— Post Office Protocol version 3IMAP—Internet Mail Access Protocolxerox— macintosh— Windows URL— Uniform Resource Locator协议://域名或IP地址:80/路径/资源名 网络API(应用程序编程接口) / 网络 123456789requests.get()用于请求目标网站，类型是一个HTTPresponse类型import requestsresponse = requests.get('http://www.baidu.com')print(response.status_code) # 打印状态码print(response.url) # 打印请求urlprint(response.headers) # 打印头信息print(response.cookies) # 打印cookie信息print(response.text) #以文本形式打印网页源码print(response.content) #以字节流形式打印 TCP编程Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 服务器12345678910111213141516171819202122232425262728293031323334353637#创建服务器发文件from io import SEEK_ENDfrom socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimefrom time import sleepdef main(): # 1.创建套接字对象并指定使用哪种传输服务 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(区分不同的服务) server.bind(('10.7.152.130', 9090)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: data = f.read() f.seek(0, SEEK_END)#设置文件读取指针在文件当前位置 file_len = f.tell()#返回文件当前位置指针 # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) while True: # accept方法是一个阻塞方法 如果没有客户端连接到服务器这个方法就会阻塞代码不会向下执行 client, addr = server.accept() # 5.发送数据 client.send('guido.jpg'.encode('utf-8')) client.send(str(file_len).encode('utf-8')) total = 0 while total &lt; file_len: client.send(data[total:total+1024]) total += 1024 sleep(0.001) # 6.断开连接 client.close()if __name__ == '__main__': main() 客户端12345678910111213141516171819202122from socket import socketdef main(): # 创建一个socket client = socket() # 建立连接: client.connect(('10.7.152.130', 9090)) filename = client.recv(1024).decode('utf-8') print(filename) file_len = int(client.recv(1024).decode('utf-8')) print(file_len) with open('C:/Users/Administrator/Desktop/' + filename,'wb') as f: total = 0 while total &lt; file_len: date = client.recv(1024) f.write(date) total += 1024 print('图片已保存')if __name__ == '__main__': main()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Web前端","slug":"HTML","date":"2018-05-17T00:59:32.000Z","updated":"2018-05-26T07:53:04.801Z","comments":true,"path":"2018/05/17/HTML/","link":"","permalink":"http://yoursite.com/2018/05/17/HTML/","excerpt":"","text":"什么是HTML?HTML 是用来描述网页的一种语言。 Tag: Content 装内容装数据 CSS: Display 渲染,显示 JavaScript: Behavior 交互,行为 HTML 指的是超文本标记语言: Hyper Text Markup Language HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 文档包含了HTML 标签及文本 内容 HTML文档也叫做web 页面 HTML格式1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;主题title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 解析\\&lt;!DOCTYPE html&gt; 声明为 HTML5 文档 \\ 元素是 HTML 页面的根元素 \\ 元素包含了文档的元（meta）数据 \\ 元素描述了文档的标题 \\ 元素包含了可见的页面内容 \\ 元素定义一个大标题 \\ 元素定义一个段落 \\ 水平分割线 \\折行符 \\\\ 下标标签 \\\\ 上标标签 \\\\ 强调标签,变粗 \\\\ 强调标签,斜体 列表无序列表12345&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;芒果&lt;/li&gt;&lt;/ul&gt; 浏览器显示: 苹果 草莓 芒果 有序列表12345&lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;芒果&lt;/li&gt;&lt;/ol&gt; 浏览器显示: 苹果 草莓 芒果 自定义列表\\ 标签定义一个描述列表。 \\ 标签与 \\ （定义项目/名字）和 \\ （描述每一个项目/名字）一起使用。 123456&lt;dl&gt; &lt;dt&gt;星期&lt;/dt&gt; &lt;dd&gt;1 2 3 4 5 6 7&lt;/dd&gt; &lt;dt&gt;月份&lt;/dt&gt; &lt;dd&gt;1 2 3 4 5 6 7 8 9 10 11 12&lt;/dd&gt; &lt;/dl&gt; 浏览器显示: 星期​ 1 2 3 4 5 6 7月份​ 1 2 3 4 5 6 7 8 9 10 11 12 链接1&lt;a href=\"url\"&gt;链接文本&lt;/a&gt; href属性描述了链接的目标。 页面链接\\ 12345当前页面跳转,target=\"_self\"可以不写&lt;a href=\"http://www.baidu.com\" target=\"_self\"&gt;百度&lt;/a&gt;&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;打开新页面跳转&lt;a href=\"http://www.qq.com\" target=\"_blank\"&gt;腾讯&lt;/a&gt; 锚点链接(id属性)\\ id属性可用于创建在一个HTML文档书签标记。 id=”tips” tips-提示部分,自己定义 123&lt;h1 id=\"top\"&gt;Hello,word!&lt;/h1&gt;&lt;a href=\"#top\"&gt;回顶部&lt;/a&gt; 功能性链接1234自动弹出发邮箱功能&lt;a href=\"mailto:fenghao1994@163.com\"&gt;联系站长&lt;/a&gt;发起消息会话,wp.qq.com网站自动生成&lt;a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes\"&gt;&lt;img border=\"0\" src=\"http://wpa.qq.com/pa?p=2::52\" alt=\"联系客服\" title=\"联系客服\"/&gt;&lt;/a&gt; 图像定义图像的语法是: 1&lt;img src=\"url\" alt=\"som_text\" &gt; src 指 “source”。源属性的值是图像的 URL 地址,或图片的相对路径。 alt 为图像定义一串预备的可替换的文本。在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。 height（高度） 与 width（宽度）属性用于设置图像的高度与宽度，属性值默认单位为像素，也可以不设置。 1&lt;img src=\"./mm.jpg\" alt=\"这是一个女的\" width=\"300\" height=\"500\"&gt; 表格1234567891011121314151617181920212223&lt;table border=\"1\"&gt; &lt;caption&gt;个人信息统计&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;身高&lt;/th&gt; th&lt;th&gt;体重&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王大锤&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td colspan=\"2\" align=\"center\"&gt;170&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"..jpg\" width=\"60\" height=\"20\"&gt; &lt;div&gt;李小刀&lt;/div&gt; &lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;180&lt;/td&gt; &lt;td&gt;58&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;caption&gt; 定义表格标题 &lt;th&gt; 定义表格的表头 &lt;tr&gt; 定义表格的行 &lt;td&gt; 定义表格单元 align=&quot;center&quot; 居中 colspan=&quot;&quot; 合并 音频1234&lt;audio controls&gt; &lt;source src=\"horse.ogg\"&gt; &lt;source src=\"horse.mp3\"&gt;&lt;/audio&gt; controls 属性供添加播放、暂停和音量控件；可以换成autoplay 自动播放；autoplay loop自动循环播放。 \\ 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件 视频1234&lt;video width=\"320\" height=\"240\" controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt;&lt;/video&gt; controls 元素提供了 播放、暂停和音量控件来控制视频。 width 和 height 属性控制视频的尺寸.尽量不要写 区块区块元素 大多数 HTML 元素被定义为块级元素或内联元素。 块级元素在浏览器显示时，通常会以新行来开始（和结束）。 实例: \\, \\, \\, \\,\\ 内联元素 内联元素在显示时通常不会以新行开始。 实例: \\, \\, \\, \\ \\ 元素 \\ 元素是块级元素，它可用于组合其他 HTML 元素的容器。 \\ 元素 \\ 元素是内联元素，可用作文本的容器 表单 表单用于收集不同类型的用户输入。表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签 \\ 来设置 输入元素多数情况下被用到的表单标签是输入标签（\\）。 输入类型是由类型属性（type）定义的。 文本域（Text Fields）文本域通过\\ 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 123456789101112131415161718&lt;form action=\"\" method=\"post\" enctype=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;必填信息&lt;/legend&gt; &lt;p&gt; &lt;label&gt;用户名: &lt;/label&gt; &lt;input type=\"text\" name=\"uid\" placeholder=\"请输入用户名\" required&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;密码 &lt;/label&gt; &lt;input type=\"password\" name=\"pwd\"&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;性别: &lt;/label&gt; &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\" checked&gt;女 &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt; action “”里面是要提交的地址 method 规定如何发送表单数据（表单数据发送到 action属性所规定的页面）。共有两种方法：post 方法和 get 方法 – get get是从服务器上获取数据 get是把参数数据队列加到提交表单的action属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到 get传送的数据量较小。 get安全性非常低。 – post post是向服务器传送数据 post是通过HTTP post机制,将表单内各个字段与其内容放置在HTML HEADER内一起传送到action属性所指的URL地址。用户看不到这个过程。 post传送的数据量较大，一般被默认为不受限制。 post安全性较高。 enctype 属性规定在将表单数据发送到服务器之前如何对其进行编码。 注意：只有 method=”post” 时才使用 enctype 属性。 &lt;fieldset&gt;&lt;/fieldset&gt; 定义了一组相关的表单元素，并使用外框包含起来 &lt;legend&gt;&lt;/legend&gt; 定义了 \\ 元素的标题 &lt;label&gt; 定义了 \\ 元素的标签，一般为输入标题 &lt;input&gt; 输入标签输入类型是由类型属性（type）定义的。 name 属性规定表单的名称,用于在 JavaScript 中引用元素，或者在表单提交之后引用表单数据。 placeholder 属性规定可描述输入字段预期值的简短的提示信息,该提示会在用户输入值之前显示在输入字段中。 注意：placeholder 属性适用于下面的 input 类型：text、search、url、tel、email 和 password。 required 属性是一个布尔属性,规定必需在提交表单之前填写输入字段。 注意：required 属性适用于下面的 input 类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio 和 file。 密码字段密码字段通过标签\\ 来定义 单选按钮&lt;input type=&quot;radio&quot;&gt; 标签定义了表单单选框选项 checked选框默认选项 复选框\\ 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项 123456&lt;label&gt;爱好: &lt;/label&gt;&lt;input type=\"checkbox\" name=\"fav\"&gt;游戏&lt;input type=\"checkbox\" name=\"fav\" checked&gt;阅读&lt;input type=\"checkbox\" name=\"fav\" checked disabled&gt;旅游&lt;input type=\"checkbox\" name=\"fav\"&gt;运动&lt;input type=\"checkbox\" name=\"fav\"&gt;其他 checked disabled 默认必选项,不能取消. 文件上传1&lt;input type=\"file\" name=\"photo1\" multiple&gt; multiple 可接受多个值的文件上传字段 日期1&lt;input type=\"date\" name=\"b\"&gt; 下拉列表选项\\定义了下拉选项列表 \\定义下拉列表中的选项 12345678&lt;label&gt;籍贯: &lt;/label&gt;&lt;select&gt;name=\"prov\" &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option selected&gt;四川&lt;/option&gt; &lt;option&gt;云南&lt;/option&gt; &lt;option&gt;海南&lt;/option&gt;&lt;/select&gt; selected 默认选项 多行文本框\\ 标签定义一个多行的文本输入控件。文本区域中可容纳无限数量的文本，其中的文本的默认字体是等宽字体（通常是 Courier）。可以通过 cols 和 rows 属性来规定 textarea 的尺寸大小 字符实体12345678910111213141516 空格 &amp;nbsp;&lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt;&amp; 和号 &amp;amp;&quot; 引号 &amp;quot;&apos; 撇号 &amp;apos; (IE不支持)￠ 分 &amp;cent;£ 镑 &amp;pound; ¥ 人民币/日元 € 欧元 &amp;euro;§ 小节 &amp;sect;× 乘号 &amp;times; ÷ 除号 &amp;divide;© 版权 &amp;copy;® 注册商标 &amp;reg;™ 商标 &amp;trade; CSS什么是 CSS? CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明，声明总是以分号(;)结束，声明组以大括号({})括起来 就近原则 具体性原则 id选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器 重要性原则 盒子模型 1content（内容） - padding（内边距） - border（边框） - background-image（背景图片） - background-color（背景颜色） - margin（外边距） 边框和轮廓border 设置对象边框的特性 border-collapse : collapse 设置表格的边框合并为一个单一的边框 border-color 设置或检索对象的边框颜色 outline 设置或检索对象外的线条轮廓。 字体font-size 设置字体属性 font-family 规定文本的字体系列 font-style 规定文本的字体尺寸 font-weight 规定字体的粗细 文本color 指定文本的颜色 line-height 设置行高 text-align 规定文本的水平对齐方式 text-decoration 规定添加到文本的装饰效果，：none取消下划线 内边距padding 简写属性在一个声明中设置所有填充属性。该属性可以有1到4个值 padding-bottom 设置元素的底填充padding-left 设置元素的左填充padding-right 设置元素的右填充padding-top 设置元素的顶部填充 背景div是不支持background-color 的，background-color是table等的属性，你要用background：#（这里是颜色代码）；这样来写 background 复合属性，设置对象的背景特性 background-color 设置或检索对象的背景颜色background-image 设置或检索对象的背景图像 外边距margin 在一个声明中设置所有外边距属性，该属性可以有1到4个值 display属性display：none 此元素不会被显示。 display：block 此元素将显示为块级元素，此元素前后会带有换行符。 display：inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 hidden 元素是不可见的。 列表list-style 在一个声明中设置所有的列表属性list-style-position 设置列表项标记的放置位置 定位position:static; 正常文档流 position:relative; 相对定位 相对于元素原来的位置定位没有脱离文档流,对兄弟元素没有影响 position:absolute; 绝对定位(相对于父元素来设置位置 脱离了文档流 position:fixd； 固定定位（相对于浏览器窗口摆放） z-index 属性指定一个元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 float：left 元素向左浮动。 float：right 元素向右浮动。 黑科技 overflow: auto; 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 overflow: hidden 兄弟选择器 ~ 相邻兄弟选择器 + 12345安装字体@font-face &#123; font-family: '给字体起个名 '; src: url(路径);&#125; JavaScript​ ECMAScript - 语法规范 - ES5 (ECMA欧洲计算机制造商协会) ​ BOM - Browser Object Model - 浏览器对象模型 - window ​ DOM - Document Object Model - 文档对象模型 - document 编程范式(理念) 面向对象编程 函数式编程 层叠样式表前置, JS后置 外部脚本不能包含 \\ 标签。 document.getElementById(“some id”) 。这个方法是 HTML DOM 中定义的, 是用于访问 HTML 元素的正式 W3C 标准x.innerHTML=”Hello JavaScript”; //改变内容 输出JavaScript 显示数据 JavaScript 可以通过不同的方式来输出数据： 使用 window.alert() 弹出警告框。 alert() 方法用于显示带有一条指定消息和一个 确认 按钮的警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 操作 HTML 元素 如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。 请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容： 语法JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值 JavaScript 对大小写是敏感的 分号用于分隔 JavaScript 语句。通常我们在每条可执行的语句结尾添加分号。使用分号的另一用处是在一行中编写多条语句。 在文本字符串中使用反斜杠对代码行进行换行 注释单行注释以 // 开头 多行注释以 / 开始，以 / 结尾 数据类型和变量简单数据类型:字符串（String） 、数字(Number) 、布尔(Boolean) 、数组(Array) 、 空（Null） 、未定义（Undefined） 复杂数据类型: 对象(Object) 当声明新变量时，可以使用关键词 “new” 来声明其类型： JavaScript中有隐式的类型转换 ==比较，它会自动转换数据类型再比较 ===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 ===(全等于/严格等) !==(严格不等) 逻辑运算符: &amp;&amp;(短路与) 只有所有都为true，&amp;&amp;运算结果才是true，第一个为false后面的不再判断 ||(短路或) 只要其中有一个为true，||运算结果就是true，第一个为true后面的不再判断 ! (非) 作用域局部作用域变量在函数内声明，变量为局部作用域。 局部变量：只能在函数内部访问。 全局作用域变量在函数外定义，即为全局变量。 全局变量有 全局作用域 : 网页中所有脚本和函数均可使用。 如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。 JavaScript 变量生命周期JavaScript 变量生命周期在它声明时初始化。 局部变量在函数执行完毕后销毁。 全局变量在页面关闭后销毁。 JavaScript全局函数isNaN() - 是不是不是一个数 parseInt() - 取整数如果取不出返回NaN parseFloat() - 取小数如果取不出返回NaN isFinite() - 是不是有限数值 eval() - 非常强大的函数 evaluate - XSS(跨站脚本攻击) encodeURIComponent() - 处理成百分号编码 decodeURIComponent() - 将百分号编码解码还原 Date 对象创建 Date 对象： new Date() 方法 描述 getFullYear() 从 Date 对象以四位数字返回年份 getMonth() 从 Date 对象返回月份 (0 ~ 11) getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31) getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6) getHours() 返回 Date 对象的小时 (0 ~ 23) getMinutes() 返回 Date 对象的分钟 (0 ~ 59) getSeconds() 返回 Date 对象的秒数 (0 ~ 59) trim() 函数用于去除字符串两端的空白字符 parseInt() 将字符串转换成整数,提取数字 disabled .onclick 绑定与反绑定 递归定义 - - 定义的左边和定义的右边出现了相同的概念 递归调用 - - 函数直接或间接的调用了自身 收敛条件 - 什么时候就不用递归了 递归公式 window对象alert() 浏览器弹出带有一段消息和一个确认按钮的警告框 prompt() 显示可提示用户输入的对话框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 open() 打开一个新的浏览器窗口或查找一个已命名的窗口 close() 关闭浏览器窗口 setTimeout() 在指定的毫秒数后调用函数或计算表达式 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式 clearTimeout() 取消由 setTimeout() 方法设置的 timeout clearInterval() 取消由 setInterval() 设置的 timeout moveTo() 把窗口的左上角移动到一个指定的坐标 moveBy() 可相对窗口的当前坐标把它移动指定的像素 resizeBy() 按照指定的像素调整窗口的大小 window对象属性location - 用于窗口或框架的 Location 对象 属性: location.href 设置或返回当前显示的文档的完整 URL 1document.write(location.href); Location 对象方法: assign() 载入一个新的文档 // window.location.assign(URL) reload() 重新载入当前文档 // location.reload(); replace() 用新的文档替换当前文档 // location.replace(newURL) history - go() / fofward / back screen = avaiwidth / avaiHeight Document 对象查找元素的方法 getElementById() 返回对拥有指定 id 的第一个对象的引用 getElementsByTagName() 返回带有指定标签名的对象集合 getElementsByClassName() 返回文档中所有指定类名的元素集合 querySelector() 根据指定的选择器查找单个元素 querySelectorAll() 根据指定的选择器查找所有元素 绑定事件与取消绑定 document.addEventListener() 方法用于向文档添加事件句柄 document.removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄 element.addEventListener() 方法为指定元素添加事件句柄 1document.addEventListener(event, function) ​ - event 必需。描述事件名称的字符串。’click’ - 当用户点击某个对象时调用的事件句柄 ​ - function 必需。描述了事件触发后执行的函数 修改节点的内容和属性 textContent / innerHTML / nodeValue 访问成员运算符 setAttribute() / getAttribute() / removeAttribute() 创建新节点 - ()追加新的子节点 - appendChild() / insertBefore()删除子节点 - removeChild() 如果已经获得一个节点 如何访问它的父节点、子节点、兄弟节点parentNodechildren / firstChild / lastChildnextSibling / prevSibling DOM事件对象鼠标事件 onmousedown 鼠标按钮被按下 target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口 1event.target 事件捕获 - 从外向里传播事件 事件冒泡 - 从里向外传播事件 jQuery jQuery的$函数的作用: 1、 $(function() {}) - \\$函数中传入的参数是一个函数作用: 绑定页面加载完成之后要执行的回调函数 2、 $(selector) - \\$函数中传入的参数是一个选择器 ​ 作用: 通过选择器获得对应的元素并将其处理成jQuery对象jQuery对象本质是一个数组 ​ 如果需要将jQuery对象还原成原生的JS对象一[index]/get(index) 3、 $(elem) - \\$函数中传入的参数是原生JS对象 ​ 作用: 将原生JS对象转换成jQuery对象(更多的属性更多的方法) 4、 $(tag) - \\$函数中传入的参数是一个标签 ​ 作用: 和标签对应的元素(得到的是jQuery对身) 通过jQuery对象的方法可以用更少的代码做更多的事情 在写代码的时候不需要考虑浏览器兼容性问题(jQuery已经做了处理） 引入多个JS库出现冲突时可以通过下面的方式让出$函数 ​ jQuery.noConfict() ; 让出$函数以后原来用\\$函数的地方全部换成jQuery 查找元素 选择器 * / element / #id / .class / selector1, selector2 ancestor descendant / parent&gt;child / previous+next / previous~siblings 筛选器 基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains(‘…’) / :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute=’value’] / [attribute!=’value’] / [attribute^=’value’] / [attribute$=’value’] / [attribute|=’value’] / [attribute~=’value’] 表单： :input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked 执行操作 内容操作 获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val() 查找操作 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq() 尺寸和位置 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate() 事件 文档加载：ready() / load() 用户交互：on() / off() 回调函数 evt参数代表的是事件对象 - 绑定了和事件相关的所有信息 如果事件回调函数中要用到和事件相关的属性和方法就最好指定evt参数 target / clientX / button / keyCode preventDefault() / stopPropagation() 不管函数是否指定了evt参数当事件发生回调该函数时都会传入该参数 调构造函数 前面加new 数组里删元素要从后往前循环 Ajax原生Ajax - Asynchronous JavaScript and XML 让浏览器向服务器发出异步请求(非阻塞式请求)，等服务器返回了响应数据(JSON/XML)后就可以对页面进行局部刷 新，这样就可以在不中断用户体验的前提下刷新页面数据 JavaScript发送HTTP请求获取数据默认只支持同源数据(同源策略) http://www.abc.com/index.html -&gt; JavaScript 如果要跨域取数据是需要对方提供数据的服务器支持的 JSONP / 服务器端设置支持跨域取数据(RESTful)","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"关于MySQL查询操作","slug":"MySQL查询","date":"2018-05-16T00:43:09.000Z","updated":"2018-05-26T08:54:26.807Z","comments":true,"path":"2018/05/16/MySQL查询/","link":"","permalink":"http://yoursite.com/2018/05/16/MySQL查询/","excerpt":"","text":"MySQL查询12345数据库内容(重点):-- 关系型数据库中数据完整性指的是什么-- 1.实体完整性 : 每条记录都是独一无二的(主键/唯一约束/唯一索引)-- 2.参照完整性 : 表中的数据要参照其他表已有的数据(外键)-- 3.域完整性 : 数据是有效的(数据类型/非空约束/默认值约束/检查约束) 12345678910111213141516-- 表的设计原则 : 范式理论(1NF / 2NF / 3NF / BCNF)-- 范式级别指的是表设计的规范程度,范式级别越高规范程度也就越高-- 范式级别越高在插入/删除/更新数据时可能发生的问题就越少-- 而且表中的数据冗余度(重复)也就越低-- 实际开发中往往会降低范式级别来提升查询数据的性能-- 1NF - 列的属性值不能够再拆分(一列一值)-- 2NF - 除了主键列之外的列要完全依赖于主键-- 场景: 不同学院的学生可能有相同的学号-- 学生表(stuid, sname, ssex, did, dname , dtel)-- 主键(stuid, did)-- sname 和 ssex依赖于stuid, 而dname和dtel依赖于did-- 这种依赖是部分依赖而不是完全依赖所以不满足2NF-- 3NF - 消除传递依赖-- 场景: 整个学校学生的学号是惟一的-- 学生表(stuid, sname, ssex, did, dname , dtel)-- 主键(stuid) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149DCL :-- 创建用户并指定登录口令create user hellokitty identified by &apos;123123&apos;;-- 授予权限和召回权限grant all on shcool.tb_student to hellokitty;revoke all on shcool.tb_student from hellokitty;grant select all on shcool.tb_student to hellokitty;grant all on school.* to hellokitty;grant all on *.* to &apos;hellokitty&apos;@&apos;%&apos;;revoke all on *.* from hellokitty;-- 删除用户drop user hellokitty;---------------------------------------------------查询(重点)查学生表所有行所有列select * from tb_student查课程所有表所有列select * from tb_course-- 笛卡尔积select * from tb_student, tb_course;-- 投影和别名: 查询所有课程名称及学分select sname as 姓名, ssex as 性别 from tb_student;select sname as 姓名, case ssex when 1 then &apos;男&apos; else &apos;女&apos; end as 性别 from tb_student;select sname as 姓名, if(ssex, &apos;男&apos;, &apos;女&apos;) as 性别 from tb_student;-- 筛选: 查询所有女学生的姓名和出生日期-- = / &lt;&gt; / &gt; / &lt; / &gt;= / &lt;= / is null / is not null select sname, sbirth from tb_student where ssex=0;select courseid, cname from tb_course where ccredit&gt;2;-- 范围筛选: 查询所有80后学生的姓名、性别和出生日期select sanme, ssex, sbirth from tb_studentwhere &apos;1980-1-1&apos;&lt;=sbirth and sbirth&lt;=&apos;1989-12-31&apos;;select sanme, ssex, sbirth from tb_studentwhere sbirth between &apos;1980-1-1&apos; and &apos;1989-12-31&apos;;-- 模糊查询: 查询姓王的学生姓名和性别select * from tb_student where sanme=&apos;杨过&apos;;select * from tb_student where sanme like&apos;杨%&apos;;通配符(widcard)% (通配符)代表0个或多个任意字符-- 模糊查询: 查询姓杨名字总共两个字的学生的姓名select * from tb_student where sanme like&apos;杨_&apos;;-- 模糊查询: 查询姓杨名字总共三个字的学生的姓名select * from tb_student where sanme like &apos;杨__&apos;;-- 模糊查询: 查询名字中有杨字的学生的姓名(模糊)select * from tb_student where sanme like &apos;%杨%&apos;;-- 多条件和空值处理: 查询没有录入生日和家庭住址的学生姓名-- 在判断一个列是否为null的时候不能用=或&lt;&gt;而要使用is或者is notselect * from tb_student where sbirth is null or saddr is null;-- 去重(distint): 查询学生的籍贯select distinct saddr from tb_student where saddr is not null;-- 排序: 查询学生的姓名和生日按年龄从大到小排列select * from tb_student order by ssex asc(升序), sbirth desc(降序);有删选条件排序时先删选再排序select * from tb_student order by ssex asc, sbirth desc;-- 筛选和排序: 查询所有录入了家庭住址的男学生的姓名、出生日期和家庭住址按年龄从小到大排列select sname, sbirth, saddr from tb_studentwhere saddr is not null and ssex=1order by sbirth desc;-- 聚合函数: 查询年龄最大的学生的出生日期-- MySQL特有函数: now() / if()-- 最常用五个聚合函数:-- max() / min() / sum() / avg()-平均 / count() - 计数select min(sbirth) from tb_student;select max(sbirth) from tb_student;-- 分组查询: 查询男女学生的人数select count(stuid) from tb_student;select count(stuid) from tb_student where ssex=1;-- 经验 : 在使用group by 分组时如果不希望执行默认的排序操作-- 可以在分组后使用order by null 来避免默认的排序操作提升查询性能select if(ssex, &apos;男&apos;, &apos;女&apos;) as 性别, count(*) as 人数from tb_student group by ssex;order by - 排序 / group by - 分组查询asc (升序 - 从小到大) / desc(降序 - 从大到小)先筛选 - 再分组 - 再排序 (重点) - 否则会导致语法错误select if(ssex, &apos;男&apos;, &apos;女&apos;) as 性别, count(*) as 人数from tb_student where saddr is not nullgroup by ssexorder by ssex desc;-- 聚合函数: 查询课程编号为1111的课程的平均成绩-- 聚合函数会自动排除空值,不会纳入计算select cid, avg(score) from tb_scwhere cid=1111;-- where 子句构造的筛选是分组以前的筛选-- 如果希望对分组以后的数据进行筛选那么要写having子句而不是where子句select cid, avg(score) from tb_scgroup by cid having avg(score) &lt; 80;-- 聚合函数: 查询学号为1001的学生所有课程的平均成绩select sid, avg(score) from tb_scwhere sid=1001;-- 子查询: 查询年龄最大的学生的姓名(在查询里嵌套别的查询) -- 重点select sname, sbirth from tb_studentwhere sbirth=(select min(sbirth) from tb_student);去掉更多记录的条件放到右边 - SQL语句 (优化)-------------------------------------------------------- 连接查询 : 注意 : 给表别名不写as / 给列别名写as要点 : 从里往外写 - 先写子查询 - -- 自然连接select sname, cname, scorefrom tb_sc, tb_student, tb_coursewhere sid=stuid and cid=courseid;-- 连接查询: 查询选课学生的姓名和平均成绩select sname, avgScore from tb_student t1,(select sid, avg(score) as avgScore from tb_scgroup by sid) t2where stuid=sid;-- 连接查询: 查询学生姓名、所选课程名称和成绩select sname, total from tb_student t1,(select sid, count(sid) as total from tb_scgroup by sid) t2where stuid=sid;如果表里的列有同名.可以加一个前缀来别名加以区分-- 左外连接 : 左表(写在前面的表)不满足连表条件的记录也要查询出来select sname, if(total, total, 0) from tb_student t1left outer join(select sid, count(sid) as total from tb_scgroup by sid) t2on stuid=sid或者 - 两种方法结果是一样的select sname, ifnull(total, 0) from tb_student t1left outer join(select sid, count(sid) as total from tb_scgroup by sid) t2on stuid=sidinner join --- 内连接 --- 数据库特定写法 ------ 分页查询 select sname, cname, score from tb_scinner join tb_student on sid=stuidinner join tb_course on cid=courseid以下三种写法:-- limit 5;-- limit 0, 5;limit 5 offset 10;先筛选 - 分页 - 排序 - 分组 领域特定语言 - 不完备 - 只能做某个领域特定的事情图灵语言 - 完备 - Pythonlow_p - 低优先级重点:-- 经验: 尽可能不使用distinct去重和in集合运算-- SQL优化-- 想去掉distinct和in运算可以使用exists(查询结果是否存在)和not exists操作相应场景下 去重 / 集合 用下面方法操作:select ename, job from tbemp t1where exists(select &apos;x&apos; from tbemp t2 where t1.empno=t2.mgr);x 为 任意值python程序中操作数据库 --- 预习 12建表建库脚本保存 :没有备份前千万别删数据库 - 备份 - 新建备份 - 保存到桌面 - 删除数据库后 - 可以还原数据库 - 123456789101112131415161718192021222324252627282930了解有印象 索引 . 视图 . 过程 -- 索引相当于是一个目录,他可以加速查询提升查询效率-- 索引是典型的用空间换时间的技术-- 索引会加速查询但是会让增删改变得更慢, 因为增删改数据时索引也要更新创建索引(有了索引就有了目录) - 空间换时间 - 加快查询速度 - 但是增删改就变慢了 - 用于用户经常用哪个字段字段查询(例如商品搜索建索引是建在商品的名字上) : create index idx_emp_ename on TbEmp (ename);删除索引 : drop index index_emp_ename;检查索引 : show index from TbEmp-- 视图 : 保存某个查询的查询结果-- 通过视图可以将用户对表的查询权限限制在某些列上-- 也就是说不同的用户可以看你到原始表的不同列的数据创建视图 : create or replace view v_gfs as (创建或者替换一个叫v_gfs的视图, 如果存在v_gfs视图就替换, 如果不存在就创建一个)查视图 : select * from v_dept_total;-- 函数和过程 : 用来封装重复的操作-- 函数可以产生返回值而过程没有返回值的-- 函数和(存储)过程都是存储在数据库服务器端编译好的二进制程序-- 所以直接调用函数和过程其执行效率比直接向数据库发出SQL语句更高-- 如果希望简化调用并改善性能就可以考虑使用存储过程-- 创建存储过程 create procedure ...in : 输入参数 / out : 输出参数-- 调用存储过程 call -- 性能好 --- 安全性好 --- 使用调用上更简单(优化数据库就调存储过程)定义变量一定要@开头定义变量名call sp_dept_avg_sal(20, @avgSal);select @avgSal-- 创建触发器 - 对数据表进行增删改时就会触发事件(实际开发中避免使用 - 使用后会导致SQL性能急剧下降)-- 测试触发器","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"PyCharm的基本快捷键","slug":"PyCharm的快捷键","date":"2018-05-15T04:22:22.000Z","updated":"2018-05-26T05:06:50.205Z","comments":true,"path":"2018/05/15/PyCharm的快捷键/","link":"","permalink":"http://yoursite.com/2018/05/15/PyCharm的快捷键/","excerpt":"","text":"Windows下Python IDE PyCharm的基本快捷键 1、编辑（Editing) Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 Shift + F1 外部文档 Ctrl + 鼠标 简介 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行 Ctrl + Y 删除选定的行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开折叠代码块 Ctrl + Numpad+ 全部展开 Ctrl + Numpad- 全部折叠 Ctrl + F4 关闭运行的选项卡 2、查找/替换(Search/Replace) F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + F 全局查找 Ctrl + Shift + R 全局替换 3、运行(Running) Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 4、调试(Debugging) F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 5、导航(Navigation) Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡 F12 回到先前的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏运行的、最近运行的窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 当前文件弹出 Ctrl+Alt+Left/Right 后退、前进 Ctrl+Shift+Backspace 导航到最近编辑区域 Alt + F1 查找当前文件或标识 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I查看快速定义 Ctrl + Shift + B跳转到类型声明 Ctrl + U跳转到父方法、父类 Alt + Up/Down跳转到上一个、下一个方法 Ctrl + ]/[跳转到代码块结束、开始 Ctrl + F12弹出文件结构 Ctrl + H类型层次结构 Ctrl + Shift + H方法层次结构 Ctrl + Alt + H调用层次结构 F2 / Shift + F2下一条、前一条高亮的错误 F4 / Ctrl + Enter编辑资源、查看资源 Alt + Home显示导航条F11书签开关 Ctrl + Shift + F11书签助记开关 Ctrl + #[0-9]跳转到标识的书签 Shift + F11显示书签 6、搜索相关(Usage Search) Alt + F7/Ctrl + F7文件中查询用法 Ctrl + Shift + F7文件中用法高亮显示 Ctrl + Alt + F7显示用法 7、重构(Refactoring) F5复制F6剪切 Alt + Delete安全删除 Shift + F6重命名 Ctrl + F6更改签名 Ctrl + Alt + N内联 Ctrl + Alt + M提取方法 Ctrl + Alt + V提取属性 Ctrl + Alt + F提取字段 Ctrl + Alt + C提取常量 Ctrl + Alt + P提取参数 8、控制VCS/Local History Ctrl + K提交项目 Ctrl + T更新项目 Alt + Shift + C查看最近的变化 Alt + BackQuote(‘)VCS快速弹出 9、模版(Live Templates) Ctrl + Alt + J当前行使用模版 Ctrl +Ｊ插入模版 10、基本(General) Alt + #[0-9]打开相应的工具窗口 Ctrl + Alt + Y同步 Ctrl + Shift + F12最大化编辑开关 Alt + Shift + F添加到最喜欢 Alt + Shift + I根据配置检查当前文件 Ctrl + BackQuote(‘)快速切换当前计划 Ctrl + Alt + S 打开设置页 Ctrl + Shift + A查找编辑器里所有的动作 Ctrl + Tab在窗口间进行切换","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"数据库MySQL","slug":"数据库MySQL","date":"2018-05-14T01:03:01.000Z","updated":"2018-05-26T08:45:13.933Z","comments":true,"path":"2018/05/14/数据库MySQL/","link":"","permalink":"http://yoursite.com/2018/05/14/数据库MySQL/","excerpt":"","text":"数据库MySQL11.Windows系统数据库的安装 - MySQL severs - 5.7全选 - 开发机 - 端口设定默认3306 - next - finish 122.启动服务器 : 1.我的电脑 - 右键管理员 - 服务和应用程序 - 服务 - MySQL2.命令行提示符 - 管理员身份运行 - net start / stop mysql57(启 / 停) 12345678MySQL5.7 Command Line Client - Unicode1. 任务菜单栏 - 双击打开 MySQL5.7 Command Line Client - Unicodepassword - 输入自己设定的MySQL密码show databases; - 查看所有数据库select version(); - 查看服务器版本? - 帮助quit - 退出2 . 命令行提示符 - mysql -u root -p (需要配置环境变量) 关系型数据库1234一 . 为什么要使用数据库?数据持久化 - 将数据从一掉电数据就丢失的存储介质(内存)转移到持久存储介质(硬盘)普通文件 / 二进制文件 / Excel / 数据库数据库 - 高效的存储和管理数据方便的检索数据 123456789二 . 什么是关系型数据库?关系型数据库特点 :1.理论基础 - 集合论和关系代数2.(最大.直观的特点) - 用二维表组织数据表 - 实体(一张表就是一个实体)行 - 记录列 - 字段表与表之间有关系编程语言 - SQL - 结构化查询语言(重点) 1234567891011三 . 数据库 . 数据库系统 . 数据库管理系统 ?数据库 - Database - DB - 数据的仓库(集散地)数据库系统 - DBS - 包括了DB . DBMS . DBA(数据库管理员)(R)DBMS - (关系型)数据库管理系统 - 管理数据库的软件关系型数据库产品: - MySQL - 小巧但是强大 - Oracle - 安全强大 商业智能分析 (银行 .金融 . 电商) 昂贵 - DB2 - 安全强大 商业智能 (银行 .金融 . 电商) 昂贵 - SQL Server (几乎用不到) - SQLite - 嵌入式数据库(移动端) 123456四 . 怎么使用MySQL ?数据库服务器和客户端工具MySQL客户端工具:- SQLyog- Toad for MySQL- Navicat for MySQL Navicat for MySQL的使用 :123456789101112131415161718192021222324252627282930313233343536373839404142Navicat for MySQL 的使用链接 - 输入相应内容与密码 - 连接数据库 - SQL(Structured Query Language) - 关系型数据库的编程语言- DDL(数据定义语言): create(创建) / drop(删除) / alter(修改)- DML(数据操纵语言): insert(嵌入) / delete(删除) / update(更新)- DQL(数据查询语言): select(挑选)- DCL(数据控制语言): grant(允许) / revoke(撤回) / begin(开始) / commit(提交) / rollback(反转)实际操作中:假如指定数据库名称为school1.如果指定的数据库存在则删除该数据库drop database if exists school(指定数据库名称);2.创建数据库并指定默认的字符集create database school default charset utf8;3.切换到school数据库use school4.删除学生表drop table if exists tb_student;-- 主键(primary key) - 能够标识唯一一条记录的列-- varchar 不定长字符串的最大长度 / var 定长字符串的长度 / default 默认值-- comment 注释语句 后面的字符串要加单引号5.创建学生表create table tb_student(stuid int not null comment &apos;学号&apos;,sname varchar(10) not null comment &apos;姓名&apos;,ssex bit default 1 comment &apos;性别&apos;, stel char(11) comment &apos;联系电话&apos;, sbirth date comment &apos;出生日期&apos;,primary key (stuid) );6.修改学生表alter table tb_student add column saddr varchar(100); -- 添加列alter table tb_student drop column stel; -- 删除列7.插入学生记录insert into tb_student values (1001, &apos;王大锤&apos;, 1, &apos;1990-2-12&apos;, &apos;四川成都&apos;);insert into tb_student (stuid, sname) values (1002, &apos;骆昊&apos;);insert into tb_student (stuid, sname, ssex) values (1003, &apos;李飘飘&apos;, 0);insert into tb_student values(1004, &apos;张三丰&apos;, 1, &apos;1940-12-3&apos;, &apos;湖北武汉&apos;),(1005, &apos;黄蓉&apos;, 0, &apos;1975-3-25&apos;, &apos;山东东营&apos;),(1006, &apos;杨过&apos;, 1, &apos;1987-1-19&apos;, &apos;湖南长沙&apos;);","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Linux","slug":"Linux命令操作","date":"2018-05-12T01:36:23.000Z","updated":"2018-05-26T08:50:13.422Z","comments":true,"path":"2018/05/12/Linux命令操作/","link":"","permalink":"http://yoursite.com/2018/05/12/Linux命令操作/","excerpt":"","text":"Liunx12时间和空间是不可调和的矛盾硬件和软件在逻辑上是等效的 基础命令12345678910111213141516171819202122232425261. 获取登录信息 -- w/who/last(查看登录历史记录)2. 查看自己使用的Shell -- ps ps -aux | grep nginx 查看进程 3. 查看命令的说明 -- whatis [root@ping ~]# whatis python 4. 查看命令的位置 -- which / whereis5. 查看帮助文档 -- man / info / apropos / help man 关键字 查看帮助文档 help -m 关键字 显示较详细的使用方法6. 切换用户命令 -- su7. 以管理员身份执行命令 -- sudo8. 登入登出相关 -- logout / exit / adduser / userdel / passwd / ssh ssh root @47.106.99.221 远程访问服务器 9. 查看系统的主机名 - uname / hostname [root@ping ~]# cat /etc/centos-release 查看服务器版本号 CentOS release 6.8 (Final) 10. 重启和关机 -- reboot / init 6 / shutdown / init 0 文件操作1. 查看/切换目录 — pwd / cd / ls1234567891011121314pwd -- print working directory 打印当前工作目录 cd -- 切换路径 ./ 当前路径 ../ 上一级路径 /home/gavinliu/ /开头 绝对路径 ../../ 相对路径 cd / 根目录 ls -- list directory contents 查看目录内容 ls -l 查看目录详情 ls -a 查看所有目录详情(显示影藏文件(.开头的文件/文件夹)) ls -R 递归展开目录 ls -r 倒序展开 2. 创建/删除目录 — mkdir / rmdir123mkdir -- make directory 创建文件目录rmdir -- remove directory 移除文件目录(只能删除空文件夹) 3. 创建/删除文件 — touch / rm12345678rm -- remove 删除文件/文件夹 rm -r 递归删除 rm -i 交互式 rm -f false touch 文件名 文件不存在 --&gt; 创建空文件 文件存在 --&gt; 更新文件最后的访问和修改时间 4. 查看/搜索文件内容 — cat / head / tail12345678cat -- 查看文件内容more -- 分页查看 more index.html / cat index.html | more(管道) ls -l | grep hello 查看带hello的文件 head -- 查看文件开头部分 head -10 index.html(查看文件前10行)tail -- 查看文件末尾部分 tail -10 index.html(查看文件最后10行) 5. 查看文件及内容 — find / grep123456find -- 搜索文件 --&gt; 显示文件 目录/文件grep -- 搜索文件内容 grep div index.html / cat index.html | grep div (匹配div) grep '&lt;div .*&gt;' index.html -n(搜索&lt;div&gt;,并给出行号) grep '&lt;div .*&gt;' index.html / -R -n &gt; result.txt 2&gt; error.txt &amp; 6. 拷贝移动文件 — cp / mv1234567cp -- 拷贝文件 cp file pathscp -- 拷贝文件到服务器 scp hello.txt root@119.27.166.245:~/abc/ mv -- 移动文件 格式: mv file path 移动文件夹 格式: mv dir path 重命名 格式: mv hello.py helloworld.py 7. 符号链接 — ln123ln -- link链接 ln 创建硬链接(文件引用) ln index.html ~/abc/index1.html ln -s file softlink 创建软连接(快捷方式) ln -s /etc/centos-release sysver 8. 压缩 / 归档 — gzip / gunzip / xz / tar123456789101112131415.xz .gz 压缩文件gunzip -- 解压缩 gunzip redis-3.2.11.tar.gz --&gt; redis-3.2.11.targzip -- 压缩 gzip dog.jpg --&gt; dog.jpg.gz xz -- 压缩/解缩压 xz -d 解压缩 xz -z -num(压缩比) 压缩 xz -z dog.jpg --&gt; dog.jpg.xz tar -- 归档/解归档 tar -cf file 归档(静默处理) tar -cvf redis-3.2.11.tar tar -xf file 解归档(静默处理) tar -xvf redis-3.2.11.tar tar -tf file 查看归档文件内容 tar -tf redis-3.2.11.tar 9. 其他工具12345678910111213141516171819wget -- 在网上下载文件 wget http://www.taobao.com/index.html wget -O 文件重命名wc -- word count 数单词数/行数 wc -w 单词 wc -w index.html wc -l 行数 wc -l index.html uniq -- 去重(相邻行)sort -- 排序(不改变原文件)diff -- 版本比较(文件)file -- 分析文件性质(根据文件内容区分) file hello.txt --&gt; hello.txt: UTF-8 Unicode text echo -- 回声命令 echo $PATH 查看变量的值 echo \"print('hello')\" &gt; hello.py 创建文件并向里面添加内容 10. 文件权限12345678910111213所有者u 同组用户g 其他用户orwx r-x r-xrwx rwx rwx111 111 1117 7 7111 7110 6100 4r read 读w write 写x excute 执行chmod u+x,g+x,o+x guess1.py 给所有者添加权限chmod 777 guess1.py 给所有者添加权限 管道和重定向123456789101. 管道 -- | ls -l | grep hello 查看带hello的文件 2. 重定向 -- &gt; &gt; 输出重定向 2&gt; 存放错误文件(覆盖) &gt;&gt; 追加输出重定向 &lt; 输入重定向 &amp; 在后台执行 其他程序123456789wall -- 向所有人发消息mssg n/y -- 拒绝/同意接收消息alias -- 命令重命名 --&gt; unalias alias foo='tar -xf' history -- 查询所有执行过的命令 !num -- 执行命令 liunx目录1234567/ 根目录下面文件夹 root -- 用户主目录(超级管理员) home -- 用户主目录(其他管理员) ect -- 存储linux系统配置/软件配置 usr -- B -- Byte 字节b -- bit 位 包管理工具 — 安装软件yum12345678yum - yellowdog updater modified 包管理工具 yun install / yum remove 安装 / 卸载 yun list / yum search 查看 / 搜索 yum list installed 显示所有已安装软件 yum install nginx 安装nginx yum nginx search 搜索软件 yum install mariadb-server mariadb 安装数据库服务器 数据库客户端 yum update 更新 rpm12345RPM - redhat package manager 红帽子的包管理工具 rpm -i 静默安装 / -ivh 显示安装过程 rpm -e 移除 rpm -qa 显示所有已安装的包 rpm -qa | grep jdk | xargs rpm -e 删除管道过滤出来的jdk (xargs 将xargs前面的结果作为后面命令的参数使用) 源码安装123456tar.gz / tar.xz ungizp / xz -d 解压缩 tar -xvf 解归档 配置PATH环境变量 临时 export ... 永久 vim .bash_profile --&gt; 添加环境变量 nginx12nginx 启动nginxnginx -s stop | quit | reopen | reload redis12345678910111213141516redis.conf 61 -- bind 172.27.0.11 内网地址 84 -- port 6379 默认端口 480 -- requirepass liutc1014? 删除注释,修改密码 redis-server 服务器 redis-server myredis.conf 启动redis服务器 redis-server myredis.conf &gt; myredis.log &amp; 后台运行 关闭服务器 jobs --&gt; fg %1 --&gt; ^c 关闭redis服务器(自动保存) kill 进程号 关闭redis服务器 不保存 redis-cli 客户端redis-cli -h 172.27.0.11(内网地址) -p 端口号(默认端口可以省略) 连接服务器 auth liutc1014? 验证 ping 查看是否连接 查看进程 / 任务123456789jobs -- 查看有无后台任务在执行fg %1 将后台任务放到前台执行^z 将放到前台执行的任务放到后台并停止执行bg %1 将放到前台执行的任务放到后台执行ps -aux 查看已启动进程 ps -aux | grep ngnix netstat -nap 查看进程号 netstat -nap | grep 80(端口号) systemctl — 服务管理工具12345678910111213141. systemctl --&gt; CentOS7 启动一个服务：systemctl start firewalld.service 关闭一个服务：systemctl stop firewalld.service 重启一个服务：systemctl restart firewalld.service 显示一个服务的状态：systemctl status firewalld.service 在开机时启用一个服务：systemctl enable firewalld.service 在开机时禁用一个服务：systemctl disable firewalld.service 查看服务是否开机启动：systemctl is-enabled firewalld.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed1. service -- (CentOS 7 以前) service firewall start service firewall status 查看状态 CentOS 7打开关闭防火墙端口123456789101112131415161718192021221. firewalld的基本使用 启动： systemctl start firewalld 查看状态： systemctl status firewalld 停止： systemctl disable firewalld 禁用： systemctl stop firewalld 2. 配置firewalld-cmd 查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd --zone=public --list-ports 更新防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 3. 配置端口 添加 firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效） 重新载入 firewall-cmd --reload 查看 firewall-cmd --zone= public --query-port=80/tcp 删除 firewall-cmd --zone= public --remove-port=80/tcp --permanent mac终端与服务器下上传下载内容1234sftp root@IP 链接服务器put 上传文件get 下载文件bye 退出 1234DNS - 域名翻译成IP地址HTTP服务器 - LAMP = Linux + Apache + MysQL + PHP LNMP = Linux + Nginx +MySQL + Pythg","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}