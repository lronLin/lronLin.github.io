{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"lronLin","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2018-05-26T03:20:51.000Z","updated":"2018-05-26T05:25:49.927Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于Django的基本操作","slug":"分类","date":"2018-05-26T03:22:22.000Z","updated":"2018-05-26T03:23:48.528Z","comments":true,"path":"2018/05/26/分类/","link":"","permalink":"http://yoursite.com/2018/05/26/分类/","excerpt":"","text":"windows环境下使用Django $ mkdir 文件夹名 #创建项目目录 $ cd 文件夹名 #进入项目目录 在项目目录: $ python -m venv hello_django_venv #创建虚拟环境并命名(hello为文件名) $ cd hello_django_venv #进入虚拟环境 $ cd Script #进入Scripts $ activate #激活环境 在虚拟环境的script目录下: deactivate #退出虚拟环境 pip install django #在虚拟环境下安装django依赖库 pip install django==指定版本号 #安装指定版本的django django-admin –version #查看安装的django版本 在虚拟环境的项目目录下: django-admin startproject hello_django #创建名为hello的项目 cd hello_django #切换到项目目录 python manage.py runserver #启动django服务器 python manage.py startapp hrs #创建一个名为hrs的应用 linux下使用Django mkdir hello_django #创建项目目录 cd hello_django/ #切换到项目目录 进入目录之后: python3 -m venv hd_venv #使用venv模块创建虚拟环境，目录名hd_venv source hd_venv/bin/activate #激活虚拟环境 在虚拟环境bin目录下: python -m pip install –upgrade pip #更新pip到最新版本 pip install django #使用pip安装django django-admin –version #通过安装django时安装的脚本工具django-admin检查django版本 在虚拟环境的项目目录下: django-admin startproject 项目名 #创建项目 python manage.py startapp 应用名 #创建应用名 python manage.py runserver (0.0.0.0:80) #启动django服务器,可以指定端口号","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"你好 世界 !","slug":"hello-world","date":"2018-05-25T09:01:15.146Z","updated":"2018-05-26T03:18:47.765Z","comments":true,"path":"2018/05/25/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Python基础","slug":"Python基础","date":"2018-05-17T10:32:19.000Z","updated":"2018-05-26T05:18:43.342Z","comments":true,"path":"2018/05/17/Python基础/","link":"","permalink":"http://yoursite.com/2018/05/17/Python基础/","excerpt":"","text":"Python基础 数据类型数字型(Number) 字符型(String) 布尔型(boolean) 空类型(None) 列表型(list) 元组型(tuple) 字典型(dict) 集合型(set) 标准数据类型Python3 中有六个标准的数据类型： 1Number（数字） ​ String（字符串） 1List（列表） ​ Tuple（元组）​ Dictionary（字典） 1Sets（集合） 变量对变量类型进行转换时可以使用Python的内置函数 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 Number（数字）整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）复数(complex) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 数学函数函数 返回值 ( 描述 )abs(x) 返回数字的绝对值，如abs(-10) 返回 10ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃 。使用 使用 (x&gt;y)- (x&lt;y) 替换。 exp(x) 返回e的x次幂(ex), 如math.exp(1) 返回2.718281828459045fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。pow(x, y) x**y 运算后的值。round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。sqrt(x) 返回数字x的平方根。 String（字符串）字符串常用内建函数 str1 = ‘’hello, world!’ str1.split( ) 通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 len() len函数计算字符串的长度 len(str1) # 13 str1.capitalize() 获得字符串首字母大写的拷贝 str1.capitalize() # Hello, world! str1.upper() 获得字符串变大写后的拷贝 str1.upper() # HELLO, WORLD! str1.find(str2, beg=0 end=len(string)) 检测 str2 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 12345678&gt;&gt;&gt;str1 = 'abca'&gt;&gt;&gt; print(str1.find('a')) # 从下标0开始，查找在字符串里第一个出现的子串，返回结果：00&gt;&gt;&gt; print(str1.find('a', 1)) # 从下标1开始，查找在字符串里第一个出现的子串：返回结果33&gt;&gt;&gt; print(str1.find('3')) # 查找不到返回-1-1&gt;&gt;&gt; index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常. str1.startswith(str2) 检查字符串是否以指定的字符串开头 12print(str1.startswith('He')) # Falseprint(str1.startswith('hel')) # True str1.endswith(str2) 检查字符串是否以指定的字符串结尾 1print(str1.endswith('!')) # True str1.center(width, &#39;=&#39;) 将字符串以指定的宽度居中并在两侧填充指定的字符 1print(str1.center(20, '=')) #===hello, world!==== rjust ljust 右对齐/左对齐 str1.rjust(width, &#39; &#39;) 将字符串以指定的宽度靠右放置左侧填充指定的字符 str1.isdigit() 检查字符串是否只由数字构成 ,返回 True 或 False str1.isalpha() 检查字符串是否只由字母构成 ,返回 True 或 False str1.isalnum() 检查字符串是否以数字和字母构成 ,返回 True 或 False str1.strip() 获得字符串修剪左右两侧空格的拷贝 12str1 = ' jackf1234@166.com 'print(str1.strip()) # jackf1234@166.com List（列表）list1 = [1, 3, 5, 7, 100] len(list1) 列表元素个数 max(list1) 返回列表元素最大值 min(list1) 返回列表元素最小值 list(对象) 将对象转换为列表 , 对象:字符串,元组,集合; 字典只能把键转成列表 list1.append(元素) 在列表末尾添加新的元素list1.insert(下标, 元素) 在指定下标出添加一个元素,原来位置处的元素往后移动 list1.pop() 将列表中指定下标的元素删除, 如果默认不传递参数,则删除的是最后一个元素 list1.remove() 移除列表中指定的元素 list1.clear() 清除列表中所有的元素 list1.reverse() 用于反向列表中元素 等同于[::-1] reversed(seq) 函数返回一个反转的迭代器。 seq – 要转换的序列，可以是 tuple, string, list 或 range list1.sort() 应用在 list 上的方法, 返回的是对已经存在的列表进行操作 12345list1 = [4, 1, 45, 21, 2, 7]# print(list1.sort()) 打印为None,没有返回值,只对原来列表排序list2 = list1.sort()print(list2) #结果还是为None print(list1) #[1, 2, 4, 7, 21, 45] 123456# 0 1 2 3 4 5 6 7 8a = [1, 2, 3, 4, 5, 6, 7, 8, 9]b = a[7:3:-1]print(b) #[8, 7, 6, 5]print(a[1:3:-1]) #Noneprint(a[3:1:-1]) #[4, 3] Tuple（元组）元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 len(tuple) 计算元组元素个数。 max(tuple) 返回元组中元素最大值。 min(tuple) 返回元组中元素最小值。 tuple(seq) 将列表转换为元组。 Dictionary（字典）无序集合, key唯一,必须是不可变类型访问获取方式: ​ dict[key] ​ dict.get(key) 添加元素: ​ dict[key] = value # key为原字典中不存在的键 修改: ​ dict[key] = balue # key为原字典中存在的键 dict.keys() 以列表返回字典中所有的键dict.values() 以列表返回字典中所有的值dict.items() 以列表返回可遍历的(键, 值) 元组数组 [(键, 值), (键, 值), (键, 值)]dict.setdefault() 返回指定键的值,如果键不存在于字典中，将会添加键并将值设为默认值dict.pop([key]) 删除指定键值对, 需传入参数 # 没有remove()方法enumerate()用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 字典内置函数dict1 = {‘name’:’shuaixiaohao’, ‘age’:22, ‘weight’:60} len(dict) 计算字典元素个数，即键的总数。 print(len(dict1)) # 3 str(dict) 输出字典，以可打印的字符串表示。 print(str(dict1)) #{‘name’: ‘shuaixiaohao’, ‘age’: 22, ‘weight’: 60}print(type(str(dict1))) # type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 字典内置函数radiansdict.clear()删除字典内所有元素radiansdict.copy()返回一个字典的浅复制radiansdict.fromkeys()创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值radiansdict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值key in dict如果键在字典dict里返回true，否则返回falseradiansdict.items()以列表返回可遍历的(键, 值) 元组数组radiansdict.keys()以列表返回一个字典所有的键radiansdict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为defaultradiansdict.update(dict2)把字典dict2的键/值对更新到dict里radiansdict.values()以列表返回字典中的所有值pop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。popitem()随机返回并删除字典中的一对键和值(一般删除末尾对)。 Sets（集合）set是无序,没有重复元素set集合是不可改变的创建一个空的集合 set1 = set(()); set1 = set([]); set1 = set({}) 注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典set.add(): 增加一个元素(重复元素不能添加) # 没有append()方法set.remove():删除元素, 参数是元素set.pop():删除最后一个元素set1 &amp; set2 交集set1 | set2 并集set1 - set2 差集set1 ^ set2 交并集 12dict--&gt;set 取字典的键, 传入集合set --&gt; dict(错误) # 不能将集合转换成字典, 只有键, 没有值 三元条件运算python中: 1value1 if condition else value2 JavaScript中: conditon ? valuel1 : value2 问号前面的条件如果成立 123function getStyle(elem) &#123; return window.getComputedStyle ? window.getComputedStyle(elem): elem.currentStyle;&#125; 迭代器与生成器迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 字符串，列表或元组对象都可用于创建迭代器 生成器 yield 函数被称为生成器（generator）, 生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器 , 每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。 函数匿名函数python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 1lambda [arg1 [,arg2,.....argn]]:expression #arg-参数 ,expression-表达式 变量作用域变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的 L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域 global 和 nonlocal关键字 当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了 1234567import randomrandom.choice():返回列表,元祖,字典中的某一个值random.choices():返回列表,元祖,字典中的指定个数值个值 k 关键字参数random.random():返回0-1之间的数, [0, 1) random.uniform():返回指定的一个区间范围的随机数 [, )random.randint():返回指定区间范围的随机整数 [, ]random.shuffle():将列表中的数据进行打乱排序 123451. 不定长参数: *args2. 关键字参数: **kw3. 偏函数: 导入模块 import functools functools.partical()就是创建一个新的函数.不需要自行定义函数.直接将结果赋值给一个变量,而 这个变量就是一个函数.这个函数的目的是将默认参数给固定住4. 回调函数: 定义函数时,将函数名作为参数传递过来,然后在函数里边再次调用函数 偏函数正则表达式 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 \\ 匹配字符串的结束\\ .exe\\ 匹配字符串的结束\\ .exe 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?\\exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.ba.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 re模块中的核心函数 1234re.match(pattern, string, flags=0)pattern 匹配的正则表达式string 要匹配的字符串flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 面向对象面向对象的三个基本特征是：封装、继承、多态 封装： ​ 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 隐藏复杂的现实细节，暴露简单的调用接口。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。 保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==&gt;数据封装。 方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==&gt;方法封装。 当对象含有完整的属性和与之对应的方法时称为封装。 从对象外面不能直接访问对象的属性，只能通过和该属性对应的方法访问。 对象的方法可以接收对象外面的消息。 继承： ​ 从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)。继承主要实现重用代码，节省开发时间。 在类名后边的括号里一般写的是基类的类名 子类中继承自父类(基类),则父类的成员属性和成员方法都可以被子类所继承 父类中私有的成员属性不能继承给子类的 多态： “一个接口，多种方法” ​ 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 多态的三个条件: 继承的存在(继承是多态的基础,没有继承就没有多态) 子类重写父类的方法(多态下调用子类重写的方法) 父类引用变量指向子类对象(子类到父类的类型转换) 数据抽象一找到和对象相关的数据一属性( 名词） 行为抽象一 找到和对象相关的行为一方法（动词） __slots__ ​ 限定自定义类型的对象只能绑定某些属性，可以通过在类中定义_slots\\_变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 123class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') 魔法方法区分开函数和方法的含义： 1.函数：类外部定义的，跟类没有直接关系的；形式： def func(*argv): 2.方法：class内部定义的函数（对象的方法也可以认为是属性）；分为两种： ① python自动产生的（魔法方法）：一般形式为 __func__()，python会在对应的时机自动调用该函数； ② 人为自定义的方法：一般和普通函数没有区别，只是定义在了class中而已 3.方法与函数的区别： 方法可认为是函数的特殊情况； ① 方法定义在class内部 ② 方法的第一个参数应为 cls(类方法) 或者 self(实例方法) 列出几个基本魔法方法： __new__(cls[,*argv]) __new__ 是在一个对象实例化的时候所调用的第一个方法 它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法 _new__ 决定是否要使用该 \\_init__方法，因为 __new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__ 没有返回实例对象，则 __init__ 不会被调用 __new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string __init__(self,[…]) 类的初始化方法 ，当一个实例对象被定义时调用 *__del__(self)** 析构器，当一个实例被析构时调用 _new__ 和 \\_init__ 是对象的构造器， __del__ 是对象的销毁器 Python内置装饰器在Python中有三个内置的装饰器，都是跟class相关的：staticmethod、classmethod 和property。 staticmethod 是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用 classmethod 与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型） property 是属性的意思，表示可以通过通过类实例直接访问的信息 类方法、静方法 都是通过给类发消息来调用的 实例方法 发给对象的消息 在类创建对象后，实例方法才能被使用，使用格式为：对象名.实例方法 ​ 名。实例方法可以使用该方法所在类的所有静态成员和实例成员。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from abc import abstractmethod, ABCMeta# 面向对象的三大支柱 - 封装 / 继承 / 多态# 封装 - 隐藏复杂的实现细节 暴露简单的调用接口# 继承 - 从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)# 多态 - 见下面# 在创建类时通过指定metaclass=ABCMeta可以将一个类声明为抽象类# 所谓抽象类就是不能创建对象的类 它存在价值是留给它的子类去继承# 经验: 我们强烈建议将用来继承的类声明为抽象类class Employee(object, metaclass=ABCMeta): def __init__(self, name): self._name = name @property def name(self): return self._name[:-1] + '*' # 被abstractmethod包装器修饰的方法是抽象方法 # 所谓抽象方法就是没有实现专门留给子类去重写的方法 # 如果子类没有重写这个抽象方法 那么子类相当于也是抽象类 不能创建对象 @abstractmethod def get_salary(self): passclass Manager(Employee): def get_salary(self): return 12000class Programmer(Employee): def __init__(self, name): super().__init__(name) self._working_hour = 0 @property def working_hour(self): return self._working_hour @working_hour.setter def working_hour(self, working_hour): self._working_hour = working_hour if working_hour &gt; 0 else 0 def get_salary(self): return 150 * self._working_hourclass Salesman(Employee): def __init__(self, name): super().__init__(name) self._sales = 0 @property def sales(self): return self._sales @sales.setter def sales(self, sales): self._sales = sales def get_salary(self): return 1500 + self._sales * 0.05def main(): emp_list = [Manager('王大锤'), Programmer('骆昊'), Programmer('李大嘴'), Salesman('白元芳')] for emp in emp_list: if isinstance(emp, Programmer): #判断一个对象是否是一个已知的类型 hour = int(input('请输入%s本月工作时间: ' % emp.name)) emp.working_hour = hour elif isinstance(emp, Salesman): sales = float(input('请输入%s本月销售额: ' % emp.name)) emp.sales = sales # 多态 - 给同样的对象发送同样的消息(同样的引用调用同样的方法)做了不同的事情 # 实现多态最关键的就是子类对父类已有方法进行重写 不同的子类给出不同的实现版本 print('%s月薪为￥%.2f元' % (emp.name, emp.get_salary()))if __name__ == '__main__': main() 异常处理123456789try: print('try...') r = 10 / 0 print('result:', r)except ZeroDivisionError as e: print('except:', e)finally: print('finally...')print('END') try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。 无论有没有异常finally语句被执行。 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如: 12except (RuntimeError, TypeError, NameError): pass ​ try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行 ​ 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。 1异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。 文件读、写文件1open(filename, mode) mode：决定了打开文件的模式：只读，写入，追加等 操作模式 具体含义 1234567**&apos;r&apos;** 读取 （默认）**&apos;w&apos;** 写入（会先截断之前的内容）**&apos;x&apos;** 写入，如果文件已经存在会产生异常**&apos;a&apos;** 追加，将内容写入到已有文件的末尾**&apos;b&apos;** 二进制模式**&apos;t&apos;** 文本模式（默认）**&apos;+&apos;** 更新（既可以读又可以写） with语句来自动帮我们调用close()方法 （关闭文件） with 语句就可以保证文件之类的对象在使用完之后一定会正确的执行他的清理方法 1with open(\"myfile.txt\") as f: 文件对象的方法fileObject.read([size]) ​ 从文件读取指定的字节数，如果未给定或为负则读取所有。 fileObject.write() ​ 写文件 # 如果要写入字符串以外的数据,先将他转换为字符串 fileObject.close() ​ 关闭文件 fileObject.readline([size]) ​ 读取整行内容,包括\\n字符, 如果给定参数则从文件开始读取指定的字符个数 fileObject.readlines([sizeint]) ​ 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 f.tell() ​ 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数). f.seek(偏移量,[起始位置]) ​ 用来移动文件指针 #偏移量:单位:比特,可正可负起始位置:0-文件头,默认值;1-当前位置;2-文件尾 操作文件和目录os模块:在这个模块中给我们封装好了系统操作的功能函数(方法) import os os.getcwd() 返回当前的工作目录 # 获取绝对路径 os.listdir(path) 返回指定的文件夹包含的文件或文件夹的名字的列表 os.mkdir(path) 在当前目录下创建新的目录 os.rmdir(path) 删除目录, 只能删除空目录 os.rename(src, dst) 对文件进行重命名 os.stat(file) 获取文件属性 os.remove(file) 删除文件 #可以将本文件删除 os.path.join(path1, path2) 路径拼接 os.path.split(path) 拆分路径 # 返回一个元组(目录, 最后一个文件/目录名称) os.path.splitext(path) 获取文件的或站名 os.path.exists(path) 判断文件/目录是否存在 os.path.isfile(path) 判断是否是文件 os.path.getsize(file) 获取文件的大小 os.path.dirname(path) 获取当前文件的目录 os.path.basename(path) 获取当前文件/目录名 StringIO很多时候，数据读写不一定是文件，也可以在内存中读写 StringIO模块主要用于在内存缓冲区中读写数据。模块是用类编写的，只有一个StringIO类， # 所以它的可用方法都在类中。此类中的大部分函数都与对文件的操作方法类似。 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue())hello world! getvalue()方法用于获得写入后的str。 BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 进程和线程进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位 线程：是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源 一个程序至少有一个进程,一个进程至少有一个线程。线程是最小的执行单元，而进程由至少一个线程组成。 多进程​ Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 fork()是os模块里的函数。 ​ 子进程永远返回 0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 Windows没有 fork调用，multiprocessing模块就是跨平台版本的多进程模块。 multiprocessing模块提供了一个Process类来代表一个进程对象 1234567891011121314from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__=='__main__': print('Parent process %s.' % os.getpid()) #getpid()取得进程识别码 p = Process(target=run_proc, args=('test',)) #创建一个Process实例 print('Child process will start.') p.start() #启动子进程 p.join() #等待子进程结束后再继续往下运行 print('Child process end.') 执行结果如下： 1234Parent process 928.Process will start.Run child process test (929)...Process end. 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用 start()方法启动。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步 Pool如果要启动大量的子进程，可以用进程池的方式批量创建子进程： 多线程Python的标准库提供了两个模块：_thread 和 threading，_thread 是低级模块，threading 是高级模块，对 _thread 进行了封装。绝大多数情况下，我们只需要使用 threading 这个高级模块。 启动一个线程就是把一个函数传入并创建 Thread 实例，然后调用 start() 开始执行 网络编程协议- protocol- 通信双方对话的规范和标准 IP.Internet Protocol- 寻址和路由www.baidu.com---&gt; 180.97.33.108 TCP和UDP是在IP协议之上构建的传输协议它们能够提供传输数据的服务TCP提供了可靠传输服务TCP- Transfer Control Protocol握手机制+冗余校验—&gt; 重发一次 TCP.Transfer Control Protocol I1.可靠通信[数据不传丢也不传错]滑动窗口机制2.流量控制(自动调节发送数据的速度3.拥塞控制(网络拥堵时会降低发送速度) QQ 微信.应用级QQ— ICQ— OICQHTTP— Hyper-Text Transfer ProtocolHTTPS— SecureSMTP– Simple Mail Transfer ProtocolPOP3— Post Office Protocol version 3IMAP—Internet Mail Access Protocolxerox— macintosh— Windows URL— Uniform Resource Locator协议://域名或IP地址:80/路径/资源名 网络API(应用程序编程接口) / 网络 123456789requests.get()用于请求目标网站，类型是一个HTTPresponse类型import requestsresponse = requests.get('http://www.baidu.com')print(response.status_code) # 打印状态码print(response.url) # 打印请求urlprint(response.headers) # 打印头信息print(response.cookies) # 打印cookie信息print(response.text) #以文本形式打印网页源码print(response.content) #以字节流形式打印 TCP编程Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 服务器12345678910111213141516171819202122232425262728293031323334353637#创建服务器发文件from io import SEEK_ENDfrom socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimefrom time import sleepdef main(): # 1.创建套接字对象并指定使用哪种传输服务 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(区分不同的服务) server.bind(('10.7.152.130', 9090)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: data = f.read() f.seek(0, SEEK_END)#设置文件读取指针在文件当前位置 file_len = f.tell()#返回文件当前位置指针 # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) while True: # accept方法是一个阻塞方法 如果没有客户端连接到服务器这个方法就会阻塞代码不会向下执行 client, addr = server.accept() # 5.发送数据 client.send('guido.jpg'.encode('utf-8')) client.send(str(file_len).encode('utf-8')) total = 0 while total &lt; file_len: client.send(data[total:total+1024]) total += 1024 sleep(0.001) # 6.断开连接 client.close()if __name__ == '__main__': main() 客户端12345678910111213141516171819202122from socket import socketdef main(): # 创建一个socket client = socket() # 建立连接: client.connect(('10.7.152.130', 9090)) filename = client.recv(1024).decode('utf-8') print(filename) file_len = int(client.recv(1024).decode('utf-8')) print(file_len) with open('C:/Users/Administrator/Desktop/' + filename,'wb') as f: total = 0 while total &lt; file_len: date = client.recv(1024) f.write(date) total += 1024 print('图片已保存')if __name__ == '__main__': main()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"PyCharm的基本快捷键","slug":"PyCharm的快捷键","date":"2018-05-15T04:22:22.000Z","updated":"2018-05-26T05:06:50.205Z","comments":true,"path":"2018/05/15/PyCharm的快捷键/","link":"","permalink":"http://yoursite.com/2018/05/15/PyCharm的快捷键/","excerpt":"","text":"Windows下Python IDE PyCharm的基本快捷键 1、编辑（Editing) Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 Shift + F1 外部文档 Ctrl + 鼠标 简介 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行 Ctrl + Y 删除选定的行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开折叠代码块 Ctrl + Numpad+ 全部展开 Ctrl + Numpad- 全部折叠 Ctrl + F4 关闭运行的选项卡 2、查找/替换(Search/Replace) F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + F 全局查找 Ctrl + Shift + R 全局替换 3、运行(Running) Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 4、调试(Debugging) F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 5、导航(Navigation) Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡 F12 回到先前的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏运行的、最近运行的窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 当前文件弹出 Ctrl+Alt+Left/Right 后退、前进 Ctrl+Shift+Backspace 导航到最近编辑区域 Alt + F1 查找当前文件或标识 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I查看快速定义 Ctrl + Shift + B跳转到类型声明 Ctrl + U跳转到父方法、父类 Alt + Up/Down跳转到上一个、下一个方法 Ctrl + ]/[跳转到代码块结束、开始 Ctrl + F12弹出文件结构 Ctrl + H类型层次结构 Ctrl + Shift + H方法层次结构 Ctrl + Alt + H调用层次结构 F2 / Shift + F2下一条、前一条高亮的错误 F4 / Ctrl + Enter编辑资源、查看资源 Alt + Home显示导航条F11书签开关 Ctrl + Shift + F11书签助记开关 Ctrl + #[0-9]跳转到标识的书签 Shift + F11显示书签 6、搜索相关(Usage Search) Alt + F7/Ctrl + F7文件中查询用法 Ctrl + Shift + F7文件中用法高亮显示 Ctrl + Alt + F7显示用法 7、重构(Refactoring) F5复制F6剪切 Alt + Delete安全删除 Shift + F6重命名 Ctrl + F6更改签名 Ctrl + Alt + N内联 Ctrl + Alt + M提取方法 Ctrl + Alt + V提取属性 Ctrl + Alt + F提取字段 Ctrl + Alt + C提取常量 Ctrl + Alt + P提取参数 8、控制VCS/Local History Ctrl + K提交项目 Ctrl + T更新项目 Alt + Shift + C查看最近的变化 Alt + BackQuote(‘)VCS快速弹出 9、模版(Live Templates) Ctrl + Alt + J当前行使用模版 Ctrl +Ｊ插入模版 10、基本(General) Alt + #[0-9]打开相应的工具窗口 Ctrl + Alt + Y同步 Ctrl + Shift + F12最大化编辑开关 Alt + Shift + F添加到最喜欢 Alt + Shift + I根据配置检查当前文件 Ctrl + BackQuote(‘)快速切换当前计划 Ctrl + Alt + S 打开设置页 Ctrl + Shift + A查找编辑器里所有的动作 Ctrl + Tab在窗口间进行切换","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]}]}