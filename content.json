{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"lronLin","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2018-05-26T03:20:51.000Z","updated":"2018-05-26T05:25:49.927Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Django","slug":"restful的使用","date":"2018-06-01T12:06:21.000Z","updated":"2018-06-01T12:06:24.617Z","comments":true,"path":"2018/06/01/restful的使用/","link":"","permalink":"http://yoursite.com/2018/06/01/restful的使用/","excerpt":"","text":"restful1.分页修改settings.py配置文件, 增加分页的配置信息 123456REST_FRAMEWORK = &#123; &apos;DEFAULT_PAGINATION_CLASS&apos;: &apos;rest_framework.pagination.PageNumberPagination&apos;, &apos;PAGE_SIZE&apos;: 2, &apos;DEFAULT_RENDERER_CLASSES&apos;: ( &apos;utils.functions.CustomJsonRenderer&apos;, ), 123456789101112131415161718&#123; &quot;code&quot;: 0, &quot;msg&quot;: &quot;请求成功&quot;, &quot;data&quot;: &#123; &quot;count&quot;: 1, &quot;next&quot;: null, &quot;previous&quot;: null, &quot;results&quot;: [ &#123; &quot;s_name&quot;: &quot;瑶瑶&quot;, &quot;s_yuwen&quot;: 88, &quot;g&quot;: 1, &quot;id&quot;: 3, &quot;g_name&quot;: &quot;python1&quot; &#125; ] &#125;&#125; 注意: 在结果在data对应的value值中, 有一个count的key, 表示返回数据有1条, next表示下一个的url, pervious表示上一页的url 2.过滤修改settings.py配置文件, 增加filter过滤的信息 2.1安装过滤的库1pip install django-filters 2.2配置settings.py的信息配置DEFAULT_FILTR_BANNCKENDS 123456789101112REST_FRAMEWORK = &#123; # 分页显示 &apos;DEFAULT_PAGINATION_CLASS&apos;: &apos;rest_framework.pagination.PageNumberPagination&apos;, &apos;PAGE_SIZE&apos;: 2, # 配置过滤 &apos;DEFAULT_FILTER_BACKENDS&apos;: ( &apos;rest_framework.filters.DjangoFilterBackend&apos;, &apos;rest_framework.filters.SearchFilter&apos;), &apos;DEFAULT_RENDERER_CLASSES&apos;: ( &apos;utils.functions.CustomJsonRenderer&apos;, ),&#125; 2.3views中指定filter_class12345678910111213class api_student(mixins.ListModelMixin, mixins.UpdateModelMixin, mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.DestroyModelMixin, viewsets.GenericViewSet): # 学生的所有信息 queryset = Student.objects.all().filter(delete=False) # 序列化学生的所有信息(表现层, 将数据按照一定格式返回给用户) serializer_class = StudentSerializer # 过滤 filter_class = StudentFilter 2.4编写filter_class过滤信息12345678910111213141516import django_filtersfrom rest_framework import filtersfrom app.models import Studentclass StudentFilter(filters.FilterSet): # 模糊查询学生的s_name姓名 s_name = django_filters.CharFilter(&apos;s_name&apos;, lookup_expr=&apos;contains&apos;) # 查询语文成绩大于80分的学生 s_yuwen = django_filters.NumberFilter(&apos;s_yuwen&apos;, lookup_expr=&apos;gte&apos;) s_yuwen_max = django_filters.NumberFilter(&apos;s_yuwen&apos;, lookup_expr=&apos;lte&apos;) class Meta: model = Student fields = [&apos;s_name&apos;, ] 2.5实现方法2.5.1查询学生的姓名中包含瑶的学生使用filter_class进行过滤筛选 : 1http://127.0.0.1:8080/stu/student/?name=瑶 不使用filter_class进行筛选: 123def get_queryset(self): query = self.queryset return query.filter(s_name__contaions=&apos;瑶&apos;) 2.5.2查询学生的创建时间在2018年5月1日到2018年6月1日的学生信息使用filter_class进行过滤筛选: 1http://127.0.0.1:8080/stu/student/?create_min=2018-05-01&amp;create_max=2018-06-01 不使用filter_class进行筛选: 1234def get_queryset(self): query = self.queryset return query.filter(s_create_time__gte=&apos;2018-05-01&apos;, s_create_time__lte=&apos;2018-06-01&apos;) 2.53查询状态为休学的学生信息1http://127.0.0.1:8080/stu/student/?status=LEAVE_SCH 2.5.4查询所有的学生, 按照id从大到小排序123def get_queryset(self): query = self.queryset return query.order_by(&apos;-id&apos;)","categories":[],"tags":[{"name":"restful的使用","slug":"restful的使用","permalink":"http://yoursite.com/tags/restful的使用/"}]},{"title":"Django","slug":"Django Rest 框架","date":"2018-05-31T09:17:23.000Z","updated":"2018-05-31T12:23:48.066Z","comments":true,"path":"2018/05/31/Django Rest 框架/","link":"","permalink":"http://yoursite.com/2018/05/31/Django Rest 框架/","excerpt":"","text":"Django rest 框架实例网: xyty.klicen.com 官方文档www.django-rest-framework.org REST是所有Web应应用都应该遵守的架构设计指导原则 Representational State Transfer - 翻译是 ‘表现层状态转化’ REST核心 : 资源 , 状态转移, 统一接口资源 : 是REST最明显的特征, 是指对某类信息实体的抽象, 资源是服务器上一个可命名的抽象概念的, 资源是以名词为核心来组织的, 首先关注的是名词 状态转移 :是指客户端与服务端进行交互的过程中, 客户端能够通过对资源的表述, 实现操作资源的目的 统一接口 :RSET要求, 必须通过统一的接口来对资源执行各种操作, 对于每个资源只能执行一组有限的操作, 比如, 客户端通过HTTP的4个请求方式(POST, GET, PUT, PATCH)来操作资源, 也就意味着, 不管你的url是什么, 不管请求的资源是什么但操作的资源接口都是统一的 GET用来获取资源 , POST用来新建资源(也可用于更新资源), PUT(PATCH)用来更新资源, DELETE用来删除资源 状态码服务端向用户返回请求api的结果, 在结果中包含了status code 状态码的, 可以通过状态码去判断请求api的状态是成功还是失败 123456789101112200 OK - [GET]: 服务器成功返回用户请求的数据, 该操作是幂等的(Idempotent)201 CREATED - [POST/PUT/PATCH]: 用户新建或修改数据成功202 Accepted - [*]: 表示一个请求已经进入后台排队(异步任务)204 NO CONTENT - [DELETE]: 用户删除数据成功400 INVALID REQUEST - [POST/PUT/PATCH]: 用户发出的请求有误, 服务器没有进行新建或修改数据的擦操作, 该操作是幂等的401 Unauthorized -[*]: 表示用户没有权限(令牌, 用户名, 密码错误)403 Forbidden - [*]: 表示用户得到授权(与401错误相对), 但是访问时被禁止的404 NOT FOUND -[*]: 用户发出的请求针对的是不存在的记录, 服务器没有进行操作, 该操作的幂等的406 Not Accepted - [GET]: 用户请求的格式不可得(比如用户请求JSON格式, 但只有XML格式)410 Gone -[GET]: 用户请求的资源被永久删除, 且不会再得到的422 Unprocesable entity - [POST/PUT/PATCH]: 当创建一个对象时, 发生一个验证错误500 INTERNAL SERVER ERROR - [*]: 服务器发生错误, 用户将无法判断发出的请求是否成功 rest 资源 , 统一接口 , 状态转移 1234567891011127.0.0.1:8080/app/student/ - (student为资源) : 获取所有的学生 GET127.0.0.1:8080/app/student/ : 创建的学生 POST127.0.0.1:8080/app/student/1/: 获取学生中id为1的那一个学生 GET 127.0.0.1:8080/app/student/1/ : POST \\ PUT \\ PATCH127.0.0.1:8080/app/student/1/ : DELETE127.0.0.1:8080/app/grade/ : 获取所有的班级 GET 2.http请求方式 123456789GET : 用于获取POST : 用于创建PUT : 用于修改, 全部属性都会修改PATCH : 用于修改, 部分属性进行修改DELETE : 删除 3.旧接口 123127.0.0.1:8080/app/student/?id=1127.0.0.1:8080/app/student/1/ - 符合restframe风格 接口文档 : 4.安装 , django中使用restful 12pip install djangorestframeworkpip install django_filter # Filtering support 添加内容到settings配置文件 1234567891011INSINSTALLED_APPS = ( ... &apos;rest_framework&apos;, )# settings最后添加下面内容REST_FRAMEWORK = &#123; &apos;DEFAULT_PAGINATION_CLASS&apos;: &apos;rest_framework.pagination.PageNumberPagination&apos;, &apos;PAGE_SIZE&apos;: 2,&#125; 添加urls.py文件中的内容 1234urlurlpatterns = [ ... url(r&apos;^api-auth/&apos;, include(&apos;rest_framework.urls&apos;))] 5.删除 请求url:http://127.0.0.1:8000/app/api/student/2/ 12345678910def destory(self, request, *args, **kwargs):instance = self.get_objects()self.perform_destory(instance)return Response(status=status.HTTP_204_NO_CONTENT)def perform_destory(self, instance): instance.delete() instance = self.get_object() 等价于 stu=Student.objects.get(id=2)instance.delete() 等价于 stu.delete() 6.to_representation中instance是当前循环学生的对象 7.rest的配置, 分页配置, 还有权限设置 1234567RESREST_FRAMEWORK = &#123; &apos;DEFAULT_PAGINATION_CLASS&apos;: &apos;rest_framework.pagination.PageNumberPagination&apos;, &apos;PAGE_SIZE&apos;: 2, &apos;DEFAULT_AUTHENTICATION_CLASSES&apos;:() &#125;&#125; 8.ajax 请求方式 1234567$.(url, function(msg)&#123; &#125;)$.post(url, function(msg)&#123; &#125;) 以上方式: url表示请求的地址, function(msg)代表, 请求成功后的回调函数, msg是api返回的结果 12345678910111213$.aj$.ajax(&#123; url:&apos;&apos;, # 请求的url地址 type:&apos;&apos;, # GET POST PATCH PUT DELETE data:&#123;&apos;name&apos;:name, &apos;sex&apos;:sex&#125;, # 代表请求的参数 dataType:&apos;json&apos;, headers:&#123;&apos;X-CSRFToken&apos;: csrf&#125; # 代表传递的csrf值 success:function(msg)&#123; 成功执行回调函数 &#125;, error:function(msg)&#123; 失败执行回调函数 &#125;&#125;); API接口 code : 状态码 前端VUE框","categories":[],"tags":[{"name":"rest","slug":"rest","permalink":"http://yoursite.com/tags/rest/"}]},{"title":"Django","slug":"Django装饰器","date":"2018-05-30T10:27:23.000Z","updated":"2018-05-31T12:34:00.970Z","comments":true,"path":"2018/05/30/Django装饰器/","link":"","permalink":"http://yoursite.com/2018/05/30/Django装饰器/","excerpt":"","text":"定义闭包(装饰器) 123def is_longin(func): def check_login(request): 如果登录, 返回函数func 123ticket = request.COOKIES.get(&apos;ticket&apos;) if not ticket: 如果没有登录, 跳转到登录页面 12345678910111213return HttpResponseRedirect(reverse(&apos;user:login&apos;)) user = Users.objects.filter(ticket=ticket) if not user: # 如果没有登录, 跳转到登录页面 return HttpResponseRedirect(reverse(&apos;user:login&apos;)) return func return check_login 2.模板 1234567891011在基础base.html中挖坑 &#123;% block xxx %&#125; &#123;% endblock %&#125;在index.html页面中, 需要先继承&#123;% extends &apos;base.html &apos;%&#125; &#123;% block xxx %&#125; &#123;% endblock %&#125;加载上一次填坑的内容 &#123;% block.super %&#125; 3.F/Q 12345678910111213141516171819202122last(): 最后一个first() : 第一个一对多: 多找一: student.g.g_name student.g.id 一找多: grade.student_set.all()一对一: student.g.g_name grade.student.all() F(): 用于做计算 1students.filters(s_yuwen__gt= F(&apos;s_shuxue&apos;) + 10) Q - 用于过滤信息 |或者 &amp;并且 ~取反 查询python班语文大于等于80或者数学小于等于80的学生 12345678910111213 grade = Grade.objects.filter(g_name=&apos;python&apos;).first() students = grade.student_set.all() stu = students.filter(Q(s_yuwengte=80) | Q(s_shuxue__lte=80))查询python班语文小于80并且数学小于等于80的学生 stu = students.filter(~Q(s_yuwengte=80) &amp; Q(s_shuxue__lte=80)) 4.模板 1234567891011121314151617ifforifequal : 判断是否相等forloop.counter : 循环, 从1开始forloop.revcounter : 倒循环, 倒1结束 forloop.counter0 : 循环, 从0开始forloop.revcounter0 : 倒循环, 倒0结束Ctrl shift + Delete ----删除浏览器缓存 创建班级的模型 12345class Grade(models.Model): g_name = models.CharField(max_length=20) g_create_time = models.DateTimeField(auto_now_add=True) 12class Meta: db_table = &apos;grade&apos; 创建学生的模型： 123456789101112131415161718192021class Student(models.Model): stu_name = models.CharField(max_length=6, unique=True) stu_sex = models.BooleanField(default=0) stu_birth = models.DateField() stu_delete = models.BooleanField(default=0) stu_create_time = models.DateField(auto_now_add=True) stu_operate_time = models.DateField(auto_now=True) stu_tel = models.CharField(max_length=11) stu_yuwen = models.DecimalField(max_digits=3, decimal_places=1, default=0) stu_shuxue = models.DecimalField(max_digits=3, decimal_places=1, default=0) g = models.ForeignKey(Grade) 12class Meta: db_table = &apos;stu&apos; 创建学生拓展的模型： class StuInfo(models.Model): 123456stu_addr = models.CharField(max_length=30)stu_age = models.IntegerField()stu = models.OneToOneField(Student)class Meta: db_table = &apos;stu_info&apos; 实际操作: 1234561.通过某个学生拓展表去获取学生信息2. 通过学生表获取个人拓展表的信息3. 获取python班下的所有学生的信息和拓展表的信息4. 获取python班下语文成绩大于80分的女学生5. 获取python班下语文成绩超过数学成绩10分的男学生6. 获取出生在80后的男学生，查看他们的班级","categories":[],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]},{"title":"关于Django的基本操作","slug":"Categories","date":"2018-05-26T03:22:22.000Z","updated":"2018-05-26T07:38:56.764Z","comments":true,"path":"2018/05/26/Categories/","link":"","permalink":"http://yoursite.com/2018/05/26/Categories/","excerpt":"","text":"windows环境下使用Django $ mkdir 文件夹名 #创建项目目录 $ cd 文件夹名 #进入项目目录 在项目目录: $ python -m venv hello_django_venv #创建虚拟环境并命名(hello为文件名) $ cd hello_django_venv #进入虚拟环境 $ cd Script #进入Scripts $ activate #激活环境 在虚拟环境的script目录下: deactivate #退出虚拟环境 pip install django #在虚拟环境下安装django依赖库 pip install django==指定版本号 #安装指定版本的django django-admin –version #查看安装的django版本 在虚拟环境的项目目录下: django-admin startproject hello_django #创建名为hello的项目 cd hello_django #切换到项目目录 python manage.py runserver #启动django服务器 python manage.py startapp hrs #创建一个名为hrs的应用 linux下使用Django mkdir hello_django #创建项目目录 cd hello_django/ #切换到项目目录 进入目录之后: python3 -m venv hd_venv #使用venv模块创建虚拟环境，目录名hd_venv source hd_venv/bin/activate #激活虚拟环境 在虚拟环境bin目录下: python -m pip install –upgrade pip #更新pip到最新版本 pip install django #使用pip安装django django-admin –version #通过安装django时安装的脚本工具django-admin检查django版本 在虚拟环境的项目目录下: django-admin startproject 项目名 #创建项目 python manage.py startapp 应用名 #创建应用名 python manage.py runserver (0.0.0.0:80) #启动django服务器,可以指定端口号","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"你好 世界 !","slug":"hello-world","date":"2018-05-25T09:01:15.146Z","updated":"2018-05-26T03:18:47.765Z","comments":true,"path":"2018/05/25/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Redis主从切换","slug":"Redis主从切换","date":"2018-05-24T12:53:58.000Z","updated":"2018-05-26T08:28:01.005Z","comments":true,"path":"2018/05/24/Redis主从切换/","link":"","permalink":"http://yoursite.com/2018/05/24/Redis主从切换/","excerpt":"","text":"公网IP:120.79.000.00 uname:查看操作系统 cat /ect/centos-release:查看操作系统版本 ps -ef (| grep &lt;进程名&gt;):查看进程,使用管道可以查询某个进程 top :查看进程,是进程的当前状态一次性快照属于动态查看,ps -ef 是进程过去状态的一次性快照,属于静态查看 netstat -nap:查看进程状态,例如listening ,connected等 ifconfig -a:查看ip地址 kill (-9) PID:关闭一个进程,-9显示最高级别的删除,强制终止,可能会导致数据丢失 adduser 用户名:创建一个非root的用户,权限较低 userdel 用户名:删除指定用户 passwd (用户名):为指定用户添加密码,若用户已有密码,则修改密码,如果不添加用户名,则默认修改当前用户密码 logout(exit):退出当前用户 su 用户名:切换用户 shutdown(init 0):关机 reboot(init 6):重启 man 指令:查看指令手册 info 指令:更为详细的解释指令 指令 –help:查看指令帮助 whatis 指令: 简短解释指令 whereis 指令(文件):从Linux的数据库中查询指定指令或者文件 find 文件:用于查询文件 pwd:查看当前所处目录 sudo 指令:使用管理员身份运行指令,普通用户使用该命令 mkdir 文件夹:创建一个空的文件夹 rmdie 文件夹:删除一个空的文件夹 touch 文件:创建一个文件 rm -rf 文件(文件夹):递归删除一个文件夹,也可以用户删除文件 ls -al:查看当前目录所有文件的长格式,包括隐藏文件 cd :改变目录 cat -n 文件:查看文件内容并显示行数 cat -n | more(less):一页一页的查看文件内容 head -num 文件:查看文件的开头几行 tail -num 文件:查看文件的末尾几行 cp 文件 文件路径/(文件名):将文件拷贝到文件夹中,同时可以对其重命名 mv 文件 文件:对文件进行重命名 mv 文件 文件路径/(文件名):将文件剪切到文件夹中,同时可以对其重命名 grep 搜索内容 文件 :在文件中搜索指定内容 cat 文件 | grep 内容:在文件中搜索指定内容并查看 ctrl c:终止正在前台运行的程序 ctrl z:将前台正在运行的程序拿到后台并停止运行 jobs:查看后台有无程序在执行 fg %num:将后台正在执行的任务拿到前台 bg %num:将后台停止运行的程序继续执行,一般配合ctrl z使用 wc 文件 (-l -w -c):计算文件中有多少行,多少字符,多少字节 diff 文件 文件:比较两个文件的差别 file 文件:查看文件性质 history:查看历史命令 last:查看登陆历史 echo:回声命令,其实功能很强大,暂时还没怎么研究 ssh + 用户名@IP地址:登陆到其他用户 ln 文件名 文件夹路径:在某个文件夹中为文件创建一个硬链接^1 ln -s 文件路径 /user/bin:为一个程序创建一个软链接 gunzip 压缩文件(后缀为gz):对一个文件进行解压缩 gzip 文件:将一个文件压缩成.gz后缀文件 xz -d 压缩文件(后缀为xz):对一个文件进行解压缩 xz -z 文件:将一个文件压缩成xz后缀文件 tar -xvf 归档文件:解归档 tar -cvf 文件名 文件,文件,…(*):将文件进行归档并对归档后的文件进行命名 tar -tf 归档文件:读取归档文件中的内容 wget url:下载指定网址内容 alias 新命令 ‘旧命令’:为一个命令重新进行命名 unalias 命令:取消重命名 chmod 755 文件:将文件的执行模式更改为当前用户可读可写可执行,其他用户或者组成员只能读和执行[^ 2] vim的命令模式[^3 ] vim的默行模式[^4] yum install 软件:安装开源软件 yum list installed:查看安装的所有软件 yum search 软件:搜索软件 yum update 软件:更新软件 rpm -ivh 软件:安装软件,可以查看安装过程 rpm -e 软件:删除软件 rpm -qa:查看所有安装的软件 rpm -qa | grep 软件:搜索安装的某个文件 rpm -qa |grep 软件 | xargs rpm -r :搜索软件并将其删除 nginx:启动nginx nginx -s stop:停止nginx,也可以使用kill 进程号来结束进程 systemctl start mariadb:启动MySQL,systemctl命令用于执行系统服务 systemctl stop mariadb:停止MySQL systemctl status mariadb:查看服务的运行状态 systemctl enable mariadb:开机自启MySQL systemctl disable mariadb:取消自启MySQL make &amp;&amp; make install:进行源代码安装 redis-server redis.conf :启动redis服务器 redis-cli -h ip:连接redis服务器 auth password:连接服务器后输入密码 pip3 install ipython:安装ipython ln -s /user/local/python3.6/bin/ipython3 /user/bin/ipython3:创建软链接 firewall-cmd –zone=public –list-ports:查看防火墙所有的打开端口 firewall-cmd –zone=public –add-port=80/tcp –permanent:永久打开防火墙80端口 firewall-cmd –zone=public –remove-port=80/tcp –permanent:永久删除防火墙80端口 启动redis服务器 配置redis.conf文件 bind &lt;内网地址&gt; port &lt;端口号&gt; requirepass &lt;服务器密码&gt; 启动redis服务器 redis-server redis.conf &amp; 启动redis客户端 redis-cli -h &lt;服务器地址&gt; -p &lt;服务器端口&gt; -a &lt;服务器密码&gt; 进去之后输入Info replication查看master,slaver信息 redis中主从切换在作为master的服务器中: 在redis.conf文件中写入masterauth &lt;master服务器密码&gt;[^5 ] 在sentinel.conf文件中进行哨兵的配置[^6 ] bind &lt;本服务器内网地址&gt; port &lt;哨兵端口号&gt; sentinel monitor mymaster &lt;master服务器地址&gt; &lt;master服务器端口号&gt; &lt; 投票数&gt;至少小于哨兵个数的一半) sentinel auth-pass mymaster &lt;master服务器密码&gt; sentinel down-after-milliseconds mymaster 5000:指定服务器已经断线所需的毫秒数,超时则主观下线 sentinel failover-timeout mymaster 18000:表示master超时期限,超时则客观下线 在作为salve的服务器中: 在redis.conf文件中写入slaveof &lt;master服务器外网地址&gt; &lt;master服务器端口号 &gt; 在redis.conf文件中写入 masterauth &lt;master服务器密码&gt; [^ 2]: 同时可以使用chmod u+w+r+x,g+w+r+x,o+w+r+x 文件来更改执行模式[^3 ]: dd:删除整行 dw:删除光标所在的单词 g:回到内容的第一行 G:回到内容的最后一行 pg+down:向下翻页 pg+up:向上翻页[^4]: /:搜索关键词,可以使用正则表达式来进行匹配,但是量词前面需要加上/,例如/+,/.,1,%s/…/…/g:全局替换 ! 命令:可以在vim模式下使用外部命令,并且会切换到外部进行执行[^5 ]: 该master很有可能在将来成为slave,所有要在配置文件输入以后可能成为master的服务器密码,其实我感觉应该是所有的redis服务器都使用同一个密码,不然谁知道谁成为master.[^6 ]: 哨兵在master和slave服务器都可以进行配置","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"非关系型数据库","slug":"非关系型数据库Redis","date":"2018-05-18T01:05:13.000Z","updated":"2018-05-26T08:19:06.575Z","comments":true,"path":"2018/05/18/非关系型数据库Redis/","link":"","permalink":"http://yoursite.com/2018/05/18/非关系型数据库Redis/","excerpt":"","text":"非关系型数据库Redis1988 提出了NoSQL (非关系型数据库的补充) 2008/2010 — Big Data(大数据) NoSQL = No SQL NoSQL = No Only SQL 关系型数据库(锁) - 数据价值高强一致性 NoSQL产品: 四大类非关系型数据库 : — Redis - 高速缓存(内存比硬盘快, 内存比硬盘小) - 键值对数据库 — MongoDB - 存放结构不严谨价值不高的数据 - 文档数据库 — Neo4j - 社交网站 - 图数据库 — HBase - 列族数据库 查看是否安装redis1cd user/local/bin - ll | grep redis - cd ~ - 配置文件 - ls - cp - vim -61行 - :!ifconfig - 内网地址复制 - enter - i进入编辑模式 - 粘贴到61行 - 84行改端口 改成11223(0到2的10次方-1) - 命令模式480行/requirepass 1qaz2wsx - 命令模式 database可以改库数量 启服务器1234567891011121314151617181920212223启服务: redis-server myredis.conf &amp; - 杀进程kill 5021 (会显示关机过程, 数据显示已保存) - 查看后台进程jobs - 前台运行 fg %2 - ctrl+c - redis benchmark -h 120.77.222.217 -p 11223 -a 1qaz2wsx查看是否成功ps -ef | grep redis 查进程redis-cli -h 120.77.222.217 -p 11223 -- set username admin - keys*(看到所有键) / keys u*(查看u打头的键) / keys [u,p]*(查看u,p打头的键) - set foo hello ex 300 - get foo - get bar - ttl foo(查看存活时间) - expire username 15(15秒后过期) - ttl username - get username - ttl username - ttl email save (保存) / bgsave(后台保存)select 1(切换到2号库)set foo bar - get foo - select 0 - get fooselect 15 - flushdb - keys* - select 0 - keys* - flushall(清理底层所有库)dbsizeinfo - 查看服务器相关信息shutdown save - 关闭服务器并保存数据 / shutdown no save - 关闭服务器不保存数据set - 放键值对del username - 删除数据select index - 切换到指定的数据库 开启防火墙时连接123456操作步骤 :1.systemctl start firewalld(开启防火墙)2.firewall-cmd --add-port=11223/tcp --permanent --zone=public(给防火墙开洞)3.firewall-cmd --reload(重新加载配置)4.redis-cli -h 120.79.135.242 -p 11223 (客服端连接服务器)5.auth 1qaz2wsx(输入密码)6.ping 回复PONG 就成功了(ping是否连接成功) 关闭防火墙时连接12345操作步骤 :1.systemctl stop firewalld2.redis-benchmark -h 120.79.135.242 -p 11223 -a 1qaz2wsx3.redis-cli -h 120.79.135.242 -p 11223 4.auth 1qaz2wsx5.ping 回复PONG 就成功了 五种数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970key(键) - 键都是字符串 String(字符串) : set foo 1set bar 1.23set username helloincr foo (网站投票, 网站页面首页缓存,SQL语句查询结果缓存)incr fooincrby foo 50 (网站投票) - redis中操作incrbyfloat bar 1.23 Strlen - 长度decr - 减少append user name - 键后面追加内容与set相似 JSON格式的字符串也可以-------------------------------------------Hash(哈希表) : 键值对存放数据 - 字典里面放字典hset student1 name &quot;Hao Luo&quot;hset student1 age 38hset student1 gender Malehget student1 namehget student1 genderhgetall student1 哈希表最适合放对象-------------------列子------------hset 10 dno 10hset 10 dname 财务部hset 10 dloc 重庆get 10hgetall 10三个字节utf-8hset 20 dno 20hset 20 dname 研发部hset 20 dloc 成都hgetall 20field - value 方式存在hdel 10 dloc - 删哈希表里的字段del key - 删键hexists ... - 判断是否有...hincrby - 增加------------------------List(列表) - push lpush foo 10 20 30 40lrange - 取指定范围元素-1 表示全部拿完元素lrange foo 0 -1 - 倒序rpush foo 10 20 30 40lrange foo 0 -1 - 顺序pop - 拿走元素nil - 空, 元素没有了lindex - 查看元素linsert - 插入元素lrem - 删除元素列表应用场景(微博,生产者-消费者模式 - 消息队列)------------------------------Set(集合) - 元素不能重复 - 去重sadd foo 10 10 20 10 20 30 sinter 求交集 foo barsunion 并集 foo barsddif 差集 foo barsremove - 删元素smembers - 删元素 fooscard foo -------------------------SortedSet(有序集合) : zadd foo 100 hell 75 good 102 world 300 apple根据设定的值排序zrange foo 0 -1 zrevrange foo 0 -1(自动排序) - 游戏排位zincrby foo 400 hello (加值) - 改变排位的值zincrange foo 0 -1 可以看到改变后排位的值type - 查看键的类型","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Python基础","slug":"Python基础","date":"2018-05-17T10:32:19.000Z","updated":"2018-05-26T05:18:43.342Z","comments":true,"path":"2018/05/17/Python基础/","link":"","permalink":"http://yoursite.com/2018/05/17/Python基础/","excerpt":"","text":"Python基础 数据类型数字型(Number) 字符型(String) 布尔型(boolean) 空类型(None) 列表型(list) 元组型(tuple) 字典型(dict) 集合型(set) 标准数据类型Python3 中有六个标准的数据类型： 1Number（数字） ​ String（字符串） 1List（列表） ​ Tuple（元组）​ Dictionary（字典） 1Sets（集合） 变量对变量类型进行转换时可以使用Python的内置函数 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 Number（数字）整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）复数(complex) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 数学函数函数 返回值 ( 描述 )abs(x) 返回数字的绝对值，如abs(-10) 返回 10ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃 。使用 使用 (x&gt;y)- (x&lt;y) 替换。 exp(x) 返回e的x次幂(ex), 如math.exp(1) 返回2.718281828459045fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。pow(x, y) x**y 运算后的值。round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。sqrt(x) 返回数字x的平方根。 String（字符串）字符串常用内建函数 str1 = ‘’hello, world!’ str1.split( ) 通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 len() len函数计算字符串的长度 len(str1) # 13 str1.capitalize() 获得字符串首字母大写的拷贝 str1.capitalize() # Hello, world! str1.upper() 获得字符串变大写后的拷贝 str1.upper() # HELLO, WORLD! str1.find(str2, beg=0 end=len(string)) 检测 str2 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 12345678&gt;&gt;&gt;str1 = 'abca'&gt;&gt;&gt; print(str1.find('a')) # 从下标0开始，查找在字符串里第一个出现的子串，返回结果：00&gt;&gt;&gt; print(str1.find('a', 1)) # 从下标1开始，查找在字符串里第一个出现的子串：返回结果33&gt;&gt;&gt; print(str1.find('3')) # 查找不到返回-1-1&gt;&gt;&gt; index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常. str1.startswith(str2) 检查字符串是否以指定的字符串开头 12print(str1.startswith('He')) # Falseprint(str1.startswith('hel')) # True str1.endswith(str2) 检查字符串是否以指定的字符串结尾 1print(str1.endswith('!')) # True str1.center(width, &#39;=&#39;) 将字符串以指定的宽度居中并在两侧填充指定的字符 1print(str1.center(20, '=')) #===hello, world!==== rjust ljust 右对齐/左对齐 str1.rjust(width, &#39; &#39;) 将字符串以指定的宽度靠右放置左侧填充指定的字符 str1.isdigit() 检查字符串是否只由数字构成 ,返回 True 或 False str1.isalpha() 检查字符串是否只由字母构成 ,返回 True 或 False str1.isalnum() 检查字符串是否以数字和字母构成 ,返回 True 或 False str1.strip() 获得字符串修剪左右两侧空格的拷贝 12str1 = ' jackf1234@166.com 'print(str1.strip()) # jackf1234@166.com List（列表）list1 = [1, 3, 5, 7, 100] len(list1) 列表元素个数 max(list1) 返回列表元素最大值 min(list1) 返回列表元素最小值 list(对象) 将对象转换为列表 , 对象:字符串,元组,集合; 字典只能把键转成列表 list1.append(元素) 在列表末尾添加新的元素list1.insert(下标, 元素) 在指定下标出添加一个元素,原来位置处的元素往后移动 list1.pop() 将列表中指定下标的元素删除, 如果默认不传递参数,则删除的是最后一个元素 list1.remove() 移除列表中指定的元素 list1.clear() 清除列表中所有的元素 list1.reverse() 用于反向列表中元素 等同于[::-1] reversed(seq) 函数返回一个反转的迭代器。 seq – 要转换的序列，可以是 tuple, string, list 或 range list1.sort() 应用在 list 上的方法, 返回的是对已经存在的列表进行操作 12345list1 = [4, 1, 45, 21, 2, 7]# print(list1.sort()) 打印为None,没有返回值,只对原来列表排序list2 = list1.sort()print(list2) #结果还是为None print(list1) #[1, 2, 4, 7, 21, 45] 123456# 0 1 2 3 4 5 6 7 8a = [1, 2, 3, 4, 5, 6, 7, 8, 9]b = a[7:3:-1]print(b) #[8, 7, 6, 5]print(a[1:3:-1]) #Noneprint(a[3:1:-1]) #[4, 3] Tuple（元组）元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 len(tuple) 计算元组元素个数。 max(tuple) 返回元组中元素最大值。 min(tuple) 返回元组中元素最小值。 tuple(seq) 将列表转换为元组。 Dictionary（字典）无序集合, key唯一,必须是不可变类型访问获取方式: ​ dict[key] ​ dict.get(key) 添加元素: ​ dict[key] = value # key为原字典中不存在的键 修改: ​ dict[key] = balue # key为原字典中存在的键 dict.keys() 以列表返回字典中所有的键dict.values() 以列表返回字典中所有的值dict.items() 以列表返回可遍历的(键, 值) 元组数组 [(键, 值), (键, 值), (键, 值)]dict.setdefault() 返回指定键的值,如果键不存在于字典中，将会添加键并将值设为默认值dict.pop([key]) 删除指定键值对, 需传入参数 # 没有remove()方法enumerate()用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 字典内置函数dict1 = {‘name’:’shuaixiaohao’, ‘age’:22, ‘weight’:60} len(dict) 计算字典元素个数，即键的总数。 print(len(dict1)) # 3 str(dict) 输出字典，以可打印的字符串表示。 print(str(dict1)) #{‘name’: ‘shuaixiaohao’, ‘age’: 22, ‘weight’: 60}print(type(str(dict1))) # type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 字典内置函数radiansdict.clear()删除字典内所有元素radiansdict.copy()返回一个字典的浅复制radiansdict.fromkeys()创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值radiansdict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值key in dict如果键在字典dict里返回true，否则返回falseradiansdict.items()以列表返回可遍历的(键, 值) 元组数组radiansdict.keys()以列表返回一个字典所有的键radiansdict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为defaultradiansdict.update(dict2)把字典dict2的键/值对更新到dict里radiansdict.values()以列表返回字典中的所有值pop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。popitem()随机返回并删除字典中的一对键和值(一般删除末尾对)。 Sets（集合）set是无序,没有重复元素set集合是不可改变的创建一个空的集合 set1 = set(()); set1 = set([]); set1 = set({}) 注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典set.add(): 增加一个元素(重复元素不能添加) # 没有append()方法set.remove():删除元素, 参数是元素set.pop():删除最后一个元素set1 &amp; set2 交集set1 | set2 并集set1 - set2 差集set1 ^ set2 交并集 12dict--&gt;set 取字典的键, 传入集合set --&gt; dict(错误) # 不能将集合转换成字典, 只有键, 没有值 三元条件运算python中: 1value1 if condition else value2 JavaScript中: conditon ? valuel1 : value2 问号前面的条件如果成立 123function getStyle(elem) &#123; return window.getComputedStyle ? window.getComputedStyle(elem): elem.currentStyle;&#125; 迭代器与生成器迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 字符串，列表或元组对象都可用于创建迭代器 生成器 yield 函数被称为生成器（generator）, 生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器 , 每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。 函数匿名函数python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 1lambda [arg1 [,arg2,.....argn]]:expression #arg-参数 ,expression-表达式 变量作用域变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的 L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域 global 和 nonlocal关键字 当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了 1234567import randomrandom.choice():返回列表,元祖,字典中的某一个值random.choices():返回列表,元祖,字典中的指定个数值个值 k 关键字参数random.random():返回0-1之间的数, [0, 1) random.uniform():返回指定的一个区间范围的随机数 [, )random.randint():返回指定区间范围的随机整数 [, ]random.shuffle():将列表中的数据进行打乱排序 123451. 不定长参数: *args2. 关键字参数: **kw3. 偏函数: 导入模块 import functools functools.partical()就是创建一个新的函数.不需要自行定义函数.直接将结果赋值给一个变量,而 这个变量就是一个函数.这个函数的目的是将默认参数给固定住4. 回调函数: 定义函数时,将函数名作为参数传递过来,然后在函数里边再次调用函数 偏函数正则表达式 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 \\ 匹配字符串的结束\\ .exe\\ 匹配字符串的结束\\ .exe 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?\\exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.ba.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 re模块中的核心函数 1234re.match(pattern, string, flags=0)pattern 匹配的正则表达式string 要匹配的字符串flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 面向对象面向对象的三个基本特征是：封装、继承、多态 封装： ​ 封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 隐藏复杂的现实细节，暴露简单的调用接口。 封装的意义： 封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。 保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==&gt;数据封装。 方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==&gt;方法封装。 当对象含有完整的属性和与之对应的方法时称为封装。 从对象外面不能直接访问对象的属性，只能通过和该属性对应的方法访问。 对象的方法可以接收对象外面的消息。 继承： ​ 从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)。继承主要实现重用代码，节省开发时间。 在类名后边的括号里一般写的是基类的类名 子类中继承自父类(基类),则父类的成员属性和成员方法都可以被子类所继承 父类中私有的成员属性不能继承给子类的 多态： “一个接口，多种方法” ​ 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 多态的三个条件: 继承的存在(继承是多态的基础,没有继承就没有多态) 子类重写父类的方法(多态下调用子类重写的方法) 父类引用变量指向子类对象(子类到父类的类型转换) 数据抽象一找到和对象相关的数据一属性( 名词） 行为抽象一 找到和对象相关的行为一方法（动词） __slots__ ​ 限定自定义类型的对象只能绑定某些属性，可以通过在类中定义_slots\\_变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 123class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') 魔法方法区分开函数和方法的含义： 1.函数：类外部定义的，跟类没有直接关系的；形式： def func(*argv): 2.方法：class内部定义的函数（对象的方法也可以认为是属性）；分为两种： ① python自动产生的（魔法方法）：一般形式为 __func__()，python会在对应的时机自动调用该函数； ② 人为自定义的方法：一般和普通函数没有区别，只是定义在了class中而已 3.方法与函数的区别： 方法可认为是函数的特殊情况； ① 方法定义在class内部 ② 方法的第一个参数应为 cls(类方法) 或者 self(实例方法) 列出几个基本魔法方法： __new__(cls[,*argv]) __new__ 是在一个对象实例化的时候所调用的第一个方法 它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法 _new__ 决定是否要使用该 \\_init__方法，因为 __new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__ 没有返回实例对象，则 __init__ 不会被调用 __new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string __init__(self,[…]) 类的初始化方法 ，当一个实例对象被定义时调用 *__del__(self)** 析构器，当一个实例被析构时调用 _new__ 和 \\_init__ 是对象的构造器， __del__ 是对象的销毁器 Python内置装饰器在Python中有三个内置的装饰器，都是跟class相关的：staticmethod、classmethod 和property。 staticmethod 是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用 classmethod 与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型） property 是属性的意思，表示可以通过通过类实例直接访问的信息 类方法、静方法 都是通过给类发消息来调用的 实例方法 发给对象的消息 在类创建对象后，实例方法才能被使用，使用格式为：对象名.实例方法 ​ 名。实例方法可以使用该方法所在类的所有静态成员和实例成员。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from abc import abstractmethod, ABCMeta# 面向对象的三大支柱 - 封装 / 继承 / 多态# 封装 - 隐藏复杂的实现细节 暴露简单的调用接口# 继承 - 从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)# 多态 - 见下面# 在创建类时通过指定metaclass=ABCMeta可以将一个类声明为抽象类# 所谓抽象类就是不能创建对象的类 它存在价值是留给它的子类去继承# 经验: 我们强烈建议将用来继承的类声明为抽象类class Employee(object, metaclass=ABCMeta): def __init__(self, name): self._name = name @property def name(self): return self._name[:-1] + '*' # 被abstractmethod包装器修饰的方法是抽象方法 # 所谓抽象方法就是没有实现专门留给子类去重写的方法 # 如果子类没有重写这个抽象方法 那么子类相当于也是抽象类 不能创建对象 @abstractmethod def get_salary(self): passclass Manager(Employee): def get_salary(self): return 12000class Programmer(Employee): def __init__(self, name): super().__init__(name) self._working_hour = 0 @property def working_hour(self): return self._working_hour @working_hour.setter def working_hour(self, working_hour): self._working_hour = working_hour if working_hour &gt; 0 else 0 def get_salary(self): return 150 * self._working_hourclass Salesman(Employee): def __init__(self, name): super().__init__(name) self._sales = 0 @property def sales(self): return self._sales @sales.setter def sales(self, sales): self._sales = sales def get_salary(self): return 1500 + self._sales * 0.05def main(): emp_list = [Manager('王大锤'), Programmer('骆昊'), Programmer('李大嘴'), Salesman('白元芳')] for emp in emp_list: if isinstance(emp, Programmer): #判断一个对象是否是一个已知的类型 hour = int(input('请输入%s本月工作时间: ' % emp.name)) emp.working_hour = hour elif isinstance(emp, Salesman): sales = float(input('请输入%s本月销售额: ' % emp.name)) emp.sales = sales # 多态 - 给同样的对象发送同样的消息(同样的引用调用同样的方法)做了不同的事情 # 实现多态最关键的就是子类对父类已有方法进行重写 不同的子类给出不同的实现版本 print('%s月薪为￥%.2f元' % (emp.name, emp.get_salary()))if __name__ == '__main__': main() 异常处理123456789try: print('try...') r = 10 / 0 print('result:', r)except ZeroDivisionError as e: print('except:', e)finally: print('finally...')print('END') try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。 无论有没有异常finally语句被执行。 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如: 12except (RuntimeError, TypeError, NameError): pass ​ try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行 ​ 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。 1异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。 文件读、写文件1open(filename, mode) mode：决定了打开文件的模式：只读，写入，追加等 操作模式 具体含义 1234567**&apos;r&apos;** 读取 （默认）**&apos;w&apos;** 写入（会先截断之前的内容）**&apos;x&apos;** 写入，如果文件已经存在会产生异常**&apos;a&apos;** 追加，将内容写入到已有文件的末尾**&apos;b&apos;** 二进制模式**&apos;t&apos;** 文本模式（默认）**&apos;+&apos;** 更新（既可以读又可以写） with语句来自动帮我们调用close()方法 （关闭文件） with 语句就可以保证文件之类的对象在使用完之后一定会正确的执行他的清理方法 1with open(\"myfile.txt\") as f: 文件对象的方法fileObject.read([size]) ​ 从文件读取指定的字节数，如果未给定或为负则读取所有。 fileObject.write() ​ 写文件 # 如果要写入字符串以外的数据,先将他转换为字符串 fileObject.close() ​ 关闭文件 fileObject.readline([size]) ​ 读取整行内容,包括\\n字符, 如果给定参数则从文件开始读取指定的字符个数 fileObject.readlines([sizeint]) ​ 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 f.tell() ​ 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数). f.seek(偏移量,[起始位置]) ​ 用来移动文件指针 #偏移量:单位:比特,可正可负起始位置:0-文件头,默认值;1-当前位置;2-文件尾 操作文件和目录os模块:在这个模块中给我们封装好了系统操作的功能函数(方法) import os os.getcwd() 返回当前的工作目录 # 获取绝对路径 os.listdir(path) 返回指定的文件夹包含的文件或文件夹的名字的列表 os.mkdir(path) 在当前目录下创建新的目录 os.rmdir(path) 删除目录, 只能删除空目录 os.rename(src, dst) 对文件进行重命名 os.stat(file) 获取文件属性 os.remove(file) 删除文件 #可以将本文件删除 os.path.join(path1, path2) 路径拼接 os.path.split(path) 拆分路径 # 返回一个元组(目录, 最后一个文件/目录名称) os.path.splitext(path) 获取文件的或站名 os.path.exists(path) 判断文件/目录是否存在 os.path.isfile(path) 判断是否是文件 os.path.getsize(file) 获取文件的大小 os.path.dirname(path) 获取当前文件的目录 os.path.basename(path) 获取当前文件/目录名 StringIO很多时候，数据读写不一定是文件，也可以在内存中读写 StringIO模块主要用于在内存缓冲区中读写数据。模块是用类编写的，只有一个StringIO类， # 所以它的可用方法都在类中。此类中的大部分函数都与对文件的操作方法类似。 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue())hello world! getvalue()方法用于获得写入后的str。 BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 进程和线程进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位 线程：是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源 一个程序至少有一个进程,一个进程至少有一个线程。线程是最小的执行单元，而进程由至少一个线程组成。 多进程​ Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 fork()是os模块里的函数。 ​ 子进程永远返回 0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 Windows没有 fork调用，multiprocessing模块就是跨平台版本的多进程模块。 multiprocessing模块提供了一个Process类来代表一个进程对象 1234567891011121314from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__=='__main__': print('Parent process %s.' % os.getpid()) #getpid()取得进程识别码 p = Process(target=run_proc, args=('test',)) #创建一个Process实例 print('Child process will start.') p.start() #启动子进程 p.join() #等待子进程结束后再继续往下运行 print('Child process end.') 执行结果如下： 1234Parent process 928.Process will start.Run child process test (929)...Process end. 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用 start()方法启动。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步 Pool如果要启动大量的子进程，可以用进程池的方式批量创建子进程： 多线程Python的标准库提供了两个模块：_thread 和 threading，_thread 是低级模块，threading 是高级模块，对 _thread 进行了封装。绝大多数情况下，我们只需要使用 threading 这个高级模块。 启动一个线程就是把一个函数传入并创建 Thread 实例，然后调用 start() 开始执行 网络编程协议- protocol- 通信双方对话的规范和标准 IP.Internet Protocol- 寻址和路由www.baidu.com---&gt; 180.97.33.108 TCP和UDP是在IP协议之上构建的传输协议它们能够提供传输数据的服务TCP提供了可靠传输服务TCP- Transfer Control Protocol握手机制+冗余校验—&gt; 重发一次 TCP.Transfer Control Protocol I1.可靠通信[数据不传丢也不传错]滑动窗口机制2.流量控制(自动调节发送数据的速度3.拥塞控制(网络拥堵时会降低发送速度) QQ 微信.应用级QQ— ICQ— OICQHTTP— Hyper-Text Transfer ProtocolHTTPS— SecureSMTP– Simple Mail Transfer ProtocolPOP3— Post Office Protocol version 3IMAP—Internet Mail Access Protocolxerox— macintosh— Windows URL— Uniform Resource Locator协议://域名或IP地址:80/路径/资源名 网络API(应用程序编程接口) / 网络 123456789requests.get()用于请求目标网站，类型是一个HTTPresponse类型import requestsresponse = requests.get('http://www.baidu.com')print(response.status_code) # 打印状态码print(response.url) # 打印请求urlprint(response.headers) # 打印头信息print(response.cookies) # 打印cookie信息print(response.text) #以文本形式打印网页源码print(response.content) #以字节流形式打印 TCP编程Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 服务器12345678910111213141516171819202122232425262728293031323334353637#创建服务器发文件from io import SEEK_ENDfrom socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimefrom time import sleepdef main(): # 1.创建套接字对象并指定使用哪种传输服务 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(区分不同的服务) server.bind(('10.7.152.130', 9090)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: data = f.read() f.seek(0, SEEK_END)#设置文件读取指针在文件当前位置 file_len = f.tell()#返回文件当前位置指针 # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) while True: # accept方法是一个阻塞方法 如果没有客户端连接到服务器这个方法就会阻塞代码不会向下执行 client, addr = server.accept() # 5.发送数据 client.send('guido.jpg'.encode('utf-8')) client.send(str(file_len).encode('utf-8')) total = 0 while total &lt; file_len: client.send(data[total:total+1024]) total += 1024 sleep(0.001) # 6.断开连接 client.close()if __name__ == '__main__': main() 客户端12345678910111213141516171819202122from socket import socketdef main(): # 创建一个socket client = socket() # 建立连接: client.connect(('10.7.152.130', 9090)) filename = client.recv(1024).decode('utf-8') print(filename) file_len = int(client.recv(1024).decode('utf-8')) print(file_len) with open('C:/Users/Administrator/Desktop/' + filename,'wb') as f: total = 0 while total &lt; file_len: date = client.recv(1024) f.write(date) total += 1024 print('图片已保存')if __name__ == '__main__': main()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Web前端","slug":"HTML","date":"2018-05-17T00:59:32.000Z","updated":"2018-05-26T07:53:04.801Z","comments":true,"path":"2018/05/17/HTML/","link":"","permalink":"http://yoursite.com/2018/05/17/HTML/","excerpt":"","text":"什么是HTML?HTML 是用来描述网页的一种语言。 Tag: Content 装内容装数据 CSS: Display 渲染,显示 JavaScript: Behavior 交互,行为 HTML 指的是超文本标记语言: Hyper Text Markup Language HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 文档包含了HTML 标签及文本 内容 HTML文档也叫做web 页面 HTML格式1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;主题title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 解析\\&lt;!DOCTYPE html&gt; 声明为 HTML5 文档 \\ 元素是 HTML 页面的根元素 \\ 元素包含了文档的元（meta）数据 \\ 元素描述了文档的标题 \\ 元素包含了可见的页面内容 \\ 元素定义一个大标题 \\ 元素定义一个段落 \\ 水平分割线 \\折行符 \\\\ 下标标签 \\\\ 上标标签 \\\\ 强调标签,变粗 \\\\ 强调标签,斜体 列表无序列表12345&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;芒果&lt;/li&gt;&lt;/ul&gt; 浏览器显示: 苹果 草莓 芒果 有序列表12345&lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;芒果&lt;/li&gt;&lt;/ol&gt; 浏览器显示: 苹果 草莓 芒果 自定义列表\\ 标签定义一个描述列表。 \\ 标签与 \\ （定义项目/名字）和 \\ （描述每一个项目/名字）一起使用。 123456&lt;dl&gt; &lt;dt&gt;星期&lt;/dt&gt; &lt;dd&gt;1 2 3 4 5 6 7&lt;/dd&gt; &lt;dt&gt;月份&lt;/dt&gt; &lt;dd&gt;1 2 3 4 5 6 7 8 9 10 11 12&lt;/dd&gt; &lt;/dl&gt; 浏览器显示: 星期​ 1 2 3 4 5 6 7月份​ 1 2 3 4 5 6 7 8 9 10 11 12 链接1&lt;a href=\"url\"&gt;链接文本&lt;/a&gt; href属性描述了链接的目标。 页面链接\\ 12345当前页面跳转,target=\"_self\"可以不写&lt;a href=\"http://www.baidu.com\" target=\"_self\"&gt;百度&lt;/a&gt;&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;打开新页面跳转&lt;a href=\"http://www.qq.com\" target=\"_blank\"&gt;腾讯&lt;/a&gt; 锚点链接(id属性)\\ id属性可用于创建在一个HTML文档书签标记。 id=”tips” tips-提示部分,自己定义 123&lt;h1 id=\"top\"&gt;Hello,word!&lt;/h1&gt;&lt;a href=\"#top\"&gt;回顶部&lt;/a&gt; 功能性链接1234自动弹出发邮箱功能&lt;a href=\"mailto:fenghao1994@163.com\"&gt;联系站长&lt;/a&gt;发起消息会话,wp.qq.com网站自动生成&lt;a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes\"&gt;&lt;img border=\"0\" src=\"http://wpa.qq.com/pa?p=2::52\" alt=\"联系客服\" title=\"联系客服\"/&gt;&lt;/a&gt; 图像定义图像的语法是: 1&lt;img src=\"url\" alt=\"som_text\" &gt; src 指 “source”。源属性的值是图像的 URL 地址,或图片的相对路径。 alt 为图像定义一串预备的可替换的文本。在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。 height（高度） 与 width（宽度）属性用于设置图像的高度与宽度，属性值默认单位为像素，也可以不设置。 1&lt;img src=\"./mm.jpg\" alt=\"这是一个女的\" width=\"300\" height=\"500\"&gt; 表格1234567891011121314151617181920212223&lt;table border=\"1\"&gt; &lt;caption&gt;个人信息统计&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;身高&lt;/th&gt; th&lt;th&gt;体重&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王大锤&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td colspan=\"2\" align=\"center\"&gt;170&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"..jpg\" width=\"60\" height=\"20\"&gt; &lt;div&gt;李小刀&lt;/div&gt; &lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;180&lt;/td&gt; &lt;td&gt;58&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;caption&gt; 定义表格标题 &lt;th&gt; 定义表格的表头 &lt;tr&gt; 定义表格的行 &lt;td&gt; 定义表格单元 align=&quot;center&quot; 居中 colspan=&quot;&quot; 合并 音频1234&lt;audio controls&gt; &lt;source src=\"horse.ogg\"&gt; &lt;source src=\"horse.mp3\"&gt;&lt;/audio&gt; controls 属性供添加播放、暂停和音量控件；可以换成autoplay 自动播放；autoplay loop自动循环播放。 \\ 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件 视频1234&lt;video width=\"320\" height=\"240\" controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt;&lt;/video&gt; controls 元素提供了 播放、暂停和音量控件来控制视频。 width 和 height 属性控制视频的尺寸.尽量不要写 区块区块元素 大多数 HTML 元素被定义为块级元素或内联元素。 块级元素在浏览器显示时，通常会以新行来开始（和结束）。 实例: \\, \\, \\, \\,\\ 内联元素 内联元素在显示时通常不会以新行开始。 实例: \\, \\, \\, \\ \\ 元素 \\ 元素是块级元素，它可用于组合其他 HTML 元素的容器。 \\ 元素 \\ 元素是内联元素，可用作文本的容器 表单 表单用于收集不同类型的用户输入。表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签 \\ 来设置 输入元素多数情况下被用到的表单标签是输入标签（\\）。 输入类型是由类型属性（type）定义的。 文本域（Text Fields）文本域通过\\ 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 123456789101112131415161718&lt;form action=\"\" method=\"post\" enctype=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;必填信息&lt;/legend&gt; &lt;p&gt; &lt;label&gt;用户名: &lt;/label&gt; &lt;input type=\"text\" name=\"uid\" placeholder=\"请输入用户名\" required&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;密码 &lt;/label&gt; &lt;input type=\"password\" name=\"pwd\"&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;性别: &lt;/label&gt; &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\" checked&gt;女 &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt; action “”里面是要提交的地址 method 规定如何发送表单数据（表单数据发送到 action属性所规定的页面）。共有两种方法：post 方法和 get 方法 – get get是从服务器上获取数据 get是把参数数据队列加到提交表单的action属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到 get传送的数据量较小。 get安全性非常低。 – post post是向服务器传送数据 post是通过HTTP post机制,将表单内各个字段与其内容放置在HTML HEADER内一起传送到action属性所指的URL地址。用户看不到这个过程。 post传送的数据量较大，一般被默认为不受限制。 post安全性较高。 enctype 属性规定在将表单数据发送到服务器之前如何对其进行编码。 注意：只有 method=”post” 时才使用 enctype 属性。 &lt;fieldset&gt;&lt;/fieldset&gt; 定义了一组相关的表单元素，并使用外框包含起来 &lt;legend&gt;&lt;/legend&gt; 定义了 \\ 元素的标题 &lt;label&gt; 定义了 \\ 元素的标签，一般为输入标题 &lt;input&gt; 输入标签输入类型是由类型属性（type）定义的。 name 属性规定表单的名称,用于在 JavaScript 中引用元素，或者在表单提交之后引用表单数据。 placeholder 属性规定可描述输入字段预期值的简短的提示信息,该提示会在用户输入值之前显示在输入字段中。 注意：placeholder 属性适用于下面的 input 类型：text、search、url、tel、email 和 password。 required 属性是一个布尔属性,规定必需在提交表单之前填写输入字段。 注意：required 属性适用于下面的 input 类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio 和 file。 密码字段密码字段通过标签\\ 来定义 单选按钮&lt;input type=&quot;radio&quot;&gt; 标签定义了表单单选框选项 checked选框默认选项 复选框\\ 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项 123456&lt;label&gt;爱好: &lt;/label&gt;&lt;input type=\"checkbox\" name=\"fav\"&gt;游戏&lt;input type=\"checkbox\" name=\"fav\" checked&gt;阅读&lt;input type=\"checkbox\" name=\"fav\" checked disabled&gt;旅游&lt;input type=\"checkbox\" name=\"fav\"&gt;运动&lt;input type=\"checkbox\" name=\"fav\"&gt;其他 checked disabled 默认必选项,不能取消. 文件上传1&lt;input type=\"file\" name=\"photo1\" multiple&gt; multiple 可接受多个值的文件上传字段 日期1&lt;input type=\"date\" name=\"b\"&gt; 下拉列表选项\\定义了下拉选项列表 \\定义下拉列表中的选项 12345678&lt;label&gt;籍贯: &lt;/label&gt;&lt;select&gt;name=\"prov\" &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option selected&gt;四川&lt;/option&gt; &lt;option&gt;云南&lt;/option&gt; &lt;option&gt;海南&lt;/option&gt;&lt;/select&gt; selected 默认选项 多行文本框\\ 标签定义一个多行的文本输入控件。文本区域中可容纳无限数量的文本，其中的文本的默认字体是等宽字体（通常是 Courier）。可以通过 cols 和 rows 属性来规定 textarea 的尺寸大小 字符实体12345678910111213141516 空格 &amp;nbsp;&lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt;&amp; 和号 &amp;amp;&quot; 引号 &amp;quot;&apos; 撇号 &amp;apos; (IE不支持)￠ 分 &amp;cent;£ 镑 &amp;pound; ¥ 人民币/日元 € 欧元 &amp;euro;§ 小节 &amp;sect;× 乘号 &amp;times; ÷ 除号 &amp;divide;© 版权 &amp;copy;® 注册商标 &amp;reg;™ 商标 &amp;trade; CSS什么是 CSS? CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明，声明总是以分号(;)结束，声明组以大括号({})括起来 就近原则 具体性原则 id选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器 重要性原则 盒子模型 1content（内容） - padding（内边距） - border（边框） - background-image（背景图片） - background-color（背景颜色） - margin（外边距） 边框和轮廓border 设置对象边框的特性 border-collapse : collapse 设置表格的边框合并为一个单一的边框 border-color 设置或检索对象的边框颜色 outline 设置或检索对象外的线条轮廓。 字体font-size 设置字体属性 font-family 规定文本的字体系列 font-style 规定文本的字体尺寸 font-weight 规定字体的粗细 文本color 指定文本的颜色 line-height 设置行高 text-align 规定文本的水平对齐方式 text-decoration 规定添加到文本的装饰效果，：none取消下划线 内边距padding 简写属性在一个声明中设置所有填充属性。该属性可以有1到4个值 padding-bottom 设置元素的底填充padding-left 设置元素的左填充padding-right 设置元素的右填充padding-top 设置元素的顶部填充 背景div是不支持background-color 的，background-color是table等的属性，你要用background：#（这里是颜色代码）；这样来写 background 复合属性，设置对象的背景特性 background-color 设置或检索对象的背景颜色background-image 设置或检索对象的背景图像 外边距margin 在一个声明中设置所有外边距属性，该属性可以有1到4个值 display属性display：none 此元素不会被显示。 display：block 此元素将显示为块级元素，此元素前后会带有换行符。 display：inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 hidden 元素是不可见的。 列表list-style 在一个声明中设置所有的列表属性list-style-position 设置列表项标记的放置位置 定位position:static; 正常文档流 position:relative; 相对定位 相对于元素原来的位置定位没有脱离文档流,对兄弟元素没有影响 position:absolute; 绝对定位(相对于父元素来设置位置 脱离了文档流 position:fixd； 固定定位（相对于浏览器窗口摆放） z-index 属性指定一个元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 float：left 元素向左浮动。 float：right 元素向右浮动。 黑科技 overflow: auto; 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 overflow: hidden 兄弟选择器 ~ 相邻兄弟选择器 + 12345安装字体@font-face &#123; font-family: '给字体起个名 '; src: url(路径);&#125; JavaScript​ ECMAScript - 语法规范 - ES5 (ECMA欧洲计算机制造商协会) ​ BOM - Browser Object Model - 浏览器对象模型 - window ​ DOM - Document Object Model - 文档对象模型 - document 编程范式(理念) 面向对象编程 函数式编程 层叠样式表前置, JS后置 外部脚本不能包含 \\ 标签。 document.getElementById(“some id”) 。这个方法是 HTML DOM 中定义的, 是用于访问 HTML 元素的正式 W3C 标准x.innerHTML=”Hello JavaScript”; //改变内容 输出JavaScript 显示数据 JavaScript 可以通过不同的方式来输出数据： 使用 window.alert() 弹出警告框。 alert() 方法用于显示带有一条指定消息和一个 确认 按钮的警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 操作 HTML 元素 如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。 请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容： 语法JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值 JavaScript 对大小写是敏感的 分号用于分隔 JavaScript 语句。通常我们在每条可执行的语句结尾添加分号。使用分号的另一用处是在一行中编写多条语句。 在文本字符串中使用反斜杠对代码行进行换行 注释单行注释以 // 开头 多行注释以 / 开始，以 / 结尾 数据类型和变量简单数据类型:字符串（String） 、数字(Number) 、布尔(Boolean) 、数组(Array) 、 空（Null） 、未定义（Undefined） 复杂数据类型: 对象(Object) 当声明新变量时，可以使用关键词 “new” 来声明其类型： JavaScript中有隐式的类型转换 ==比较，它会自动转换数据类型再比较 ===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 ===(全等于/严格等) !==(严格不等) 逻辑运算符: &amp;&amp;(短路与) 只有所有都为true，&amp;&amp;运算结果才是true，第一个为false后面的不再判断 ||(短路或) 只要其中有一个为true，||运算结果就是true，第一个为true后面的不再判断 ! (非) 作用域局部作用域变量在函数内声明，变量为局部作用域。 局部变量：只能在函数内部访问。 全局作用域变量在函数外定义，即为全局变量。 全局变量有 全局作用域 : 网页中所有脚本和函数均可使用。 如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。 JavaScript 变量生命周期JavaScript 变量生命周期在它声明时初始化。 局部变量在函数执行完毕后销毁。 全局变量在页面关闭后销毁。 JavaScript全局函数isNaN() - 是不是不是一个数 parseInt() - 取整数如果取不出返回NaN parseFloat() - 取小数如果取不出返回NaN isFinite() - 是不是有限数值 eval() - 非常强大的函数 evaluate - XSS(跨站脚本攻击) encodeURIComponent() - 处理成百分号编码 decodeURIComponent() - 将百分号编码解码还原 Date 对象创建 Date 对象： new Date() 方法 描述 getFullYear() 从 Date 对象以四位数字返回年份 getMonth() 从 Date 对象返回月份 (0 ~ 11) getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31) getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6) getHours() 返回 Date 对象的小时 (0 ~ 23) getMinutes() 返回 Date 对象的分钟 (0 ~ 59) getSeconds() 返回 Date 对象的秒数 (0 ~ 59) trim() 函数用于去除字符串两端的空白字符 parseInt() 将字符串转换成整数,提取数字 disabled .onclick 绑定与反绑定 递归定义 - - 定义的左边和定义的右边出现了相同的概念 递归调用 - - 函数直接或间接的调用了自身 收敛条件 - 什么时候就不用递归了 递归公式 window对象alert() 浏览器弹出带有一段消息和一个确认按钮的警告框 prompt() 显示可提示用户输入的对话框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 open() 打开一个新的浏览器窗口或查找一个已命名的窗口 close() 关闭浏览器窗口 setTimeout() 在指定的毫秒数后调用函数或计算表达式 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式 clearTimeout() 取消由 setTimeout() 方法设置的 timeout clearInterval() 取消由 setInterval() 设置的 timeout moveTo() 把窗口的左上角移动到一个指定的坐标 moveBy() 可相对窗口的当前坐标把它移动指定的像素 resizeBy() 按照指定的像素调整窗口的大小 window对象属性location - 用于窗口或框架的 Location 对象 属性: location.href 设置或返回当前显示的文档的完整 URL 1document.write(location.href); Location 对象方法: assign() 载入一个新的文档 // window.location.assign(URL) reload() 重新载入当前文档 // location.reload(); replace() 用新的文档替换当前文档 // location.replace(newURL) history - go() / fofward / back screen = avaiwidth / avaiHeight Document 对象查找元素的方法 getElementById() 返回对拥有指定 id 的第一个对象的引用 getElementsByTagName() 返回带有指定标签名的对象集合 getElementsByClassName() 返回文档中所有指定类名的元素集合 querySelector() 根据指定的选择器查找单个元素 querySelectorAll() 根据指定的选择器查找所有元素 绑定事件与取消绑定 document.addEventListener() 方法用于向文档添加事件句柄 document.removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄 element.addEventListener() 方法为指定元素添加事件句柄 1document.addEventListener(event, function) ​ - event 必需。描述事件名称的字符串。’click’ - 当用户点击某个对象时调用的事件句柄 ​ - function 必需。描述了事件触发后执行的函数 修改节点的内容和属性 textContent / innerHTML / nodeValue 访问成员运算符 setAttribute() / getAttribute() / removeAttribute() 创建新节点 - ()追加新的子节点 - appendChild() / insertBefore()删除子节点 - removeChild() 如果已经获得一个节点 如何访问它的父节点、子节点、兄弟节点parentNodechildren / firstChild / lastChildnextSibling / prevSibling DOM事件对象鼠标事件 onmousedown 鼠标按钮被按下 target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口 1event.target 事件捕获 - 从外向里传播事件 事件冒泡 - 从里向外传播事件 jQuery jQuery的$函数的作用: 1、 $(function() {}) - \\$函数中传入的参数是一个函数作用: 绑定页面加载完成之后要执行的回调函数 2、 $(selector) - \\$函数中传入的参数是一个选择器 ​ 作用: 通过选择器获得对应的元素并将其处理成jQuery对象jQuery对象本质是一个数组 ​ 如果需要将jQuery对象还原成原生的JS对象一[index]/get(index) 3、 $(elem) - \\$函数中传入的参数是原生JS对象 ​ 作用: 将原生JS对象转换成jQuery对象(更多的属性更多的方法) 4、 $(tag) - \\$函数中传入的参数是一个标签 ​ 作用: 和标签对应的元素(得到的是jQuery对身) 通过jQuery对象的方法可以用更少的代码做更多的事情 在写代码的时候不需要考虑浏览器兼容性问题(jQuery已经做了处理） 引入多个JS库出现冲突时可以通过下面的方式让出$函数 ​ jQuery.noConfict() ; 让出$函数以后原来用\\$函数的地方全部换成jQuery 查找元素 选择器 * / element / #id / .class / selector1, selector2 ancestor descendant / parent&gt;child / previous+next / previous~siblings 筛选器 基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains(‘…’) / :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute=’value’] / [attribute!=’value’] / [attribute^=’value’] / [attribute$=’value’] / [attribute|=’value’] / [attribute~=’value’] 表单： :input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked 执行操作 内容操作 获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val() 查找操作 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq() 尺寸和位置 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate() 事件 文档加载：ready() / load() 用户交互：on() / off() 回调函数 evt参数代表的是事件对象 - 绑定了和事件相关的所有信息 如果事件回调函数中要用到和事件相关的属性和方法就最好指定evt参数 target / clientX / button / keyCode preventDefault() / stopPropagation() 不管函数是否指定了evt参数当事件发生回调该函数时都会传入该参数 调构造函数 前面加new 数组里删元素要从后往前循环 Ajax原生Ajax - Asynchronous JavaScript and XML 让浏览器向服务器发出异步请求(非阻塞式请求)，等服务器返回了响应数据(JSON/XML)后就可以对页面进行局部刷 新，这样就可以在不中断用户体验的前提下刷新页面数据 JavaScript发送HTTP请求获取数据默认只支持同源数据(同源策略) http://www.abc.com/index.html -&gt; JavaScript 如果要跨域取数据是需要对方提供数据的服务器支持的 JSONP / 服务器端设置支持跨域取数据(RESTful)","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"关于MySQL查询操作","slug":"MySQL查询","date":"2018-05-16T00:43:09.000Z","updated":"2018-05-26T08:54:26.807Z","comments":true,"path":"2018/05/16/MySQL查询/","link":"","permalink":"http://yoursite.com/2018/05/16/MySQL查询/","excerpt":"","text":"MySQL查询12345数据库内容(重点):-- 关系型数据库中数据完整性指的是什么-- 1.实体完整性 : 每条记录都是独一无二的(主键/唯一约束/唯一索引)-- 2.参照完整性 : 表中的数据要参照其他表已有的数据(外键)-- 3.域完整性 : 数据是有效的(数据类型/非空约束/默认值约束/检查约束) 12345678910111213141516-- 表的设计原则 : 范式理论(1NF / 2NF / 3NF / BCNF)-- 范式级别指的是表设计的规范程度,范式级别越高规范程度也就越高-- 范式级别越高在插入/删除/更新数据时可能发生的问题就越少-- 而且表中的数据冗余度(重复)也就越低-- 实际开发中往往会降低范式级别来提升查询数据的性能-- 1NF - 列的属性值不能够再拆分(一列一值)-- 2NF - 除了主键列之外的列要完全依赖于主键-- 场景: 不同学院的学生可能有相同的学号-- 学生表(stuid, sname, ssex, did, dname , dtel)-- 主键(stuid, did)-- sname 和 ssex依赖于stuid, 而dname和dtel依赖于did-- 这种依赖是部分依赖而不是完全依赖所以不满足2NF-- 3NF - 消除传递依赖-- 场景: 整个学校学生的学号是惟一的-- 学生表(stuid, sname, ssex, did, dname , dtel)-- 主键(stuid) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149DCL :-- 创建用户并指定登录口令create user hellokitty identified by &apos;123123&apos;;-- 授予权限和召回权限grant all on shcool.tb_student to hellokitty;revoke all on shcool.tb_student from hellokitty;grant select all on shcool.tb_student to hellokitty;grant all on school.* to hellokitty;grant all on *.* to &apos;hellokitty&apos;@&apos;%&apos;;revoke all on *.* from hellokitty;-- 删除用户drop user hellokitty;---------------------------------------------------查询(重点)查学生表所有行所有列select * from tb_student查课程所有表所有列select * from tb_course-- 笛卡尔积select * from tb_student, tb_course;-- 投影和别名: 查询所有课程名称及学分select sname as 姓名, ssex as 性别 from tb_student;select sname as 姓名, case ssex when 1 then &apos;男&apos; else &apos;女&apos; end as 性别 from tb_student;select sname as 姓名, if(ssex, &apos;男&apos;, &apos;女&apos;) as 性别 from tb_student;-- 筛选: 查询所有女学生的姓名和出生日期-- = / &lt;&gt; / &gt; / &lt; / &gt;= / &lt;= / is null / is not null select sname, sbirth from tb_student where ssex=0;select courseid, cname from tb_course where ccredit&gt;2;-- 范围筛选: 查询所有80后学生的姓名、性别和出生日期select sanme, ssex, sbirth from tb_studentwhere &apos;1980-1-1&apos;&lt;=sbirth and sbirth&lt;=&apos;1989-12-31&apos;;select sanme, ssex, sbirth from tb_studentwhere sbirth between &apos;1980-1-1&apos; and &apos;1989-12-31&apos;;-- 模糊查询: 查询姓王的学生姓名和性别select * from tb_student where sanme=&apos;杨过&apos;;select * from tb_student where sanme like&apos;杨%&apos;;通配符(widcard)% (通配符)代表0个或多个任意字符-- 模糊查询: 查询姓杨名字总共两个字的学生的姓名select * from tb_student where sanme like&apos;杨_&apos;;-- 模糊查询: 查询姓杨名字总共三个字的学生的姓名select * from tb_student where sanme like &apos;杨__&apos;;-- 模糊查询: 查询名字中有杨字的学生的姓名(模糊)select * from tb_student where sanme like &apos;%杨%&apos;;-- 多条件和空值处理: 查询没有录入生日和家庭住址的学生姓名-- 在判断一个列是否为null的时候不能用=或&lt;&gt;而要使用is或者is notselect * from tb_student where sbirth is null or saddr is null;-- 去重(distint): 查询学生的籍贯select distinct saddr from tb_student where saddr is not null;-- 排序: 查询学生的姓名和生日按年龄从大到小排列select * from tb_student order by ssex asc(升序), sbirth desc(降序);有删选条件排序时先删选再排序select * from tb_student order by ssex asc, sbirth desc;-- 筛选和排序: 查询所有录入了家庭住址的男学生的姓名、出生日期和家庭住址按年龄从小到大排列select sname, sbirth, saddr from tb_studentwhere saddr is not null and ssex=1order by sbirth desc;-- 聚合函数: 查询年龄最大的学生的出生日期-- MySQL特有函数: now() / if()-- 最常用五个聚合函数:-- max() / min() / sum() / avg()-平均 / count() - 计数select min(sbirth) from tb_student;select max(sbirth) from tb_student;-- 分组查询: 查询男女学生的人数select count(stuid) from tb_student;select count(stuid) from tb_student where ssex=1;-- 经验 : 在使用group by 分组时如果不希望执行默认的排序操作-- 可以在分组后使用order by null 来避免默认的排序操作提升查询性能select if(ssex, &apos;男&apos;, &apos;女&apos;) as 性别, count(*) as 人数from tb_student group by ssex;order by - 排序 / group by - 分组查询asc (升序 - 从小到大) / desc(降序 - 从大到小)先筛选 - 再分组 - 再排序 (重点) - 否则会导致语法错误select if(ssex, &apos;男&apos;, &apos;女&apos;) as 性别, count(*) as 人数from tb_student where saddr is not nullgroup by ssexorder by ssex desc;-- 聚合函数: 查询课程编号为1111的课程的平均成绩-- 聚合函数会自动排除空值,不会纳入计算select cid, avg(score) from tb_scwhere cid=1111;-- where 子句构造的筛选是分组以前的筛选-- 如果希望对分组以后的数据进行筛选那么要写having子句而不是where子句select cid, avg(score) from tb_scgroup by cid having avg(score) &lt; 80;-- 聚合函数: 查询学号为1001的学生所有课程的平均成绩select sid, avg(score) from tb_scwhere sid=1001;-- 子查询: 查询年龄最大的学生的姓名(在查询里嵌套别的查询) -- 重点select sname, sbirth from tb_studentwhere sbirth=(select min(sbirth) from tb_student);去掉更多记录的条件放到右边 - SQL语句 (优化)-------------------------------------------------------- 连接查询 : 注意 : 给表别名不写as / 给列别名写as要点 : 从里往外写 - 先写子查询 - -- 自然连接select sname, cname, scorefrom tb_sc, tb_student, tb_coursewhere sid=stuid and cid=courseid;-- 连接查询: 查询选课学生的姓名和平均成绩select sname, avgScore from tb_student t1,(select sid, avg(score) as avgScore from tb_scgroup by sid) t2where stuid=sid;-- 连接查询: 查询学生姓名、所选课程名称和成绩select sname, total from tb_student t1,(select sid, count(sid) as total from tb_scgroup by sid) t2where stuid=sid;如果表里的列有同名.可以加一个前缀来别名加以区分-- 左外连接 : 左表(写在前面的表)不满足连表条件的记录也要查询出来select sname, if(total, total, 0) from tb_student t1left outer join(select sid, count(sid) as total from tb_scgroup by sid) t2on stuid=sid或者 - 两种方法结果是一样的select sname, ifnull(total, 0) from tb_student t1left outer join(select sid, count(sid) as total from tb_scgroup by sid) t2on stuid=sidinner join --- 内连接 --- 数据库特定写法 ------ 分页查询 select sname, cname, score from tb_scinner join tb_student on sid=stuidinner join tb_course on cid=courseid以下三种写法:-- limit 5;-- limit 0, 5;limit 5 offset 10;先筛选 - 分页 - 排序 - 分组 领域特定语言 - 不完备 - 只能做某个领域特定的事情图灵语言 - 完备 - Pythonlow_p - 低优先级重点:-- 经验: 尽可能不使用distinct去重和in集合运算-- SQL优化-- 想去掉distinct和in运算可以使用exists(查询结果是否存在)和not exists操作相应场景下 去重 / 集合 用下面方法操作:select ename, job from tbemp t1where exists(select &apos;x&apos; from tbemp t2 where t1.empno=t2.mgr);x 为 任意值python程序中操作数据库 --- 预习 12建表建库脚本保存 :没有备份前千万别删数据库 - 备份 - 新建备份 - 保存到桌面 - 删除数据库后 - 可以还原数据库 - 123456789101112131415161718192021222324252627282930了解有印象 索引 . 视图 . 过程 -- 索引相当于是一个目录,他可以加速查询提升查询效率-- 索引是典型的用空间换时间的技术-- 索引会加速查询但是会让增删改变得更慢, 因为增删改数据时索引也要更新创建索引(有了索引就有了目录) - 空间换时间 - 加快查询速度 - 但是增删改就变慢了 - 用于用户经常用哪个字段字段查询(例如商品搜索建索引是建在商品的名字上) : create index idx_emp_ename on TbEmp (ename);删除索引 : drop index index_emp_ename;检查索引 : show index from TbEmp-- 视图 : 保存某个查询的查询结果-- 通过视图可以将用户对表的查询权限限制在某些列上-- 也就是说不同的用户可以看你到原始表的不同列的数据创建视图 : create or replace view v_gfs as (创建或者替换一个叫v_gfs的视图, 如果存在v_gfs视图就替换, 如果不存在就创建一个)查视图 : select * from v_dept_total;-- 函数和过程 : 用来封装重复的操作-- 函数可以产生返回值而过程没有返回值的-- 函数和(存储)过程都是存储在数据库服务器端编译好的二进制程序-- 所以直接调用函数和过程其执行效率比直接向数据库发出SQL语句更高-- 如果希望简化调用并改善性能就可以考虑使用存储过程-- 创建存储过程 create procedure ...in : 输入参数 / out : 输出参数-- 调用存储过程 call -- 性能好 --- 安全性好 --- 使用调用上更简单(优化数据库就调存储过程)定义变量一定要@开头定义变量名call sp_dept_avg_sal(20, @avgSal);select @avgSal-- 创建触发器 - 对数据表进行增删改时就会触发事件(实际开发中避免使用 - 使用后会导致SQL性能急剧下降)-- 测试触发器","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"PyCharm的基本快捷键","slug":"PyCharm的快捷键","date":"2018-05-15T04:22:22.000Z","updated":"2018-05-26T05:06:50.205Z","comments":true,"path":"2018/05/15/PyCharm的快捷键/","link":"","permalink":"http://yoursite.com/2018/05/15/PyCharm的快捷键/","excerpt":"","text":"Windows下Python IDE PyCharm的基本快捷键 1、编辑（Editing) Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 Shift + F1 外部文档 Ctrl + 鼠标 简介 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行 Ctrl + Y 删除选定的行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开折叠代码块 Ctrl + Numpad+ 全部展开 Ctrl + Numpad- 全部折叠 Ctrl + F4 关闭运行的选项卡 2、查找/替换(Search/Replace) F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + F 全局查找 Ctrl + Shift + R 全局替换 3、运行(Running) Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 4、调试(Debugging) F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 5、导航(Navigation) Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡 F12 回到先前的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏运行的、最近运行的窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 当前文件弹出 Ctrl+Alt+Left/Right 后退、前进 Ctrl+Shift+Backspace 导航到最近编辑区域 Alt + F1 查找当前文件或标识 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I查看快速定义 Ctrl + Shift + B跳转到类型声明 Ctrl + U跳转到父方法、父类 Alt + Up/Down跳转到上一个、下一个方法 Ctrl + ]/[跳转到代码块结束、开始 Ctrl + F12弹出文件结构 Ctrl + H类型层次结构 Ctrl + Shift + H方法层次结构 Ctrl + Alt + H调用层次结构 F2 / Shift + F2下一条、前一条高亮的错误 F4 / Ctrl + Enter编辑资源、查看资源 Alt + Home显示导航条F11书签开关 Ctrl + Shift + F11书签助记开关 Ctrl + #[0-9]跳转到标识的书签 Shift + F11显示书签 6、搜索相关(Usage Search) Alt + F7/Ctrl + F7文件中查询用法 Ctrl + Shift + F7文件中用法高亮显示 Ctrl + Alt + F7显示用法 7、重构(Refactoring) F5复制F6剪切 Alt + Delete安全删除 Shift + F6重命名 Ctrl + F6更改签名 Ctrl + Alt + N内联 Ctrl + Alt + M提取方法 Ctrl + Alt + V提取属性 Ctrl + Alt + F提取字段 Ctrl + Alt + C提取常量 Ctrl + Alt + P提取参数 8、控制VCS/Local History Ctrl + K提交项目 Ctrl + T更新项目 Alt + Shift + C查看最近的变化 Alt + BackQuote(‘)VCS快速弹出 9、模版(Live Templates) Ctrl + Alt + J当前行使用模版 Ctrl +Ｊ插入模版 10、基本(General) Alt + #[0-9]打开相应的工具窗口 Ctrl + Alt + Y同步 Ctrl + Shift + F12最大化编辑开关 Alt + Shift + F添加到最喜欢 Alt + Shift + I根据配置检查当前文件 Ctrl + BackQuote(‘)快速切换当前计划 Ctrl + Alt + S 打开设置页 Ctrl + Shift + A查找编辑器里所有的动作 Ctrl + Tab在窗口间进行切换","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"数据库MySQL","slug":"数据库MySQL","date":"2018-05-14T01:03:01.000Z","updated":"2018-05-26T08:45:13.933Z","comments":true,"path":"2018/05/14/数据库MySQL/","link":"","permalink":"http://yoursite.com/2018/05/14/数据库MySQL/","excerpt":"","text":"数据库MySQL11.Windows系统数据库的安装 - MySQL severs - 5.7全选 - 开发机 - 端口设定默认3306 - next - finish 122.启动服务器 : 1.我的电脑 - 右键管理员 - 服务和应用程序 - 服务 - MySQL2.命令行提示符 - 管理员身份运行 - net start / stop mysql57(启 / 停) 12345678MySQL5.7 Command Line Client - Unicode1. 任务菜单栏 - 双击打开 MySQL5.7 Command Line Client - Unicodepassword - 输入自己设定的MySQL密码show databases; - 查看所有数据库select version(); - 查看服务器版本? - 帮助quit - 退出2 . 命令行提示符 - mysql -u root -p (需要配置环境变量) 关系型数据库1234一 . 为什么要使用数据库?数据持久化 - 将数据从一掉电数据就丢失的存储介质(内存)转移到持久存储介质(硬盘)普通文件 / 二进制文件 / Excel / 数据库数据库 - 高效的存储和管理数据方便的检索数据 123456789二 . 什么是关系型数据库?关系型数据库特点 :1.理论基础 - 集合论和关系代数2.(最大.直观的特点) - 用二维表组织数据表 - 实体(一张表就是一个实体)行 - 记录列 - 字段表与表之间有关系编程语言 - SQL - 结构化查询语言(重点) 1234567891011三 . 数据库 . 数据库系统 . 数据库管理系统 ?数据库 - Database - DB - 数据的仓库(集散地)数据库系统 - DBS - 包括了DB . DBMS . DBA(数据库管理员)(R)DBMS - (关系型)数据库管理系统 - 管理数据库的软件关系型数据库产品: - MySQL - 小巧但是强大 - Oracle - 安全强大 商业智能分析 (银行 .金融 . 电商) 昂贵 - DB2 - 安全强大 商业智能 (银行 .金融 . 电商) 昂贵 - SQL Server (几乎用不到) - SQLite - 嵌入式数据库(移动端) 123456四 . 怎么使用MySQL ?数据库服务器和客户端工具MySQL客户端工具:- SQLyog- Toad for MySQL- Navicat for MySQL Navicat for MySQL的使用 :123456789101112131415161718192021222324252627282930313233343536373839404142Navicat for MySQL 的使用链接 - 输入相应内容与密码 - 连接数据库 - SQL(Structured Query Language) - 关系型数据库的编程语言- DDL(数据定义语言): create(创建) / drop(删除) / alter(修改)- DML(数据操纵语言): insert(嵌入) / delete(删除) / update(更新)- DQL(数据查询语言): select(挑选)- DCL(数据控制语言): grant(允许) / revoke(撤回) / begin(开始) / commit(提交) / rollback(反转)实际操作中:假如指定数据库名称为school1.如果指定的数据库存在则删除该数据库drop database if exists school(指定数据库名称);2.创建数据库并指定默认的字符集create database school default charset utf8;3.切换到school数据库use school4.删除学生表drop table if exists tb_student;-- 主键(primary key) - 能够标识唯一一条记录的列-- varchar 不定长字符串的最大长度 / var 定长字符串的长度 / default 默认值-- comment 注释语句 后面的字符串要加单引号5.创建学生表create table tb_student(stuid int not null comment &apos;学号&apos;,sname varchar(10) not null comment &apos;姓名&apos;,ssex bit default 1 comment &apos;性别&apos;, stel char(11) comment &apos;联系电话&apos;, sbirth date comment &apos;出生日期&apos;,primary key (stuid) );6.修改学生表alter table tb_student add column saddr varchar(100); -- 添加列alter table tb_student drop column stel; -- 删除列7.插入学生记录insert into tb_student values (1001, &apos;王大锤&apos;, 1, &apos;1990-2-12&apos;, &apos;四川成都&apos;);insert into tb_student (stuid, sname) values (1002, &apos;骆昊&apos;);insert into tb_student (stuid, sname, ssex) values (1003, &apos;李飘飘&apos;, 0);insert into tb_student values(1004, &apos;张三丰&apos;, 1, &apos;1940-12-3&apos;, &apos;湖北武汉&apos;),(1005, &apos;黄蓉&apos;, 0, &apos;1975-3-25&apos;, &apos;山东东营&apos;),(1006, &apos;杨过&apos;, 1, &apos;1987-1-19&apos;, &apos;湖南长沙&apos;);","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Linux","slug":"Linux命令操作","date":"2018-05-12T01:36:23.000Z","updated":"2018-05-26T08:50:13.422Z","comments":true,"path":"2018/05/12/Linux命令操作/","link":"","permalink":"http://yoursite.com/2018/05/12/Linux命令操作/","excerpt":"","text":"Liunx12时间和空间是不可调和的矛盾硬件和软件在逻辑上是等效的 基础命令12345678910111213141516171819202122232425261. 获取登录信息 -- w/who/last(查看登录历史记录)2. 查看自己使用的Shell -- ps ps -aux | grep nginx 查看进程 3. 查看命令的说明 -- whatis [root@ping ~]# whatis python 4. 查看命令的位置 -- which / whereis5. 查看帮助文档 -- man / info / apropos / help man 关键字 查看帮助文档 help -m 关键字 显示较详细的使用方法6. 切换用户命令 -- su7. 以管理员身份执行命令 -- sudo8. 登入登出相关 -- logout / exit / adduser / userdel / passwd / ssh ssh root @47.106.99.221 远程访问服务器 9. 查看系统的主机名 - uname / hostname [root@ping ~]# cat /etc/centos-release 查看服务器版本号 CentOS release 6.8 (Final) 10. 重启和关机 -- reboot / init 6 / shutdown / init 0 文件操作1. 查看/切换目录 — pwd / cd / ls1234567891011121314pwd -- print working directory 打印当前工作目录 cd -- 切换路径 ./ 当前路径 ../ 上一级路径 /home/gavinliu/ /开头 绝对路径 ../../ 相对路径 cd / 根目录 ls -- list directory contents 查看目录内容 ls -l 查看目录详情 ls -a 查看所有目录详情(显示影藏文件(.开头的文件/文件夹)) ls -R 递归展开目录 ls -r 倒序展开 2. 创建/删除目录 — mkdir / rmdir123mkdir -- make directory 创建文件目录rmdir -- remove directory 移除文件目录(只能删除空文件夹) 3. 创建/删除文件 — touch / rm12345678rm -- remove 删除文件/文件夹 rm -r 递归删除 rm -i 交互式 rm -f false touch 文件名 文件不存在 --&gt; 创建空文件 文件存在 --&gt; 更新文件最后的访问和修改时间 4. 查看/搜索文件内容 — cat / head / tail12345678cat -- 查看文件内容more -- 分页查看 more index.html / cat index.html | more(管道) ls -l | grep hello 查看带hello的文件 head -- 查看文件开头部分 head -10 index.html(查看文件前10行)tail -- 查看文件末尾部分 tail -10 index.html(查看文件最后10行) 5. 查看文件及内容 — find / grep123456find -- 搜索文件 --&gt; 显示文件 目录/文件grep -- 搜索文件内容 grep div index.html / cat index.html | grep div (匹配div) grep '&lt;div .*&gt;' index.html -n(搜索&lt;div&gt;,并给出行号) grep '&lt;div .*&gt;' index.html / -R -n &gt; result.txt 2&gt; error.txt &amp; 6. 拷贝移动文件 — cp / mv1234567cp -- 拷贝文件 cp file pathscp -- 拷贝文件到服务器 scp hello.txt root@119.27.166.245:~/abc/ mv -- 移动文件 格式: mv file path 移动文件夹 格式: mv dir path 重命名 格式: mv hello.py helloworld.py 7. 符号链接 — ln123ln -- link链接 ln 创建硬链接(文件引用) ln index.html ~/abc/index1.html ln -s file softlink 创建软连接(快捷方式) ln -s /etc/centos-release sysver 8. 压缩 / 归档 — gzip / gunzip / xz / tar123456789101112131415.xz .gz 压缩文件gunzip -- 解压缩 gunzip redis-3.2.11.tar.gz --&gt; redis-3.2.11.targzip -- 压缩 gzip dog.jpg --&gt; dog.jpg.gz xz -- 压缩/解缩压 xz -d 解压缩 xz -z -num(压缩比) 压缩 xz -z dog.jpg --&gt; dog.jpg.xz tar -- 归档/解归档 tar -cf file 归档(静默处理) tar -cvf redis-3.2.11.tar tar -xf file 解归档(静默处理) tar -xvf redis-3.2.11.tar tar -tf file 查看归档文件内容 tar -tf redis-3.2.11.tar 9. 其他工具12345678910111213141516171819wget -- 在网上下载文件 wget http://www.taobao.com/index.html wget -O 文件重命名wc -- word count 数单词数/行数 wc -w 单词 wc -w index.html wc -l 行数 wc -l index.html uniq -- 去重(相邻行)sort -- 排序(不改变原文件)diff -- 版本比较(文件)file -- 分析文件性质(根据文件内容区分) file hello.txt --&gt; hello.txt: UTF-8 Unicode text echo -- 回声命令 echo $PATH 查看变量的值 echo \"print('hello')\" &gt; hello.py 创建文件并向里面添加内容 10. 文件权限12345678910111213所有者u 同组用户g 其他用户orwx r-x r-xrwx rwx rwx111 111 1117 7 7111 7110 6100 4r read 读w write 写x excute 执行chmod u+x,g+x,o+x guess1.py 给所有者添加权限chmod 777 guess1.py 给所有者添加权限 管道和重定向123456789101. 管道 -- | ls -l | grep hello 查看带hello的文件 2. 重定向 -- &gt; &gt; 输出重定向 2&gt; 存放错误文件(覆盖) &gt;&gt; 追加输出重定向 &lt; 输入重定向 &amp; 在后台执行 其他程序123456789wall -- 向所有人发消息mssg n/y -- 拒绝/同意接收消息alias -- 命令重命名 --&gt; unalias alias foo='tar -xf' history -- 查询所有执行过的命令 !num -- 执行命令 liunx目录1234567/ 根目录下面文件夹 root -- 用户主目录(超级管理员) home -- 用户主目录(其他管理员) ect -- 存储linux系统配置/软件配置 usr -- B -- Byte 字节b -- bit 位 包管理工具 — 安装软件yum12345678yum - yellowdog updater modified 包管理工具 yun install / yum remove 安装 / 卸载 yun list / yum search 查看 / 搜索 yum list installed 显示所有已安装软件 yum install nginx 安装nginx yum nginx search 搜索软件 yum install mariadb-server mariadb 安装数据库服务器 数据库客户端 yum update 更新 rpm12345RPM - redhat package manager 红帽子的包管理工具 rpm -i 静默安装 / -ivh 显示安装过程 rpm -e 移除 rpm -qa 显示所有已安装的包 rpm -qa | grep jdk | xargs rpm -e 删除管道过滤出来的jdk (xargs 将xargs前面的结果作为后面命令的参数使用) 源码安装123456tar.gz / tar.xz ungizp / xz -d 解压缩 tar -xvf 解归档 配置PATH环境变量 临时 export ... 永久 vim .bash_profile --&gt; 添加环境变量 nginx12nginx 启动nginxnginx -s stop | quit | reopen | reload redis12345678910111213141516redis.conf 61 -- bind 172.27.0.11 内网地址 84 -- port 6379 默认端口 480 -- requirepass liutc1014? 删除注释,修改密码 redis-server 服务器 redis-server myredis.conf 启动redis服务器 redis-server myredis.conf &gt; myredis.log &amp; 后台运行 关闭服务器 jobs --&gt; fg %1 --&gt; ^c 关闭redis服务器(自动保存) kill 进程号 关闭redis服务器 不保存 redis-cli 客户端redis-cli -h 172.27.0.11(内网地址) -p 端口号(默认端口可以省略) 连接服务器 auth liutc1014? 验证 ping 查看是否连接 查看进程 / 任务123456789jobs -- 查看有无后台任务在执行fg %1 将后台任务放到前台执行^z 将放到前台执行的任务放到后台并停止执行bg %1 将放到前台执行的任务放到后台执行ps -aux 查看已启动进程 ps -aux | grep ngnix netstat -nap 查看进程号 netstat -nap | grep 80(端口号) systemctl — 服务管理工具12345678910111213141. systemctl --&gt; CentOS7 启动一个服务：systemctl start firewalld.service 关闭一个服务：systemctl stop firewalld.service 重启一个服务：systemctl restart firewalld.service 显示一个服务的状态：systemctl status firewalld.service 在开机时启用一个服务：systemctl enable firewalld.service 在开机时禁用一个服务：systemctl disable firewalld.service 查看服务是否开机启动：systemctl is-enabled firewalld.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed1. service -- (CentOS 7 以前) service firewall start service firewall status 查看状态 CentOS 7打开关闭防火墙端口123456789101112131415161718192021221. firewalld的基本使用 启动： systemctl start firewalld 查看状态： systemctl status firewalld 停止： systemctl disable firewalld 禁用： systemctl stop firewalld 2. 配置firewalld-cmd 查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd --zone=public --list-ports 更新防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 3. 配置端口 添加 firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效） 重新载入 firewall-cmd --reload 查看 firewall-cmd --zone= public --query-port=80/tcp 删除 firewall-cmd --zone= public --remove-port=80/tcp --permanent mac终端与服务器下上传下载内容1234sftp root@IP 链接服务器put 上传文件get 下载文件bye 退出 1234DNS - 域名翻译成IP地址HTTP服务器 - LAMP = Linux + Apache + MysQL + PHP LNMP = Linux + Nginx +MySQL + Pythg","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}